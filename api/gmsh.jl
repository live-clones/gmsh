# Gmsh - Copyright (C) 1997-2018 C. Geuzaine, J.-F. Remacle
#
# See the LICENSE.txt file for license information. Please report all
# bugs and problems to the public mailing list <gmsh@onelab.info>.

# This file defines the Gmsh Julia API (v3.0).
#
# Do not edit it directly: it is automatically generated by `api/gen.py'.
#
# By design, the Gmsh Julia API is purely functional, and only uses elementary
# types. See `demos/api' for examples.

"""
    module gmsh

Top-level functions
"""
module gmsh

const GMSH_API_VERSION = "3.0"
const clib = is_windows() ? "gmsh-3.0" : "libgmsh"

"""
    gmsh.initialize(argv = Vector{String}(), readConfigFiles = true)

Initialize Gmsh. This must be called before any call to the other functions in
the API. If `argc` and `argv` are provided, they will be handled in the same way
as the command line arguments in the Gmsh app. If `readConfigFiles` is set, read
system Gmsh configuration files (gmshrc and gmsh-options).
"""
function initialize(argv = Vector{String}(), readConfigFiles = true)
    ierr = Ref{Cint}()
    ccall((:gmshInitialize, clib), Void,
          (Cint, Ptr{Ptr{Cchar}}, Cint, Ptr{Cint}),
          length(argv), argv, readConfigFiles, ierr)
    ierr[] != 0 && error("gmshInitialize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.finalize()

Finalize Gmsh. This must be called when you are done using the Gmsh API.
"""
function finalize()
    ierr = Ref{Cint}()
    ccall((:gmshFinalize, clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshFinalize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.open(fileName)

Open a file. Equivalent to the `File->Open` menu in the Gmsh app. Handling of
the file depends on its extension and/or its contents.
"""
function open(fileName)
    ierr = Ref{Cint}()
    ccall((:gmshOpen, clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          fileName, ierr)
    ierr[] != 0 && error("gmshOpen returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.merge(fileName)

Merge a file. Equivalent to the `File->Merge` menu in the Gmsh app. Handling of
the file depends on its extension and/or its contents.
"""
function merge(fileName)
    ierr = Ref{Cint}()
    ccall((:gmshMerge, clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          fileName, ierr)
    ierr[] != 0 && error("gmshMerge returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.write(fileName)

Write a file. The export format is determined by the file extension.
"""
function write(fileName)
    ierr = Ref{Cint}()
    ccall((:gmshWrite, clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          fileName, ierr)
    ierr[] != 0 && error("gmshWrite returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.clear()

Clear all loaded models and post-processing data, and add a new empty model.
"""
function clear()
    ierr = Ref{Cint}()
    ccall((:gmshClear, clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshClear returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    module gmsh.option

Global option handling functions
"""
module option

import ..gmsh

"""
    gmsh.option.setNumber(name, value)

Set a numerical option to `value`. `name` is of the form "category.option" or
"category[num].option". Available categories and options are listed in the Gmsh
reference manual.
"""
function setNumber(name, value)
    ierr = Ref{Cint}()
    ccall((:gmshOptionSetNumber, gmsh.clib), Void,
          (Ptr{Cchar}, Cdouble, Ptr{Cint}),
          name, value, ierr)
    ierr[] != 0 && error("gmshOptionSetNumber returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.option.getNumber(name, value)

Get the `value` of a numerical option.

Return 'value'.
"""
function getNumber(name)
    api_value_ = Ref{Cdouble}()
    ierr = Ref{Cint}()
    ccall((:gmshOptionGetNumber, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cdouble}, Ptr{Cint}),
          name, api_value_, ierr)
    ierr[] != 0 && error("gmshOptionGetNumber returned non-zero error code: $(ierr[])")
    return api_value_[]
end

"""
    gmsh.option.setString(name, value)

Set a string option to `value`.
"""
function setString(name, value)
    ierr = Ref{Cint}()
    ccall((:gmshOptionSetString, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          name, value, ierr)
    ierr[] != 0 && error("gmshOptionSetString returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.option.getString(name, value)

Get the `value` of a string option.

Return 'value'.
"""
function getString(name)
    api_value_ = Ref{Ptr{Cchar}}()
    ierr = Ref{Cint}()
    ccall((:gmshOptionGetString, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Ptr{Cchar}}, Ptr{Cint}),
          name, api_value_, ierr)
    ierr[] != 0 && error("gmshOptionGetString returned non-zero error code: $(ierr[])")
    value = unsafe_string(api_value_[])
    return value
end

end # end of module option

"""
    module gmsh.model

Per-model functions
"""
module model

import ..gmsh

"""
    gmsh.model.add(name)

Add a new model, with name `name`, and set it as the current model.
"""
function add(name)
    ierr = Ref{Cint}()
    ccall((:gmshModelAdd, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          name, ierr)
    ierr[] != 0 && error("gmshModelAdd returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.remove()

Remove the current model.
"""
function remove()
    ierr = Ref{Cint}()
    ccall((:gmshModelRemove, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelRemove returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.list(names)

List the names of all models.

Return 'names'.
"""
function list()
    api_names_ = Ref{Ptr{Ptr{Cchar}}}()
    api_names_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelList, gmsh.clib), Void,
          (Ptr{Ptr{Cchar}}, Ptr{Csize_t}, Ptr{Cint}),
          api_names_, api_names_n_, ierr)
    ierr[] != 0 && error("gmshModelList returned non-zero error code: $(ierr[])")
    tmp_api_names_ = unsafe_wrap(Array, api_names_[], api_names_n_[], true)
    names = [unsafe_string(tmp_api_names_[i]) for i in 1:length(tmp_api_names_) ]
    return names
end

"""
    gmsh.model.setCurrent(name)

Set the current model to the model with name `name`. If several models have the
same name, select the one that was added first.
"""
function setCurrent(name)
    ierr = Ref{Cint}()
    ccall((:gmshModelSetCurrent, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          name, ierr)
    ierr[] != 0 && error("gmshModelSetCurrent returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.getEntities(dimTags, dim = -1)

Get all the (elementary) geometrical entities in the current model. If `dim` is
>= 0, return only the entities of the specified dimension (e.g. points if `dim`
== 0). The entities are returned as a vector of (dim, tag) integer pairs.

Return 'dimTags'.
"""
function getEntities(dim = -1)
    api_dimTags_ = Ref{Ptr{Cint}}()
    api_dimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetEntities, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          api_dimTags_, api_dimTags_n_, dim, ierr)
    ierr[] != 0 && error("gmshModelGetEntities returned non-zero error code: $(ierr[])")
    tmp_api_dimTags_ = unsafe_wrap(Array, api_dimTags_[], api_dimTags_n_[], true)
    dimTags = [ (tmp_api_dimTags_[i], tmp_api_dimTags_[i+1]) for i in 1:2:length(tmp_api_dimTags_) ]
    return dimTags
end

"""
    gmsh.model.getPhysicalGroups(dimTags, dim = -1)

Get all the physical groups in the current model. If `dim` is >= 0, return only
the entities of the specified dimension (e.g. physical points if `dim` == 0).
The entities are returned as a vector of (dim, tag) integer pairs.

Return 'dimTags'.
"""
function getPhysicalGroups(dim = -1)
    api_dimTags_ = Ref{Ptr{Cint}}()
    api_dimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetPhysicalGroups, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          api_dimTags_, api_dimTags_n_, dim, ierr)
    ierr[] != 0 && error("gmshModelGetPhysicalGroups returned non-zero error code: $(ierr[])")
    tmp_api_dimTags_ = unsafe_wrap(Array, api_dimTags_[], api_dimTags_n_[], true)
    dimTags = [ (tmp_api_dimTags_[i], tmp_api_dimTags_[i+1]) for i in 1:2:length(tmp_api_dimTags_) ]
    return dimTags
end

"""
    gmsh.model.getEntitiesForPhysicalGroup(dim, tag, tags)

Get the tags of all the (elementary) geometrical entities making up the physical
group of dimension `dim` and tag `tag`.

Return 'tags'.
"""
function getEntitiesForPhysicalGroup(dim, tag)
    api_tags_ = Ref{Ptr{Cint}}()
    api_tags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetEntitiesForPhysicalGroup, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          dim, tag, api_tags_, api_tags_n_, ierr)
    ierr[] != 0 && error("gmshModelGetEntitiesForPhysicalGroup returned non-zero error code: $(ierr[])")
    tags = unsafe_wrap(Array, api_tags_[], api_tags_n_[], true)
    return tags
end

"""
    gmsh.model.addPhysicalGroup(dim, tags, tag = -1)

Add a physical group of dimension `dim`, grouping the elementary entities with
tags `tags`. Return the tag of the physical group, equal to `tag` if `tag` is
positive, or a new tag if `tag` < 0.

Return an integer.
"""
function addPhysicalGroup(dim, tags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelAddPhysicalGroup, gmsh.clib), Cint,
          (Cint, Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          dim, convert(Vector{Cint}, tags), length(tags), tag, ierr)
    ierr[] != 0 && error("gmshModelAddPhysicalGroup returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.setPhysicalName(dim, tag, name)

Set the name of the physical group of dimension `dim` and tag `tag`.
"""
function setPhysicalName(dim, tag, name)
    ierr = Ref{Cint}()
    ccall((:gmshModelSetPhysicalName, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Ptr{Cint}),
          dim, tag, name, ierr)
    ierr[] != 0 && error("gmshModelSetPhysicalName returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.getPhysicalName(dim, tag, name)

Get the name of the physical group of dimension `dim` and tag `tag`.

Return 'name'.
"""
function getPhysicalName(dim, tag)
    api_name_ = Ref{Ptr{Cchar}}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetPhysicalName, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cchar}}, Ptr{Cint}),
          dim, tag, api_name_, ierr)
    ierr[] != 0 && error("gmshModelGetPhysicalName returned non-zero error code: $(ierr[])")
    name = unsafe_string(api_name_[])
    return name
end

"""
    gmsh.model.getBoundary(dimTags, outDimTags, combined = true, oriented = true, recursive = false)

Get the boundary of the geometrical entities `dimTags`. Return in `outDimTags`
the boundary of the individual entities (if `combined` is false) or the boundary
of the combined geometrical shape formed by all input entities (if `combined` is
true). Return tags multiplied by the sign of the boundary entity if `oriented`
is true. Apply the boundary operator recursively down to dimension 0 (i.e. to
points) if `recursive` is true.

Return 'outDimTags'.
"""
function getBoundary(dimTags, combined = true, oriented = true, recursive = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetBoundary, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), api_outDimTags_, api_outDimTags_n_, combined, oriented, recursive, ierr)
    ierr[] != 0 && error("gmshModelGetBoundary returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.getEntitiesInBoundingBox(xmin, ymin, zmin, xmax, ymax, zmax, tags, dim = -1)

Get the (elementary) geometrical entities in the bounding box defined by the two
points (`xmin`, `ymin`, `zmin`) and (`xmax`, `ymax`, `zmax`). If `dim` is >= 0,
return only the entities of the specified dimension (e.g. points if `dim` == 0).

Return 'tags'.
"""
function getEntitiesInBoundingBox(xmin, ymin, zmin, xmax, ymax, zmax, dim = -1)
    api_tags_ = Ref{Ptr{Cint}}()
    api_tags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetEntitiesInBoundingBox, gmsh.clib), Void,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          xmin, ymin, zmin, xmax, ymax, zmax, api_tags_, api_tags_n_, dim, ierr)
    ierr[] != 0 && error("gmshModelGetEntitiesInBoundingBox returned non-zero error code: $(ierr[])")
    tmp_api_tags_ = unsafe_wrap(Array, api_tags_[], api_tags_n_[], true)
    tags = [ (tmp_api_tags_[i], tmp_api_tags_[i+1]) for i in 1:2:length(tmp_api_tags_) ]
    return tags
end

"""
    gmsh.model.getBoundingBox(dim, tag, xmin, ymin, zmin, xmax, ymax, zmax)

Get the bounding box (`xmin`, `ymin`, `zmin`), (`xmax`, `ymax`, `zmax`) of the
geometrical entity of dimension `dim` and tag `tag`.

Return 'xmin', 'ymin', 'zmin', 'xmax', 'ymax', 'zmax'.
"""
function getBoundingBox(dim, tag)
    api_xmin_ = Ref{Cdouble}()
    api_ymin_ = Ref{Cdouble}()
    api_zmin_ = Ref{Cdouble}()
    api_xmax_ = Ref{Cdouble}()
    api_ymax_ = Ref{Cdouble}()
    api_zmax_ = Ref{Cdouble}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetBoundingBox, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Cint}),
          dim, tag, api_xmin_, api_ymin_, api_zmin_, api_xmax_, api_ymax_, api_zmax_, ierr)
    ierr[] != 0 && error("gmshModelGetBoundingBox returned non-zero error code: $(ierr[])")
    return api_xmin_[], api_ymin_[], api_zmin_[], api_xmax_[], api_ymax_[], api_zmax_[]
end

"""
    gmsh.model.getDimension()

Get the geometrical dimension of the current model.

Return an integer.
"""
function getDimension()
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGetDimension, gmsh.clib), Cint,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelGetDimension returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.addDiscreteEntity(dim, tag = -1, boundary = Cint[])

Add a discrete geometrical entity (defined by a mesh) of dimension `dim` in the
current model. Return the tag of the new discrete entity, equal to `tag` if
`tag` is positive, or a new tag if `tag` < 0. `boundary` specifies the tags of
the entities on the boundary of the discrete entity, if any. Specyfing
`boundary` allows Gmsh to construct the topology of the overall model.

Return an integer.
"""
function addDiscreteEntity(dim, tag = -1, boundary = Cint[])
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelAddDiscreteEntity, gmsh.clib), Cint,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          dim, tag, convert(Vector{Cint}, boundary), length(boundary), ierr)
    ierr[] != 0 && error("gmshModelAddDiscreteEntity returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.removeEntities(dimTags, recursive = false)

Remove the entities `dimTags` of the current model. If `recursive` is true,
remove all the entities on their boundaries, down to dimension 0.
"""
function removeEntities(dimTags, recursive = false)
    ierr = Ref{Cint}()
    ccall((:gmshModelRemoveEntities, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), recursive, ierr)
    ierr[] != 0 && error("gmshModelRemoveEntities returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.getType(dim, tag, entityType)

Get the type of the entity of dimension `dim` and tag `tag`.

Return 'entityType'.
"""
function getType(dim, tag)
    api_entityType_ = Ref{Ptr{Cchar}}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGetType, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cchar}}, Ptr{Cint}),
          dim, tag, api_entityType_, ierr)
    ierr[] != 0 && error("gmshModelGetType returned non-zero error code: $(ierr[])")
    entityType = unsafe_string(api_entityType_[])
    return entityType
end

"""
    module gmsh.model.mesh

Per-model meshing functions
"""
module mesh

import ...gmsh

"""
    gmsh.model.mesh.generate(dim = 3)

Generate a mesh of the current model, up to dimension `dim` (0, 1, 2 or 3).
"""
function generate(dim = 3)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGenerate, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          dim, ierr)
    ierr[] != 0 && error("gmshModelMeshGenerate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.partition(numPart)

Partition the mesh of the current model into `numPart` partitions.
"""
function partition(numPart)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshPartition, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          numPart, ierr)
    ierr[] != 0 && error("gmshModelMeshPartition returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.refine()

Refine the mesh of the current model by uniformly splitting the elements.
"""
function refine()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshRefine, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelMeshRefine returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setOrder(order)

Set the order of the elements in the mesh of the current model to `order`.
"""
function setOrder(order)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetOrder, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          order, ierr)
    ierr[] != 0 && error("gmshModelMeshSetOrder returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.getLastEntityError(dimTags)

Get the last entities (if any) where a meshing error occurred. Currently only
populated by the new 3D meshing algorithms.

Return 'dimTags'.
"""
function getLastEntityError()
    api_dimTags_ = Ref{Ptr{Cint}}()
    api_dimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetLastEntityError, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          api_dimTags_, api_dimTags_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetLastEntityError returned non-zero error code: $(ierr[])")
    tmp_api_dimTags_ = unsafe_wrap(Array, api_dimTags_[], api_dimTags_n_[], true)
    dimTags = [ (tmp_api_dimTags_[i], tmp_api_dimTags_[i+1]) for i in 1:2:length(tmp_api_dimTags_) ]
    return dimTags
end

"""
    gmsh.model.mesh.getLastNodeError(nodeTags)

Get the last nodes (if any) where a meshing error occurred. Currently only
populated by the new 3D meshing algorithms.

Return 'nodeTags'.
"""
function getLastNodeError()
    api_nodeTags_ = Ref{Ptr{Cint}}()
    api_nodeTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetLastNodeError, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          api_nodeTags_, api_nodeTags_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetLastNodeError returned non-zero error code: $(ierr[])")
    nodeTags = unsafe_wrap(Array, api_nodeTags_[], api_nodeTags_n_[], true)
    return nodeTags
end

"""
    gmsh.model.mesh.getNodes(nodeTags, coord, parametricCoord, dim = -1, tag = -1)

Get the nodes classified on the entity of dimension `dim` and tag `tag`. If
`tag` < 0, get the nodes for all entities of dimension `dim`. If `dim` and `tag`
are negative, get all the nodes in the mesh. `nodeTags` contains the node tags
(their unique, strictly positive identification numbers). `coord` is a vector of
length 3 times the length of `nodeTags` that contains the (x, y, z) coordinates
of the nodes, concatenated. If `dim` >= 0, `parametricCoord` contains the
parametric coordinates of the nodes, if available. The length of
`parametricCoord` can be 0 or `dim` times the length of `nodeTags`.

Return 'nodeTags', 'coord', 'parametricCoord'.
"""
function getNodes(dim = -1, tag = -1)
    api_nodeTags_ = Ref{Ptr{Cint}}()
    api_nodeTags_n_ = Ref{Csize_t}()
    api_coord_ = Ref{Ptr{Cdouble}}()
    api_coord_n_ = Ref{Csize_t}()
    api_parametricCoord_ = Ref{Ptr{Cdouble}}()
    api_parametricCoord_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetNodes, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          api_nodeTags_, api_nodeTags_n_, api_coord_, api_coord_n_, api_parametricCoord_, api_parametricCoord_n_, dim, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshGetNodes returned non-zero error code: $(ierr[])")
    nodeTags = unsafe_wrap(Array, api_nodeTags_[], api_nodeTags_n_[], true)
    coord = unsafe_wrap(Array, api_coord_[], api_coord_n_[], true)
    parametricCoord = unsafe_wrap(Array, api_parametricCoord_[], api_parametricCoord_n_[], true)
    return nodeTags, coord, parametricCoord
end

"""
    gmsh.model.mesh.getNode(nodeTag, coord, parametricCoord)

Get the coordinates and the parametric coordinates (if any) of the node with tag
`tag`. This is a sometimes useful but inefficient way of accessing node data, as
it relies on a cache stored in the model. For large meshes all the nodes in the
model should be numbered in a continuous sequence of tags from 1 to N to
maintain reasonnable performance (in this case the internal cache is based on a
vector; otherwise it uses a map).

Return 'coord', 'parametricCoord'.
"""
function getNode(nodeTag)
    api_coord_ = Ref{Ptr{Cdouble}}()
    api_coord_n_ = Ref{Csize_t}()
    api_parametricCoord_ = Ref{Ptr{Cdouble}}()
    api_parametricCoord_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetNode, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}),
          nodeTag, api_coord_, api_coord_n_, api_parametricCoord_, api_parametricCoord_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetNode returned non-zero error code: $(ierr[])")
    coord = unsafe_wrap(Array, api_coord_[], api_coord_n_[], true)
    parametricCoord = unsafe_wrap(Array, api_parametricCoord_[], api_parametricCoord_n_[], true)
    return coord, parametricCoord
end

"""
    gmsh.model.mesh.rebuildNodeCache(onlyIfNecessary = true)

Rebuild the node cache.
"""
function rebuildNodeCache(onlyIfNecessary = true)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshRebuildNodeCache, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          onlyIfNecessary, ierr)
    ierr[] != 0 && error("gmshModelMeshRebuildNodeCache returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setNodes(dim, tag, nodeTags, coord, parametricCoord = Cdouble[])

Set the nodes classified on the geometrical entity of dimension `dim` and tag
`tag`. `nodeTags` contains the node tags (their unique, strictly positive
identification numbers). `coord` is a vector of length 3 times the length of
`nodeTags` that contains the (x, y, z) coordinates of the nodes, concatenated.
The optional `parametricCoord` vector contains the parametric coordinates of the
nodes, if any. The length of `parametricCoord` can be 0 or `dim` times the
length of `nodeTags`.
"""
function setNodes(dim, tag, nodeTags, coord, parametricCoord = Cdouble[])
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetNodes, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          dim, tag, convert(Vector{Cint}, nodeTags), length(nodeTags), coord, length(coord), parametricCoord, length(parametricCoord), ierr)
    ierr[] != 0 && error("gmshModelMeshSetNodes returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.reclassifyNodes()

Reclassify all nodes on their associated geometrical entity, based on the
elements. Can be used when importing nodes in bulk (e.g. by associating them all
to a single volume), to reclassify them correctly on model surfaces, curves,
etc. after the elements have been set.
"""
function reclassifyNodes()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshReclassifyNodes, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelMeshReclassifyNodes returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.getElements(elementTypes, elementTags, nodeTags, dim = -1, tag = -1)

Get the elements classified on the entity of dimension `dim` and tag `tag`. If
`tag` < 0, get the elements for all entities of dimension `dim`. If `dim` and
`tag` are negative, get all the elements in the mesh. `elementTypes` contains
the MSH types of the elements (e.g. `2` for 3-node triangles: see
`getElementProperties` to obtain the properties for a given element type).
`elementTags` is a vector of the same length as `elementTypes`; each entry is a
vector containing the tags (unique, strictly positive identifiers) of the
elements of the corresponding type. `nodeTags` is also a vector of the same
length as `elementTypes`; each entry is a vector of length equal to the number
of elements of the given type times the number of nodes for this type of
element, that contains the node tags of all the elements of the given type,
concatenated.

Return 'elementTypes', 'elementTags', 'nodeTags'.
"""
function getElements(dim = -1, tag = -1)
    api_elementTypes_ = Ref{Ptr{Cint}}()
    api_elementTypes_n_ = Ref{Csize_t}()
    api_elementTags_ = Ref{Ptr{Ptr{Cint}}}()
    api_elementTags_n_ = Ref{Ptr{Csize_t}}()
    api_elementTags_nn_ = Ref{Csize_t}()
    api_nodeTags_ = Ref{Ptr{Ptr{Cint}}}()
    api_nodeTags_n_ = Ref{Ptr{Csize_t}}()
    api_nodeTags_nn_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetElements, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          api_elementTypes_, api_elementTypes_n_, api_elementTags_, api_elementTags_n_, api_elementTags_nn_, api_nodeTags_, api_nodeTags_n_, api_nodeTags_nn_, dim, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshGetElements returned non-zero error code: $(ierr[])")
    elementTypes = unsafe_wrap(Array, api_elementTypes_[], api_elementTypes_n_[], true)
    tmp_api_elementTags_ = unsafe_wrap(Array, api_elementTags_[], api_elementTags_nn_[], true)
    tmp_api_elementTags_n_ = unsafe_wrap(Array, api_elementTags_n_[], api_elementTags_nn_[], true)
    elementTags = [ unsafe_wrap(Array, tmp_api_elementTags_[i], tmp_api_elementTags_n_[i], true) for i in 1:api_elementTags_nn_[] ]
    tmp_api_nodeTags_ = unsafe_wrap(Array, api_nodeTags_[], api_nodeTags_nn_[], true)
    tmp_api_nodeTags_n_ = unsafe_wrap(Array, api_nodeTags_n_[], api_nodeTags_nn_[], true)
    nodeTags = [ unsafe_wrap(Array, tmp_api_nodeTags_[i], tmp_api_nodeTags_n_[i], true) for i in 1:api_nodeTags_nn_[] ]
    return elementTypes, elementTags, nodeTags
end

"""
    gmsh.model.mesh.getElement(elementTag, elementType, nodeTags)

Get the type and node tags of the element with tag `tag`. This is a useful but
inefficient way of accessing element data, as it relies on a cache stored in the
model. For large meshes all the elements in the model should be numbered in a
continuous sequence of tags from 1 to N to maintain reasonnable performance (in
this case the internal cache is based on a vector; otherwise it uses a map).

Return 'elementType', 'nodeTags'.
"""
function getElement(elementTag)
    api_elementType_ = Ref{Cint}()
    api_nodeTags_ = Ref{Ptr{Cint}}()
    api_nodeTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetElement, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          elementTag, api_elementType_, api_nodeTags_, api_nodeTags_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetElement returned non-zero error code: $(ierr[])")
    nodeTags = unsafe_wrap(Array, api_nodeTags_[], api_nodeTags_n_[], true)
    return api_elementType_[], nodeTags
end

"""
    gmsh.model.mesh.setElements(dim, tag, elementTypes, elementTags, nodeTags)

Set the elements of the entity of dimension `dim` and tag `tag`. `types`
contains the MSH types of the elements (e.g. `2` for 3-node triangles: see the
Gmsh reference manual). `elementTags` is a vector of the same length as `types`;
each entry is a vector containing the tags (unique, strictly positive
identifiers) of the elements of the corresponding type. `nodeTags` is also a
vector of the same length as `types`; each entry is a vector of length equal to
the number of elements of the give type times the number of nodes per element,
that contains the node tags of all the elements of the given type, concatenated.
"""
function setElements(dim, tag, elementTypes, elementTags, nodeTags)
    api_elementTags_n_ = [ length(elementTags[i]) for i in 1:length(elementTags) ]
    api_nodeTags_n_ = [ length(nodeTags[i]) for i in 1:length(nodeTags) ]
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetElements, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Csize_t, Ptr{Cint}),
          dim, tag, convert(Vector{Cint}, elementTypes), length(elementTypes), convert(Vector{Vector{Cint}},elementTags), api_elementTags_n_, length(elementTags), convert(Vector{Vector{Cint}},nodeTags), api_nodeTags_n_, length(nodeTags), ierr)
    ierr[] != 0 && error("gmshModelMeshSetElements returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.getElementTypes(elementTypes, dim = -1, tag = -1)

Get the types of elements in the entity of dimension `dim` and tag `tag`. If
`tag` < 0, get the types for all entities of dimension `dim`. If `dim` and `tag`
are negative, get all the types in the mesh.

Return 'elementTypes'.
"""
function getElementTypes(dim = -1, tag = -1)
    api_elementTypes_ = Ref{Ptr{Cint}}()
    api_elementTypes_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetElementTypes, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Ptr{Cint}),
          api_elementTypes_, api_elementTypes_n_, dim, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshGetElementTypes returned non-zero error code: $(ierr[])")
    elementTypes = unsafe_wrap(Array, api_elementTypes_[], api_elementTypes_n_[], true)
    return elementTypes
end

"""
    gmsh.model.mesh.getElementProperties(elementType, elementName, dim, order, numNodes, parametricCoord)

Get the properties of an element of type `elementType`: its name
(`elementName`), dimension (`dim`), order (`order`), number of nodes
(`numNodes`) and parametric node coordinates (`parametricCoord` vector, of
length `dim` times `numNodes`).

Return 'elementName', 'dim', 'order', 'numNodes', 'parametricCoord'.
"""
function getElementProperties(elementType)
    api_elementName_ = Ref{Ptr{Cchar}}()
    api_dim_ = Ref{Cint}()
    api_order_ = Ref{Cint}()
    api_numNodes_ = Ref{Cint}()
    api_parametricCoord_ = Ref{Ptr{Cdouble}}()
    api_parametricCoord_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetElementProperties, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cchar}}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}),
          elementType, api_elementName_, api_dim_, api_order_, api_numNodes_, api_parametricCoord_, api_parametricCoord_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetElementProperties returned non-zero error code: $(ierr[])")
    elementName = unsafe_string(api_elementName_[])
    parametricCoord = unsafe_wrap(Array, api_parametricCoord_[], api_parametricCoord_n_[], true)
    return elementName, api_dim_[], api_order_[], api_numNodes_[], parametricCoord
end

"""
    gmsh.model.mesh.getElementsByType(elementType, elementTags, nodeTags, tag = -1, task = 0, numTasks = 1)

Get the elements of type `elementType` classified on the entity of of tag `tag`.
If `tag` < 0, get the elements for all entities. `elementTags` is a vector
containing the tags (unique, strictly positive identifiers) of the elements of
the corresponding type. `nodeTags` is a vector of length equal to the number of
elements of the given type times the number of nodes for this type of element,
that contains the node tags of all the elements of the given type, concatenated.
If `numTasks` > 1, only compute and return the part of the data indexed by
`task`.

Return 'elementTags', 'nodeTags'.
"""
function getElementsByType(elementType, tag = -1, task = 0, numTasks = 1)
    api_elementTags_ = Ref{Ptr{Cint}}()
    api_elementTags_n_ = Ref{Csize_t}()
    api_nodeTags_ = Ref{Ptr{Cint}}()
    api_nodeTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetElementsByType, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Csize_t, Csize_t, Ptr{Cint}),
          elementType, api_elementTags_, api_elementTags_n_, api_nodeTags_, api_nodeTags_n_, tag, task, numTasks, ierr)
    ierr[] != 0 && error("gmshModelMeshGetElementsByType returned non-zero error code: $(ierr[])")
    elementTags = unsafe_wrap(Array, api_elementTags_[], api_elementTags_n_[], true)
    nodeTags = unsafe_wrap(Array, api_nodeTags_[], api_nodeTags_n_[], true)
    return elementTags, nodeTags
end

"""
    gmsh.model.mesh.preallocateElementsByType(elementType, elementTag, nodeTag, elementTags, nodeTags, tag = -1)

Preallocate the data for `getElementsByType`. This is necessary only if
`getElementsByType` is called with `numTasks` > 1.

Return 'elementTags', 'nodeTags'.
"""
function preallocateElementsByType(elementType, elementTag, nodeTag, tag = -1)
    api_elementTags_ = Ref{Ptr{Cint}}()
    api_elementTags_n_ = Ref{Csize_t}()
    api_nodeTags_ = Ref{Ptr{Cint}}()
    api_nodeTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshPreallocateElementsByType, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          elementType, elementTag, nodeTag, api_elementTags_, api_elementTags_n_, api_nodeTags_, api_nodeTags_n_, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshPreallocateElementsByType returned non-zero error code: $(ierr[])")
    elementTags = unsafe_wrap(Array, api_elementTags_[], api_elementTags_n_[], true)
    nodeTags = unsafe_wrap(Array, api_nodeTags_[], api_nodeTags_n_[], true)
    return elementTags, nodeTags
end

"""
    gmsh.model.mesh.getJacobians(elementType, integrationType, jacobians, determinants, points, tag = -1, task = 0, numTasks = 1)

Get the Jacobians of all the elements of type `elementType` classified on the
entity of dimension `dim` and tag `tag`, at the integration points required by
the `integrationType` integration rule (e.g. "Gauss4"). Data is returned by
element, in the same order as data returned by `getElementsByType`. `jacobians`
contains for each element the 9 entries of a 3x3 Jacobian matrix (by row), for
each integration point. `determinants` contains for each element the determinant
of the Jacobian matrix for each integration point. `points` contains for each
element the (x, y, z) coordinates of the integration points. If `tag` < 0, get
the Jacobian data for all entities. If `numTasks` > 1, only compute and return
the part of the data indexed by `task`.

Return 'jacobians', 'determinants', 'points'.
"""
function getJacobians(elementType, integrationType, tag = -1, task = 0, numTasks = 1)
    api_jacobians_ = Ref{Ptr{Cdouble}}()
    api_jacobians_n_ = Ref{Csize_t}()
    api_determinants_ = Ref{Ptr{Cdouble}}()
    api_determinants_n_ = Ref{Csize_t}()
    api_points_ = Ref{Ptr{Cdouble}}()
    api_points_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetJacobians, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Csize_t, Csize_t, Ptr{Cint}),
          elementType, integrationType, api_jacobians_, api_jacobians_n_, api_determinants_, api_determinants_n_, api_points_, api_points_n_, tag, task, numTasks, ierr)
    ierr[] != 0 && error("gmshModelMeshGetJacobians returned non-zero error code: $(ierr[])")
    jacobians = unsafe_wrap(Array, api_jacobians_[], api_jacobians_n_[], true)
    determinants = unsafe_wrap(Array, api_determinants_[], api_determinants_n_[], true)
    points = unsafe_wrap(Array, api_points_[], api_points_n_[], true)
    return jacobians, determinants, points
end

"""
    gmsh.model.mesh.preallocateJacobians(elementType, integrationType, jacobian, determinant, point, jacobians, determinants, points, tag = -1)

Preallocate the data required by `getJacobians`. This is necessary only if
`getJacobians` is called with `numTasks` > 1.

Return 'jacobians', 'determinants', 'points'.
"""
function preallocateJacobians(elementType, integrationType, jacobian, determinant, point, tag = -1)
    api_jacobians_ = Ref{Ptr{Cdouble}}()
    api_jacobians_n_ = Ref{Csize_t}()
    api_determinants_ = Ref{Ptr{Cdouble}}()
    api_determinants_n_ = Ref{Csize_t}()
    api_points_ = Ref{Ptr{Cdouble}}()
    api_points_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshPreallocateJacobians, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cint, Cint, Cint, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          elementType, integrationType, jacobian, determinant, point, api_jacobians_, api_jacobians_n_, api_determinants_, api_determinants_n_, api_points_, api_points_n_, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshPreallocateJacobians returned non-zero error code: $(ierr[])")
    jacobians = unsafe_wrap(Array, api_jacobians_[], api_jacobians_n_[], true)
    determinants = unsafe_wrap(Array, api_determinants_[], api_determinants_n_[], true)
    points = unsafe_wrap(Array, api_points_[], api_points_n_[], true)
    return jacobians, determinants, points
end

"""
    gmsh.model.mesh.getBasisFunctions(elementType, integrationType, functionSpaceType, integrationPoints, numComponents, basisFunctions)

Get the basis functions of the element of type `elementType` for the given
`integrationType` integration rule (e.g. "Gauss4") and `functionSpaceType`
function space (e.g. "IsoParametric"). `integrationPoints` contains the
parametric coordinates (u, v, w) and the weight for each integeration point,
concatenated. `numComponents` returns the number of components of a basis
function. `basisFunctions` contains the evaluation of the basis functions at the
integration points.

Return 'integrationPoints', 'numComponents', 'basisFunctions'.
"""
function getBasisFunctions(elementType, integrationType, functionSpaceType)
    api_integrationPoints_ = Ref{Ptr{Cdouble}}()
    api_integrationPoints_n_ = Ref{Csize_t}()
    api_numComponents_ = Ref{Cint}()
    api_basisFunctions_ = Ref{Ptr{Cdouble}}()
    api_basisFunctions_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetBasisFunctions, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cchar}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}),
          elementType, integrationType, functionSpaceType, api_integrationPoints_, api_integrationPoints_n_, api_numComponents_, api_basisFunctions_, api_basisFunctions_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetBasisFunctions returned non-zero error code: $(ierr[])")
    integrationPoints = unsafe_wrap(Array, api_integrationPoints_[], api_integrationPoints_n_[], true)
    basisFunctions = unsafe_wrap(Array, api_basisFunctions_[], api_basisFunctions_n_[], true)
    return integrationPoints, api_numComponents_[], basisFunctions
end

"""
    gmsh.model.mesh.precomputeBasisFunctions(elementType)

Precomputes the basis functions corresponding to `elementType`.
"""
function precomputeBasisFunctions(elementType)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshPrecomputeBasisFunctions, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          elementType, ierr)
    ierr[] != 0 && error("gmshModelMeshPrecomputeBasisFunctions returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.getBarycenters(elementType, tag, fast, primary, barycenters, task = 0, numTasks = 1)

Get the barycenters of all elements of type `elementType` classified on the
entity of tag `tag`. If `primary` is set, only the primary nodes of the elements
are taken into account for the barycenter calculation. If `fast` is set, the
function returns the sum of the primary node coordinates (without normalizing by
the number of nodes). If `numTasks` > 1, only compute and return the part of the
data indexed by `task`.

Return 'barycenters'.
"""
function getBarycenters(elementType, tag, fast, primary, task = 0, numTasks = 1)
    api_barycenters_ = Ref{Ptr{Cdouble}}()
    api_barycenters_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetBarycenters, gmsh.clib), Void,
          (Cint, Cint, Cint, Cint, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Csize_t, Csize_t, Ptr{Cint}),
          elementType, tag, fast, primary, api_barycenters_, api_barycenters_n_, task, numTasks, ierr)
    ierr[] != 0 && error("gmshModelMeshGetBarycenters returned non-zero error code: $(ierr[])")
    barycenters = unsafe_wrap(Array, api_barycenters_[], api_barycenters_n_[], true)
    return barycenters
end

"""
    gmsh.model.mesh.preallocateBarycenters(elementType, barycenters, tag = -1)

Preallocate the data required by `getBarycenters`. This is necessary only if
`getBarycenters` is called with `numTasks` > 1.

Return 'barycenters'.
"""
function preallocateBarycenters(elementType, tag = -1)
    api_barycenters_ = Ref{Ptr{Cdouble}}()
    api_barycenters_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshPreallocateBarycenters, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          elementType, api_barycenters_, api_barycenters_n_, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshPreallocateBarycenters returned non-zero error code: $(ierr[])")
    barycenters = unsafe_wrap(Array, api_barycenters_[], api_barycenters_n_[], true)
    return barycenters
end

"""
    gmsh.model.mesh.setSize(dimTags, size)

Set a mesh size constraint on the geometrical entities `dimTags`. Currently only
entities of dimension 0 (points) are handled.
"""
function setSize(dimTags, size)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetSize, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), size, ierr)
    ierr[] != 0 && error("gmshModelMeshSetSize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setTransfiniteCurve(tag, numNodes, meshType = "Progression", coef = 1.)

Set a transfinite meshing constraint on the curve `tag`, with `numNodes` nodes
distributed according to `meshType` and `coef`. Currently supported types are
"Progression" (geometrical progression with power `coef`) and "Bump" (refinement
toward both extremities of the curve).
"""
function setTransfiniteCurve(tag, numNodes, meshType = "Progression", coef = 1.)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetTransfiniteCurve, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          tag, numNodes, meshType, coef, ierr)
    ierr[] != 0 && error("gmshModelMeshSetTransfiniteCurve returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setTransfiniteSurface(tag, arrangement = "Left", cornerTags = Cint[])

Set a transfinite meshing constraint on the surface `tag`. `arrangement`
describes the arrangement of the triangles when the surface is not flagged as
recombined: currently supported values are "Left", "Right", "AlternateLeft" and
"AlternateRight". `cornerTags` can be used to specify the (3 or 4) corners of
the transfinite interpolation explicitly; specifying the corners explicitly is
mandatory if the surface has more that 3 or 4 points on its boundary.
"""
function setTransfiniteSurface(tag, arrangement = "Left", cornerTags = Cint[])
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetTransfiniteSurface, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, arrangement, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    ierr[] != 0 && error("gmshModelMeshSetTransfiniteSurface returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setTransfiniteVolume(tag, cornerTags = Cint[])

Set a transfinite meshing constraint on the surface `tag`. `cornerTags` can be
used to specify the (6 or 8) corners of the transfinite interpolation
explicitly.
"""
function setTransfiniteVolume(tag, cornerTags = Cint[])
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetTransfiniteVolume, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    ierr[] != 0 && error("gmshModelMeshSetTransfiniteVolume returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setRecombine(dim, tag)

Set a recombination meshing constraint on the geometrical entity of dimension
`dim` and tag `tag`. Currently only entities of dimension 2 (to recombine
triangles into quadrangles) are supported.
"""
function setRecombine(dim, tag)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetRecombine, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}),
          dim, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshSetRecombine returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setSmoothing(dim, tag, val)

Set a smoothing meshing constraint on the geometrical entity of dimension `dim`
and tag `tag`. `val` iterations of a Laplace smoother are applied.
"""
function setSmoothing(dim, tag, val)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetSmoothing, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    ierr[] != 0 && error("gmshModelMeshSetSmoothing returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setReverse(dim, tag, val = true)

Set a reverse meshing constraint on the geometrical entity of dimension `dim`
and tag `tag`. If `val` is true, the mesh orientation will be reversed with
respect to the natural mesh orientation (i.e. the orientation consistent with
the orientation of the geometrical entity). If `val` is false, the mesh is left
as-is.
"""
function setReverse(dim, tag, val = true)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetReverse, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    ierr[] != 0 && error("gmshModelMeshSetReverse returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setOutwardOrientation(tag)

Set meshing constraints on the bounding surfaces of the volume of tag `tag` so
that all surfaces are oriented with outward pointing normals. Currently only
available with the OpenCASCADE kernel, as it relies on the STL triangulation.
"""
function setOutwardOrientation(tag)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetOutwardOrientation, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    ierr[] != 0 && error("gmshModelMeshSetOutwardOrientation returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.embed(dim, tags, inDim, inTag)

Embed the geometrical entities of dimension `dim` and tags `tags` in the (inDim,
inTag) geometrical entity. `inDim` must be strictly greater than `dim`.
"""
function embed(dim, tags, inDim, inTag)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshEmbed, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cint}),
          dim, convert(Vector{Cint}, tags), length(tags), inDim, inTag, ierr)
    ierr[] != 0 && error("gmshModelMeshEmbed returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.reorderElements(elementType, tag, order)

Reorder the elements of type `elementType` classified on the entity of tag `tag`
according to `order`.
"""
function reorderElements(elementType, tag, order)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshReorderElements, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          elementType, tag, convert(Vector{Cint}, order), length(order), ierr)
    ierr[] != 0 && error("gmshModelMeshReorderElements returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.setPeriodic(dim, tags, tagsSource, affineTransformation)

Set the meshes of the entities of dimension `dim` and tag `tags` as periodic
copies of the meshes of entities `tagsSource`, using the affine transformation
specified in `affineTransformation` (16 entries of a 4x4 matrix, by row).
Currently only available for `dim` == 1 and `dim` == 2.
"""
function setPeriodic(dim, tags, tagsSource, affineTransformation)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshSetPeriodic, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          dim, convert(Vector{Cint}, tags), length(tags), convert(Vector{Cint}, tagsSource), length(tagsSource), affineTransformation, length(affineTransformation), ierr)
    ierr[] != 0 && error("gmshModelMeshSetPeriodic returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.getPeriodicNodes(dim, tag, tagMaster, nodes, affineTransform)

Get the master entity, periodic node pairs and affine transform for the entity
of dimension `dim` and tag `tag`.

Return 'tagMaster', 'nodes', 'affineTransform'.
"""
function getPeriodicNodes(dim, tag)
    api_tagMaster_ = Ref{Cint}()
    api_nodes_ = Ref{Ptr{Cint}}()
    api_nodes_n_ = Ref{Csize_t}()
    api_affineTransform_ = Ref{Ptr{Cdouble}}()
    api_affineTransform_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshGetPeriodicNodes, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cint}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Ptr{Cint}),
          dim, tag, api_tagMaster_, api_nodes_, api_nodes_n_, api_affineTransform_, api_affineTransform_n_, ierr)
    ierr[] != 0 && error("gmshModelMeshGetPeriodicNodes returned non-zero error code: $(ierr[])")
    tmp_api_nodes_ = unsafe_wrap(Array, api_nodes_[], api_nodes_n_[], true)
    nodes = [ (tmp_api_nodes_[i], tmp_api_nodes_[i+1]) for i in 1:2:length(tmp_api_nodes_) ]
    affineTransform = unsafe_wrap(Array, api_affineTransform_[], api_affineTransform_n_[], true)
    return api_tagMaster_[], nodes, affineTransform
end

"""
    gmsh.model.mesh.removeDuplicateNodes()

Remove duplicate nodes in the mesh of the current model.
"""
function removeDuplicateNodes()
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshRemoveDuplicateNodes, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelMeshRemoveDuplicateNodes returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.homology(domainTags = Cint[], subdomainTags = Cint[], dims = Cint[])

Compute a basis representation for homology spaces after a mesh has been
generated. The computation domain is given in a list of physical group tags
`domainTags`; if empty, the whole mesh is the domain. The computation subdomain
for relative homology computation is given in a list of physical group tags
`subdomainTags`; if empty, absolute homology is computed. The dimensions
homology bases to be computed are given in the list `dim`; if empty, all bases
are computed. Resulting basis representation chains are stored as physical
groups in the mesh.
"""
function homology(domainTags = Cint[], subdomainTags = Cint[], dims = Cint[])
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshHomology, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}),
          convert(Vector{Cint}, domainTags), length(domainTags), convert(Vector{Cint}, subdomainTags), length(subdomainTags), convert(Vector{Cint}, dims), length(dims), ierr)
    ierr[] != 0 && error("gmshModelMeshHomology returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.cohomology(domainTags = Cint[], subdomainTags = Cint[], dims = Cint[])

Compute a basis representation for cohomology spaces after a mesh has been
generated. The computation domain is given in a list of physical group tags
`domainTags`; if empty, the whole mesh is the domain. The computation subdomain
for relative cohomology computation is given in a list of physical group tags
`subdomainTags`; if empty, absolute cohomology is computed. The dimensions
homology bases to be computed are given in the list `dim`; if empty, all bases
are computed. Resulting basis representation cochains are stored as physical
groups in the mesh.
"""
function cohomology(domainTags = Cint[], subdomainTags = Cint[], dims = Cint[])
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshCohomology, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}),
          convert(Vector{Cint}, domainTags), length(domainTags), convert(Vector{Cint}, subdomainTags), length(subdomainTags), convert(Vector{Cint}, dims), length(dims), ierr)
    ierr[] != 0 && error("gmshModelMeshCohomology returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    module gmsh.model.mesh.field

Per-model mesh size field functions
"""
module field

import ....gmsh

"""
    gmsh.model.mesh.field.add(fieldType, tag = -1)

Add a new mesh size field of type `fieldType`. If `tag` is positive, assign the
tag explcitly; otherwise a new tag is assigned automatically. Return the field
tag.

Return an integer.
"""
function add(fieldType, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelMeshFieldAdd, gmsh.clib), Cint,
          (Ptr{Cchar}, Cint, Ptr{Cint}),
          fieldType, tag, ierr)
    ierr[] != 0 && error("gmshModelMeshFieldAdd returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.mesh.field.remove(tag)

Remove the field with tag `tag`.
"""
function remove(tag)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshFieldRemove, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    ierr[] != 0 && error("gmshModelMeshFieldRemove returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.field.setNumber(tag, option, value)

Set the numerical option `option` to value `value` for field `tag`.
"""
function setNumber(tag, option, value)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshFieldSetNumber, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          tag, option, value, ierr)
    ierr[] != 0 && error("gmshModelMeshFieldSetNumber returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.field.setString(tag, option, value)

Set the string option `option` to value `value` for field `tag`.
"""
function setString(tag, option, value)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshFieldSetString, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          tag, option, value, ierr)
    ierr[] != 0 && error("gmshModelMeshFieldSetString returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.field.setNumbers(tag, option, value)

Set the numerical list option `option` to value `value` for field `tag`.
"""
function setNumbers(tag, option, value)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshFieldSetNumbers, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          tag, option, value, length(value), ierr)
    ierr[] != 0 && error("gmshModelMeshFieldSetNumbers returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.field.setAsBackgroundMesh(tag)

Set the field `tag` as the background mesh size field.
"""
function setAsBackgroundMesh(tag)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshFieldSetAsBackgroundMesh, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    ierr[] != 0 && error("gmshModelMeshFieldSetAsBackgroundMesh returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.mesh.field.setAsBoundaryLayer(tag)

Set the field `tag` as a boundary layer size field.
"""
function setAsBoundaryLayer(tag)
    ierr = Ref{Cint}()
    ccall((:gmshModelMeshFieldSetAsBoundaryLayer, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    ierr[] != 0 && error("gmshModelMeshFieldSetAsBoundaryLayer returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module field

end # end of module mesh

"""
    module gmsh.model.geo

Internal per-model GEO CAD kernel functions
"""
module geo

import ...gmsh

"""
    gmsh.model.geo.addPoint(x, y, z, meshSize = 0., tag = -1)

Add a geometrical point in the internal GEO CAD representation, at coordinates
(x, y, z). If `meshSize` is > 0, add a meshing constraint at that point. If
`tag` is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the point. (Note that the point will be added
in the current model only after `synchronize` is called. This behavior holds for
all the entities added in the geo module.)

Return an integer.
"""
function addPoint(x, y, z, meshSize = 0., tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddPoint, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          x, y, z, meshSize, tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddPoint returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addLine(startTag, endTag, tag = -1)

Add a straight line segment between the two points with tags `startTag` and
`endTag`. If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the line.

Return an integer.
"""
function addLine(startTag, endTag, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddLine, gmsh.clib), Cint,
          (Cint, Cint, Cint, Ptr{Cint}),
          startTag, endTag, tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddLine returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addCircleArc(startTag, centerTag, endTag, tag = -1, nx = 0., ny = 0., nz = 0.)

Add a circle arc (stricly smaller than Pi) between the two points with tags
`startTag` and `endTag`, with center `centertag`. If `tag` is positive, set the
tag explicitly; otherwise a new tag is selected automatically. If (`nx`, `ny`,
`nz`) != (0,0,0), explicitely set the plane of the circle arc. Return the tag of
the circle arc.

Return an integer.
"""
function addCircleArc(startTag, centerTag, endTag, tag = -1, nx = 0., ny = 0., nz = 0.)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddCircleArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          startTag, centerTag, endTag, tag, nx, ny, nz, ierr)
    ierr[] != 0 && error("gmshModelGeoAddCircleArc returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addEllipseArc(startTag, centerTag, majorTag, endTag, tag = -1, nx = 0., ny = 0., nz = 0.)

Add an ellipse arc (stricly smaller than Pi) between the two points `startTag`
and `endTag`, with center `centertag` and major axis point `majorTag`. If `tag`
is positive, set the tag explicitly; otherwise a new tag is selected
automatically. If (`nx`, `ny`, `nz`) != (0,0,0), explicitely set the plane of
the circle arc. Return the tag of the ellipse arc.

Return an integer.
"""
function addEllipseArc(startTag, centerTag, majorTag, endTag, tag = -1, nx = 0., ny = 0., nz = 0.)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddEllipseArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Cint, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          startTag, centerTag, majorTag, endTag, tag, nx, ny, nz, ierr)
    ierr[] != 0 && error("gmshModelGeoAddEllipseArc returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addSpline(pointTags, tag = -1)

Add a spline (Catmull-Rom) curve going through the points `pointTags`. If `tag`
is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Create a periodic curve if the first and last points are the
same. Return the tag of the spline curve.

Return an integer.
"""
function addSpline(pointTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddSpline returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addBSpline(pointTags, tag = -1)

Add a cubic b-spline curve with `pointTags` control points. If `tag` is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
Creates a periodic curve if the first and last points are the same. Return the
tag of the b-spline curve.

Return an integer.
"""
function addBSpline(pointTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddBSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddBSpline returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addBezier(pointTags, tag = -1)

Add a Bezier curve with `pointTags` control points. If `tag` is positive, set
the tag explicitly; otherwise a new tag is selected automatically.  Return the
tag of the Bezier curve.

Return an integer.
"""
function addBezier(pointTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddBezier, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddBezier returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addCurveLoop(curveTags, tag = -1)

Add a curve loop (a closed wire) formed by the curves `curveTags`. `curveTags`
should contain (signed) tags of geometrical enties of dimension 1 forming a
closed loop: a negative tag signifies that the underlying curve is considered
with reversed orientation. If `tag` is positive, set the tag explicitly;
otherwise a new tag is selected automatically. Return the tag of the curve loop.

Return an integer.
"""
function addCurveLoop(curveTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddCurveLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, curveTags), length(curveTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddCurveLoop returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addPlaneSurface(wireTags, tag = -1)

Add a plane surface defined by one or more curve loops `wireTags`. The first
curve loop defines the exterior contour; additional curve loop define holes. If
`tag` is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the surface.

Return an integer.
"""
function addPlaneSurface(wireTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddPlaneSurface, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddPlaneSurface returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addSurfaceFilling(wireTags, tag = -1, sphereCenterTag = -1)

Add a surface filling the curve loops in `wireTags`. Currently only a single
curve loop is supported; this curve loop should be composed by 3 or 4 curves
only. If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the surface.

Return an integer.
"""
function addSurfaceFilling(wireTags, tag = -1, sphereCenterTag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddSurfaceFilling, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), tag, sphereCenterTag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddSurfaceFilling returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addSurfaceLoop(surfaceTags, tag = -1)

Add a surface loop (a closed shell) formed by `surfaceTags`.  If `tag` is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
Return the tag of the shell.

Return an integer.
"""
function addSurfaceLoop(surfaceTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddSurfaceLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, surfaceTags), length(surfaceTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddSurfaceLoop returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.addVolume(shellTags, tag = -1)

Add a volume (a region) defined by one or more shells `shellTags`. The first
surface loop defines the exterior boundary; additional surface loop define
holes. If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the volume.

Return an integer.
"""
function addVolume(shellTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelGeoAddVolume, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, shellTags), length(shellTags), tag, ierr)
    ierr[] != 0 && error("gmshModelGeoAddVolume returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.geo.extrude(dimTags, dx, dy, dz, outDimTags, numElements = Cint[], heights = Cdouble[], recombine = false)

Extrude the geometrical entities `dimTags` by translation along (`dx`, `dy`,
`dz`). Return extruded entities in `outDimTags`. If `numElements` is not empty,
also extrude the mesh: the entries in `numElements` give the number of elements
in each layer. If `height` is not empty, it provides the (cummulative) height of
the different layers, normalized to 1.

Return 'outDimTags'.
"""
function extrude(dimTags, dx, dy, dz, numElements = Cint[], heights = Cdouble[], recombine = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoExtrude, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), dx, dy, dz, api_outDimTags_, api_outDimTags_n_, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    ierr[] != 0 && error("gmshModelGeoExtrude returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.geo.revolve(dimTags, x, y, z, ax, ay, az, angle, outDimTags, numElements = Cint[], heights = Cdouble[], recombine = false)

Extrude the geometrical entities `dimTags` by rotation of `angle` radians around
the axis of revolution defined by the point (`x`, `y`, `z`) and the direction
(`ax`, `ay`, `az`). Return extruded entities in `outDimTags`. If `numElements`
is not empty, also extrude the mesh: the entries in `numElements` give the
number of elements in each layer. If `height` is not empty, it provides the
(cummulative) height of the different layers, normalized to 1.

Return 'outDimTags'.
"""
function revolve(dimTags, x, y, z, ax, ay, az, angle, numElements = Cint[], heights = Cdouble[], recombine = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoRevolve, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, ax, ay, az, angle, api_outDimTags_, api_outDimTags_n_, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    ierr[] != 0 && error("gmshModelGeoRevolve returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.geo.twist(dimTags, x, y, z, dx, dy, dz, ax, ay, az, angle, outDimTags, numElements = Cint[], heights = Cdouble[], recombine = false)

Extrude the geometrical entities `dimTags` by a combined translation and
rotation of `angle` radians, along (`dx`, `dy`, `dz`) and around the axis of
revolution defined by the point (`x`, `y`, `z`) and the direction (`ax`, `ay`,
`az`). Return extruded entities in `outDimTags`. If `numElements` is not empty,
also extrude the mesh: the entries in `numElements` give the number of elements
in each layer. If `height` is not empty, it provides the (cummulative) height of
the different layers, normalized to 1.

Return 'outDimTags'.
"""
function twist(dimTags, x, y, z, dx, dy, dz, ax, ay, az, angle, numElements = Cint[], heights = Cdouble[], recombine = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoTwist, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, dx, dy, dz, ax, ay, az, angle, api_outDimTags_, api_outDimTags_n_, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    ierr[] != 0 && error("gmshModelGeoTwist returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.geo.translate(dimTags, dx, dy, dz)

Translate the geometrical entities `dimTags` along (`dx`, `dy`, `dz`).
"""
function translate(dimTags, dx, dy, dz)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoTranslate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), dx, dy, dz, ierr)
    ierr[] != 0 && error("gmshModelGeoTranslate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.rotate(dimTags, x, y, z, ax, ay, az, angle)

Rotate the geometrical entities `dimTags` of `angle` radians around the axis of
revolution defined by the point (`x`, `y`, `z`) and the direction (`ax`, `ay`,
`az`).
"""
function rotate(dimTags, x, y, z, ax, ay, az, angle)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoRotate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, ax, ay, az, angle, ierr)
    ierr[] != 0 && error("gmshModelGeoRotate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.dilate(dimTags, x, y, z, a, b, c)

Scale the geometrical entities `dimTag` by factors `a`, `b` and `c` along the
three coordinate axes; use (`x`, `y`, `z`) as the center of the homothetic
transformation.
"""
function dilate(dimTags, x, y, z, a, b, c)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoDilate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, a, b, c, ierr)
    ierr[] != 0 && error("gmshModelGeoDilate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.symmetry(dimTags, a, b, c, d)

Apply a symmetry transformation to the geometrical entities `dimTag`, with
respect to the plane of equation `a` * x + `b` * y + `c` * z + `d` = 0.
"""
function symmetry(dimTags, a, b, c, d)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoSymmetry, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), a, b, c, d, ierr)
    ierr[] != 0 && error("gmshModelGeoSymmetry returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.copy(dimTags, outDimTags)

Copy the entities `dimTags`; the new entities are returned in `outDimTags`.

Return 'outDimTags'.
"""
function copy(dimTags)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoCopy, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), api_outDimTags_, api_outDimTags_n_, ierr)
    ierr[] != 0 && error("gmshModelGeoCopy returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.geo.remove(dimTags, recursive = false)

Remove the entities `dimTags`. If `recursive` is true, remove all the entities
on their boundaries, down to dimension 0.
"""
function remove(dimTags, recursive = false)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoRemove, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), recursive, ierr)
    ierr[] != 0 && error("gmshModelGeoRemove returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.removeAllDuplicates()

Remove all duplicate entities (different entities at the same geometrical
location).
"""
function removeAllDuplicates()
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoRemoveAllDuplicates, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelGeoRemoveAllDuplicates returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.synchronize()

Synchronize the internal GEO CAD representation with the current Gmsh model.
This can be called at any time, but since it involves a non trivial amount of
processing, the number of synchronization points should normally be minimized.
"""
function synchronize()
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoSynchronize, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelGeoSynchronize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    module gmsh.model.geo.mesh

GEO-specific meshing constraints
"""
module mesh

import ....gmsh

"""
    gmsh.model.geo.mesh.setSize(dimTags, size)

Set a mesh size constraint on the geometrical entities `dimTags`. Currently only
entities of dimension 0 (points) are handled.
"""
function setSize(dimTags, size)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetSize, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), size, ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetSize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.mesh.setTransfiniteCurve(tag, nPoints, meshType = "Progression", coef = 1.)

Set a transfinite meshing constraint on the curve `tag`, with `numNodes` nodes
distributed according to `meshType` and `coef`. Currently supported types are
"Progression" (geometrical progression with power `coef`) and "Bump" (refinement
toward both extreminties of the curve).
"""
function setTransfiniteCurve(tag, nPoints, meshType = "Progression", coef = 1.)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetTransfiniteCurve, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          tag, nPoints, meshType, coef, ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetTransfiniteCurve returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.mesh.setTransfiniteSurface(tag, arrangement = "Left", cornerTags = Cint[])

Set a transfinite meshing constraint on the surface `tag`. `arrangement`
describes the arrangement of the triangles when the surface is not flagged as
recombined: currently supported values are "Left", "Right", "AlternateLeft" and
"AlternateRight". `cornerTags` can be used to specify the (3 or 4) corners of
the transfinite interpolation explicitly; specifying the corners explicitly is
mandatory if the surface has more that 3 or 4 points on its boundary.
"""
function setTransfiniteSurface(tag, arrangement = "Left", cornerTags = Cint[])
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetTransfiniteSurface, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, arrangement, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetTransfiniteSurface returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.mesh.setTransfiniteVolume(tag, cornerTags = Cint[])

Set a transfinite meshing constraint on the surface `tag`. `cornerTags` can be
used to specify the (6 or 8) corners of the transfinite interpolation
explicitly.
"""
function setTransfiniteVolume(tag, cornerTags = Cint[])
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetTransfiniteVolume, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Ptr{Cint}),
          tag, convert(Vector{Cint}, cornerTags), length(cornerTags), ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetTransfiniteVolume returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.mesh.setRecombine(dim, tag, angle = 45.)

Set a recombination meshing constraint on the geometrical entity of dimension
`dim` and tag `tag`. Currently only entities of dimension 2 (to recombine
triangles into quadrangles) are supported.
"""
function setRecombine(dim, tag, angle = 45.)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetRecombine, gmsh.clib), Void,
          (Cint, Cint, Cdouble, Ptr{Cint}),
          dim, tag, angle, ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetRecombine returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.mesh.setSmoothing(dim, tag, val)

Set a smoothing meshing constraint on the geometrical entity of dimension `dim`
and tag `tag`. `val` iterations of a Laplace smoother are applied.
"""
function setSmoothing(dim, tag, val)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetSmoothing, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetSmoothing returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.geo.mesh.setReverse(dim, tag, val = true)

Set a reverse meshing constraint on the geometrical entity of dimension `dim`
and tag `tag`. If `val` is true, the mesh orientation will be reversed with
respect to the natural mesh orientation (i.e. the orientation consistent with
the orientation of the geometrical entity). If `val` is false, the mesh is left
as-is.
"""
function setReverse(dim, tag, val = true)
    ierr = Ref{Cint}()
    ccall((:gmshModelGeoMeshSetReverse, gmsh.clib), Void,
          (Cint, Cint, Cint, Ptr{Cint}),
          dim, tag, val, ierr)
    ierr[] != 0 && error("gmshModelGeoMeshSetReverse returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module mesh

end # end of module geo

"""
    module gmsh.model.occ

Internal per-model OpenCASCADE CAD kernel functions
"""
module occ

import ...gmsh

"""
    gmsh.model.occ.addPoint(x, y, z, meshSize = 0., tag = -1)

Add a geometrical point in the internal OpenCASCADE CAD representation, at
coordinates (x, y, z). If `meshSize` is > 0, add a meshing constraint at that
point. If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the point. (Note that the point will
be added in the current model only after `synchronize` is called. This behavior
holds for all the entities added in the occ module.)

Return an integer.
"""
function addPoint(x, y, z, meshSize = 0., tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddPoint, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          x, y, z, meshSize, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddPoint returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addLine(startTag, endTag, tag = -1)

Add a straight line segment between the two points with tags `startTag` and
`endTag`. If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the line.

Return an integer.
"""
function addLine(startTag, endTag, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddLine, gmsh.clib), Cint,
          (Cint, Cint, Cint, Ptr{Cint}),
          startTag, endTag, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddLine returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addCircleArc(startTag, centerTag, endTag, tag = -1)

Add a circle arc between the two points with tags `startTag` and `endTag`, with
center `centerTag`. If `tag` is positive, set the tag explicitly; otherwise a
new tag is selected automatically. Return the tag of the circle arc.

Return an integer.
"""
function addCircleArc(startTag, centerTag, endTag, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddCircleArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Ptr{Cint}),
          startTag, centerTag, endTag, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddCircleArc returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addCircle(x, y, z, r, tag = -1, angle1 = 0., angle2 = 2*pi)

Add a circle of center (`x`, `y`, `z`) and radius `r`. If `tag` is positive, set
the tag explicitly; otherwise a new tag is selected automatically. If `angle1`
and `angle2` are specified, create a circle arc between the two angles. Return
the tag of the circle.

Return an integer.
"""
function addCircle(x, y, z, r, tag = -1, angle1 = 0., angle2 = 2*pi)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddCircle, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Cdouble, Ptr{Cint}),
          x, y, z, r, tag, angle1, angle2, ierr)
    ierr[] != 0 && error("gmshModelOccAddCircle returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addEllipseArc(startTag, centerTag, endTag, tag = -1)

Add an ellipse arc between the two points with tags `startTag` and `endTag`,
with center `centerTag`. If `tag` is positive, set the tag explicitly; otherwise
a new tag is selected automatically. Return the tag of the ellipse arc.

Return an integer.
"""
function addEllipseArc(startTag, centerTag, endTag, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddEllipseArc, gmsh.clib), Cint,
          (Cint, Cint, Cint, Cint, Ptr{Cint}),
          startTag, centerTag, endTag, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddEllipseArc returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addEllipse(x, y, z, r1, r2, tag = -1, angle1 = 0., angle2 = 2*pi)

Add an ellipse of center (`x`, `y`, `z`) and radii `r1` and `r2` along the x-
and y-axes respectively. If `tag` is positive, set the tag explicitly; otherwise
a new tag is selected automatically. If `angle1` and `angle2` are specified,
create an ellipse arc between the two angles. Return the tag of the ellipse.

Return an integer.
"""
function addEllipse(x, y, z, r1, r2, tag = -1, angle1 = 0., angle2 = 2*pi)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddEllipse, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Cdouble, Ptr{Cint}),
          x, y, z, r1, r2, tag, angle1, angle2, ierr)
    ierr[] != 0 && error("gmshModelOccAddEllipse returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addSpline(pointTags, tag = -1)

Add a spline (C2 b-spline) curve going through the points `pointTags`. If `tag`
is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Create a periodic curve if the first and last points are the
same. Return the tag of the spline curve.

Return an integer.
"""
function addSpline(pointTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddSpline returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addBSpline(pointTags, tag = -1, degree = 3, weights = Cdouble[], knots = Cdouble[], multiplicities = Cint[])

Add a b-spline curve of degree `degree` with `pointTags` control points. If
`weights`, `knots` or `multiplicities` are not provided, default parameters are
computed automatically. If `tag` is positive, set the tag explicitly; otherwise
a new tag is selected automatically. Create a periodic curve if the first and
last points are the same. Return the tag of the b-spline curve.

Return an integer.
"""
function addBSpline(pointTags, tag = -1, degree = 3, weights = Cdouble[], knots = Cdouble[], multiplicities = Cint[])
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddBSpline, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, degree, weights, length(weights), knots, length(knots), convert(Vector{Cint}, multiplicities), length(multiplicities), ierr)
    ierr[] != 0 && error("gmshModelOccAddBSpline returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addBezier(pointTags, tag = -1)

Add a Bezier curve with `pointTags` control points. If `tag` is positive, set
the tag explicitly; otherwise a new tag is selected automatically. Return the
tag of the Bezier curve.

Return an integer.
"""
function addBezier(pointTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddBezier, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, pointTags), length(pointTags), tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddBezier returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addWire(curveTags, tag = -1, checkClosed = false)

Add a wire (open or closed) formed by the curves `curveTags`. `curveTags` should
contain (signed) tags: a negative tag signifies that the underlying curve is
considered with reversed orientation. If `tag` is positive, set the tag
explicitly; otherwise a new tag is selected automatically. Return the tag of the
wire.

Return an integer.
"""
function addWire(curveTags, tag = -1, checkClosed = false)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddWire, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, curveTags), length(curveTags), tag, checkClosed, ierr)
    ierr[] != 0 && error("gmshModelOccAddWire returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addCurveLoop(curveTags, tag = -1)

Add a curve loop (a closed wire) formed by the curves `curveTags`. `curveTags`
should contain (signed) tags of curves forming a closed loop: a negative tag
signifies that the underlying curve is considered with reversed orientation. If
`tag` is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the curve loop.

Return an integer.
"""
function addCurveLoop(curveTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddCurveLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, curveTags), length(curveTags), tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddCurveLoop returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addRectangle(x, y, z, dx, dy, tag = -1, roundedRadius = 0.)

Add a rectangle with lower left corner at (`x`, `y`, `z`) and upper right corner
at (`x` + `dx`, `y` + `dy`, `z`). If `tag` is positive, set the tag explicitly;
otherwise a new tag is selected automatically. Round the corners if
`roundedRadius` is nonzero. Return the tag of the rectangle.

Return an integer.
"""
function addRectangle(x, y, z, dx, dy, tag = -1, roundedRadius = 0.)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddRectangle, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, tag, roundedRadius, ierr)
    ierr[] != 0 && error("gmshModelOccAddRectangle returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addDisk(xc, yc, zc, rx, ry, tag = -1)

Add a disk with center (`xc`, `yc`, `zc`) and radius `rx` along the x-axis and
`ry` along the y-axis. If `tag` is positive, set the tag explicitly; otherwise a
new tag is selected automatically. Return the tag of the disk.

Return an integer.
"""
function addDisk(xc, yc, zc, rx, ry, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddDisk, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          xc, yc, zc, rx, ry, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddDisk returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addPlaneSurface(wireTags, tag = -1)

Add a plane surface defined by one or more curve loops (or closed wires)
`wireTags`. The first curve loop defines the exterior contour; additional curve
loop define holes. If `tag` is positive, set the tag explicitly; otherwise a new
tag is selected automatically. Return the tag of the surface.

Return an integer.
"""
function addPlaneSurface(wireTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddPlaneSurface, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddPlaneSurface returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addSurfaceFilling(wireTag, tag = -1)

Add a surface filling the curve loops in `wireTags`. If `tag` is positive, set
the tag explicitly; otherwise a new tag is selected automatically. Return the
tag of the surface.

Return an integer.
"""
function addSurfaceFilling(wireTag, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddSurfaceFilling, gmsh.clib), Cint,
          (Cint, Cint, Ptr{Cint}),
          wireTag, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddSurfaceFilling returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addSurfaceLoop(surfaceTags, tag = -1)

Add a surface loop (a closed shell) formed by `surfaceTags`.  If `tag` is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
Return the tag of the surface loop.

Return an integer.
"""
function addSurfaceLoop(surfaceTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddSurfaceLoop, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, surfaceTags), length(surfaceTags), tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddSurfaceLoop returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addVolume(shellTags, tag = -1)

Add a volume (a region) defined by one or more surface loops `shellTags`. The
first surface loop defines the exterior boundary; additional surface loop define
holes. If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the volume.

Return an integer.
"""
function addVolume(shellTags, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddVolume, gmsh.clib), Cint,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, shellTags), length(shellTags), tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddVolume returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addSphere(xc, yc, zc, radius, tag = -1, angle1 = -pi/2, angle2 = pi/2, angle3 = 2*pi)

Add a sphere of center (`xc`, `yc`, `zc`) and radius `r`. The optional `angle1`
and `angle2` arguments define the polar angle opening (from -Pi/2 to Pi/2). The
optional `angle3` argument defines the azimuthal opening (from 0 to 2*Pi). If
`tag` is positive, set the tag explicitly; otherwise a new tag is selected
automatically. Return the tag of the sphere.

Return an integer.
"""
function addSphere(xc, yc, zc, radius, tag = -1, angle1 = -pi/2, angle2 = pi/2, angle3 = 2*pi)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddSphere, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          xc, yc, zc, radius, tag, angle1, angle2, angle3, ierr)
    ierr[] != 0 && error("gmshModelOccAddSphere returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addBox(x, y, z, dx, dy, dz, tag = -1)

Add a parallelepipedic box defined by a point (`x`, `y`, `z`) and the extents
along the x-, y- and z-axes. If `tag` is positive, set the tag explicitly;
otherwise a new tag is selected automatically. Return the tag of the box.

Return an integer.
"""
function addBox(x, y, z, dx, dy, dz, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddBox, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Ptr{Cint}),
          x, y, z, dx, dy, dz, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddBox returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addCylinder(x, y, z, dx, dy, dz, r, tag = -1, angle = 2*pi)

Add a cylinder, defined by the center (`x`, `y`, `z`) of its first circular
face, the 3 components (`dx`, `dy`, `dz`) of the vector defining its axis and
its radius `r`. The optional `angle` argument defines the angular opening (from
0 to 2*Pi). If `tag` is positive, set the tag explicitly; otherwise a new tag is
selected automatically. Return the tag of the cylinder.

Return an integer.
"""
function addCylinder(x, y, z, dx, dy, dz, r, tag = -1, angle = 2*pi)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddCylinder, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, dz, r, tag, angle, ierr)
    ierr[] != 0 && error("gmshModelOccAddCylinder returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addCone(x, y, z, dx, dy, dz, r1, r2, tag = -1, angle = 2*pi)

Add a cone, defined by the center (`x`, `y`, `z`) of its first circular face,
the 3 components of the vector (`dx`, `dy`, `dz`) defining its axis and the two
radii `r1` and `r2` of the faces (these radii can be zero). If `tag` is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
`angle` defines the optional angular opening (from 0 to 2*Pi). Return the tag of
the cone.

Return an integer.
"""
function addCone(x, y, z, dx, dy, dz, r1, r2, tag = -1, angle = 2*pi)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddCone, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, dz, r1, r2, tag, angle, ierr)
    ierr[] != 0 && error("gmshModelOccAddCone returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addWedge(x, y, z, dx, dy, dz, tag = -1, ltx = 0.)

Add a right angular wedge, defined by the right-angle point (`x`, `y`, `z`) and
the 3 extends along the x-, y- and z-axes (`dx`, `dy`, `dz`). If `tag` is
positive, set the tag explicitly; otherwise a new tag is selected automatically.
The optional argument `ltx` defines the top extent along the x-axis. Return the
tag of the wedge.

Return an integer.
"""
function addWedge(x, y, z, dx, dy, dz, tag = -1, ltx = 0.)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddWedge, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, dx, dy, dz, tag, ltx, ierr)
    ierr[] != 0 && error("gmshModelOccAddWedge returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addTorus(x, y, z, r1, r2, tag = -1, angle = 2*pi)

Add a torus, defined by its center (`x`, `y`, `z`) and its 2 radii `r` and `r2`.
If `tag` is positive, set the tag explicitly; otherwise a new tag is selected
automatically. The optional argument `angle` defines the angular opening (from 0
to 2*Pi). Return the tag of the wedge.

Return an integer.
"""
function addTorus(x, y, z, r1, r2, tag = -1, angle = 2*pi)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshModelOccAddTorus, gmsh.clib), Cint,
          (Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cint, Cdouble, Ptr{Cint}),
          x, y, z, r1, r2, tag, angle, ierr)
    ierr[] != 0 && error("gmshModelOccAddTorus returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.model.occ.addThruSections(wireTags, outDimTags, tag = -1, makeSolid = true, makeRuled = false)

Add a volume (if the optional argument `makeSolid` is set) or surfaces defined
through the open or closed wires `wireTags`. If `tag` is positive, set the tag
explicitly; otherwise a new tag is selected automatically. The new entities are
returned in `outDimTags`. If the optional argument `makeRuled` is set, the
surfaces created on the boundary are forced to be ruled surfaces.

Return 'outDimTags'.
"""
function addThruSections(wireTags, tag = -1, makeSolid = true, makeRuled = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccAddThruSections, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, wireTags), length(wireTags), api_outDimTags_, api_outDimTags_n_, tag, makeSolid, makeRuled, ierr)
    ierr[] != 0 && error("gmshModelOccAddThruSections returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.addThickSolid(volumeTag, excludeSurfaceTags, offset, outDimTags, tag = -1)

Add a hollowed volume built from an initial volume `volumeTag` and a set of
faces from this volume `excludeSurfaceTags`, which are to be removed. The
remaining faces of the volume become the walls of the hollowed solid, with
thickness `offset`. If `tag` is positive, set the tag explicitly; otherwise a
new tag is selected automatically.

Return 'outDimTags'.
"""
function addThickSolid(volumeTag, excludeSurfaceTags, offset, tag = -1)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccAddThickSolid, gmsh.clib), Void,
          (Cint, Ptr{Cint}, Csize_t, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          volumeTag, convert(Vector{Cint}, excludeSurfaceTags), length(excludeSurfaceTags), offset, api_outDimTags_, api_outDimTags_n_, tag, ierr)
    ierr[] != 0 && error("gmshModelOccAddThickSolid returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.extrude(dimTags, dx, dy, dz, outDimTags, numElements = Cint[], heights = Cdouble[], recombine = false)

Extrude the geometrical entities `dimTags` by translation along (`dx`, `dy`,
`dz`). Return extruded entities in `outDimTags`. If `numElements` is not empty,
also extrude the mesh: the entries in `numElements` give the number of elements
in each layer. If `height` is not empty, it provides the (cummulative) height of
the different layers, normalized to 1.

Return 'outDimTags'.
"""
function extrude(dimTags, dx, dy, dz, numElements = Cint[], heights = Cdouble[], recombine = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccExtrude, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), dx, dy, dz, api_outDimTags_, api_outDimTags_n_, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    ierr[] != 0 && error("gmshModelOccExtrude returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.revolve(dimTags, x, y, z, ax, ay, az, angle, outDimTags, numElements = Cint[], heights = Cdouble[], recombine = false)

Extrude the geometrical entities `dimTags` by rotation of `angle` radians around
the axis of revolution defined by the point (`x`, `y`, `z`) and the direction
(`ax`, `ay`, `az`). Return extruded entities in `outDimTags`. If `numElements`
is not empty, also extrude the mesh: the entries in `numElements` give the
number of elements in each layer. If `height` is not empty, it provides the
(cummulative) height of the different layers, normalized to 1.

Return 'outDimTags'.
"""
function revolve(dimTags, x, y, z, ax, ay, az, angle, numElements = Cint[], heights = Cdouble[], recombine = false)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccRevolve, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}, Csize_t, Ptr{Cdouble}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, ax, ay, az, angle, api_outDimTags_, api_outDimTags_n_, convert(Vector{Cint}, numElements), length(numElements), heights, length(heights), recombine, ierr)
    ierr[] != 0 && error("gmshModelOccRevolve returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.addPipe(dimTags, wireTag, outDimTags)

Add a pipe by extruding the entities `dimTags` along the wire `wireTag`. Return
the pipe in `outDimTags`.

Return 'outDimTags'.
"""
function addPipe(dimTags, wireTag)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccAddPipe, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), wireTag, api_outDimTags_, api_outDimTags_n_, ierr)
    ierr[] != 0 && error("gmshModelOccAddPipe returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.fillet(volumeTags, curveTags, radius, outDimTags, removeVolume = true)

Fillet the volumes `volumeTags` on the curves `curveTags` with radius `radius`.
Return the filleted entities in `outDimTags`. Remove the original volume if
`removeVolume` is set.

Return 'outDimTags'.
"""
function fillet(volumeTags, curveTags, radius, removeVolume = true)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccFillet, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Cdouble, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cint}),
          convert(Vector{Cint}, volumeTags), length(volumeTags), convert(Vector{Cint}, curveTags), length(curveTags), radius, api_outDimTags_, api_outDimTags_n_, removeVolume, ierr)
    ierr[] != 0 && error("gmshModelOccFillet returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.fuse(objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag = -1, removeObject = true, removeTool = true)

Compute the boolean union (the fusion) of the entities `objectDimTags` and
`toolDimTags`. Return the resulting entities in `outDimTags`. If `tag` is
positive, try to set the tag explicitly (ony valid if the boolean operation
results in a single entity). Remove the object if `removeObject` is set. Remove
the tool if `removeTool` is set.

Return 'outDimTags', 'outDimTagsMap'.
"""
function fuse(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    api_outDimTagsMap_ = Ref{Ptr{Ptr{Cint}}}()
    api_outDimTagsMap_n_ = Ref{Ptr{Csize_t}}()
    api_outDimTagsMap_nn_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccFuse, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(objectDimTags))), 2 * length(objectDimTags), convert(Vector{Cint}, collect(Cint, Iterators.flatten(toolDimTags))), 2 * length(toolDimTags), api_outDimTags_, api_outDimTags_n_, api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_, tag, removeObject, removeTool, ierr)
    ierr[] != 0 && error("gmshModelOccFuse returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    tmp_api_outDimTagsMap_ = unsafe_wrap(Array, api_outDimTagsMap_[], api_outDimTagsMap_nn_[], true)
    tmp_api_outDimTagsMap_n_ = unsafe_wrap(Array, api_outDimTagsMap_n_[], api_outDimTagsMap_nn_[], true)
    outDimTagsMap = Vector{Tuple{Cint,Cint}}[]
    resize!(outDimTagsMap, api_outDimTagsMap_nn_[])
    for i in 1:api_outDimTagsMap_nn_[]
        tmp = unsafe_wrap(Array, tmp_api_outDimTagsMap_[i], tmp_api_outDimTagsMap_n_[i], true)
        outDimTagsMap[i] = [(tmp[i], tmp[i+1]) for i in 1:2:length(tmp)]
    end
    return outDimTags, outDimTagsMap
end

"""
    gmsh.model.occ.intersect(objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag = -1, removeObject = true, removeTool = true)

Compute the boolean intersection (the common parts) of the entities
`objectDimTags` and `toolDimTags`. Return the resulting entities in
`outDimTags`. If `tag` is positive, try to set the tag explicitly (ony valid if
the boolean operation results in a single entity). Remove the object if
`removeObject` is set. Remove the tool if `removeTool` is set.

Return 'outDimTags', 'outDimTagsMap'.
"""
function intersect(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    api_outDimTagsMap_ = Ref{Ptr{Ptr{Cint}}}()
    api_outDimTagsMap_n_ = Ref{Ptr{Csize_t}}()
    api_outDimTagsMap_nn_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccIntersect, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(objectDimTags))), 2 * length(objectDimTags), convert(Vector{Cint}, collect(Cint, Iterators.flatten(toolDimTags))), 2 * length(toolDimTags), api_outDimTags_, api_outDimTags_n_, api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_, tag, removeObject, removeTool, ierr)
    ierr[] != 0 && error("gmshModelOccIntersect returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    tmp_api_outDimTagsMap_ = unsafe_wrap(Array, api_outDimTagsMap_[], api_outDimTagsMap_nn_[], true)
    tmp_api_outDimTagsMap_n_ = unsafe_wrap(Array, api_outDimTagsMap_n_[], api_outDimTagsMap_nn_[], true)
    outDimTagsMap = Vector{Tuple{Cint,Cint}}[]
    resize!(outDimTagsMap, api_outDimTagsMap_nn_[])
    for i in 1:api_outDimTagsMap_nn_[]
        tmp = unsafe_wrap(Array, tmp_api_outDimTagsMap_[i], tmp_api_outDimTagsMap_n_[i], true)
        outDimTagsMap[i] = [(tmp[i], tmp[i+1]) for i in 1:2:length(tmp)]
    end
    return outDimTags, outDimTagsMap
end

"""
    gmsh.model.occ.cut(objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag = -1, removeObject = true, removeTool = true)

Compute the boolean difference between the entities `objectDimTags` and
`toolDimTags`. Return the resulting entities in `outDimTags`. If `tag` is
positive, try to set the tag explicitly (ony valid if the boolean operation
results in a single entity). Remove the object if `removeObject` is set. Remove
the tool if `removeTool` is set.

Return 'outDimTags', 'outDimTagsMap'.
"""
function cut(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    api_outDimTagsMap_ = Ref{Ptr{Ptr{Cint}}}()
    api_outDimTagsMap_n_ = Ref{Ptr{Csize_t}}()
    api_outDimTagsMap_nn_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccCut, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(objectDimTags))), 2 * length(objectDimTags), convert(Vector{Cint}, collect(Cint, Iterators.flatten(toolDimTags))), 2 * length(toolDimTags), api_outDimTags_, api_outDimTags_n_, api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_, tag, removeObject, removeTool, ierr)
    ierr[] != 0 && error("gmshModelOccCut returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    tmp_api_outDimTagsMap_ = unsafe_wrap(Array, api_outDimTagsMap_[], api_outDimTagsMap_nn_[], true)
    tmp_api_outDimTagsMap_n_ = unsafe_wrap(Array, api_outDimTagsMap_n_[], api_outDimTagsMap_nn_[], true)
    outDimTagsMap = Vector{Tuple{Cint,Cint}}[]
    resize!(outDimTagsMap, api_outDimTagsMap_nn_[])
    for i in 1:api_outDimTagsMap_nn_[]
        tmp = unsafe_wrap(Array, tmp_api_outDimTagsMap_[i], tmp_api_outDimTagsMap_n_[i], true)
        outDimTagsMap[i] = [(tmp[i], tmp[i+1]) for i in 1:2:length(tmp)]
    end
    return outDimTags, outDimTagsMap
end

"""
    gmsh.model.occ.fragment(objectDimTags, toolDimTags, outDimTags, outDimTagsMap, tag = -1, removeObject = true, removeTool = true)

Compute the boolean fragments (general fuse) of the entities `objectDimTags` and
`toolDimTags`. Return the resulting entities in `outDimTags`. If `tag` is
positive, try to set the tag explicitly (ony valid if the boolean operation
results in a single entity). Remove the object if `removeObject` is set. Remove
the tool if `removeTool` is set.

Return 'outDimTags', 'outDimTagsMap'.
"""
function fragment(objectDimTags, toolDimTags, tag = -1, removeObject = true, removeTool = true)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    api_outDimTagsMap_ = Ref{Ptr{Ptr{Cint}}}()
    api_outDimTagsMap_n_ = Ref{Ptr{Csize_t}}()
    api_outDimTagsMap_nn_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccFragment, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cint}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Cint, Cint, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(objectDimTags))), 2 * length(objectDimTags), convert(Vector{Cint}, collect(Cint, Iterators.flatten(toolDimTags))), 2 * length(toolDimTags), api_outDimTags_, api_outDimTags_n_, api_outDimTagsMap_, api_outDimTagsMap_n_, api_outDimTagsMap_nn_, tag, removeObject, removeTool, ierr)
    ierr[] != 0 && error("gmshModelOccFragment returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    tmp_api_outDimTagsMap_ = unsafe_wrap(Array, api_outDimTagsMap_[], api_outDimTagsMap_nn_[], true)
    tmp_api_outDimTagsMap_n_ = unsafe_wrap(Array, api_outDimTagsMap_n_[], api_outDimTagsMap_nn_[], true)
    outDimTagsMap = Vector{Tuple{Cint,Cint}}[]
    resize!(outDimTagsMap, api_outDimTagsMap_nn_[])
    for i in 1:api_outDimTagsMap_nn_[]
        tmp = unsafe_wrap(Array, tmp_api_outDimTagsMap_[i], tmp_api_outDimTagsMap_n_[i], true)
        outDimTagsMap[i] = [(tmp[i], tmp[i+1]) for i in 1:2:length(tmp)]
    end
    return outDimTags, outDimTagsMap
end

"""
    gmsh.model.occ.translate(dimTags, dx, dy, dz)

Translate the geometrical entities `dimTags` along (`dx`, `dy`, `dz`).
"""
function translate(dimTags, dx, dy, dz)
    ierr = Ref{Cint}()
    ccall((:gmshModelOccTranslate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), dx, dy, dz, ierr)
    ierr[] != 0 && error("gmshModelOccTranslate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.rotate(dimTags, x, y, z, ax, ay, az, angle)

Rotate the geometrical entities `dimTags` of `angle` radians around the axis of
revolution defined by the point (`x`, `y`, `z`) and the direction (`ax`, `ay`,
`az`).
"""
function rotate(dimTags, x, y, z, ax, ay, az, angle)
    ierr = Ref{Cint}()
    ccall((:gmshModelOccRotate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, ax, ay, az, angle, ierr)
    ierr[] != 0 && error("gmshModelOccRotate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.dilate(dimTags, x, y, z, a, b, c)

Scale the geometrical entities `dimTag` by factors `a`, `b` and `c` along the
three coordinate axes; use (`x`, `y`, `z`) as the center of the homothetic
transformation.
"""
function dilate(dimTags, x, y, z, a, b, c)
    ierr = Ref{Cint}()
    ccall((:gmshModelOccDilate, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), x, y, z, a, b, c, ierr)
    ierr[] != 0 && error("gmshModelOccDilate returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.symmetry(dimTags, a, b, c, d)

Apply a symmetry transformation to the geometrical entities `dimTag`, with
respect to the plane of equation `a` * x + `b` * y + `c` * z + `d` = 0.
"""
function symmetry(dimTags, a, b, c, d)
    ierr = Ref{Cint}()
    ccall((:gmshModelOccSymmetry, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Cdouble, Cdouble, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), a, b, c, d, ierr)
    ierr[] != 0 && error("gmshModelOccSymmetry returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.copy(dimTags, outDimTags)

Copy the entities `dimTags`; the new entities are returned in `outDimTags`.

Return 'outDimTags'.
"""
function copy(dimTags)
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccCopy, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), api_outDimTags_, api_outDimTags_n_, ierr)
    ierr[] != 0 && error("gmshModelOccCopy returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.remove(dimTags, recursive = false)

Remove the entities `dimTags`. If `recursive` is true, remove all the entities
on their boundaries, down to dimension 0.
"""
function remove(dimTags, recursive = false)
    ierr = Ref{Cint}()
    ccall((:gmshModelOccRemove, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cint, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), recursive, ierr)
    ierr[] != 0 && error("gmshModelOccRemove returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.removeAllDuplicates()

Remove all duplicate entities (different entities at the same geometrical
location) after intersecting (using boolean fragments) all highest dimensional
entities.
"""
function removeAllDuplicates()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccRemoveAllDuplicates, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelOccRemoveAllDuplicates returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.importShapes(fileName, outDimTags, highestDimOnly = true, format = "")

Import BREP, STEP or IGES shapes from the file `fileName`. The imported entities
are returned in `outDimTags`. If the optional argument `highestDimOnly` is set,
only import the highest dimensional entities in the file. The optional argument
`format` can be used to force the format of the file (currently "brep", "step"
or "iges").

Return 'outDimTags'.
"""
function importShapes(fileName, highestDimOnly = true, format = "")
    api_outDimTags_ = Ref{Ptr{Cint}}()
    api_outDimTags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccImportShapes, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Cint, Ptr{Cchar}, Ptr{Cint}),
          fileName, api_outDimTags_, api_outDimTags_n_, highestDimOnly, format, ierr)
    ierr[] != 0 && error("gmshModelOccImportShapes returned non-zero error code: $(ierr[])")
    tmp_api_outDimTags_ = unsafe_wrap(Array, api_outDimTags_[], api_outDimTags_n_[], true)
    outDimTags = [ (tmp_api_outDimTags_[i], tmp_api_outDimTags_[i+1]) for i in 1:2:length(tmp_api_outDimTags_) ]
    return outDimTags
end

"""
    gmsh.model.occ.setMeshSize(dimTags, size)

Set a mesh size constraint on the geometrical entities `dimTags`. Currently only
entities of dimension 0 (points) are handled.
"""
function setMeshSize(dimTags, size)
    ierr = Ref{Cint}()
    ccall((:gmshModelOccSetMeshSize, gmsh.clib), Void,
          (Ptr{Cint}, Csize_t, Cdouble, Ptr{Cint}),
          convert(Vector{Cint}, collect(Cint, Iterators.flatten(dimTags))), 2 * length(dimTags), size, ierr)
    ierr[] != 0 && error("gmshModelOccSetMeshSize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.model.occ.synchronize()

Synchronize the internal OpenCASCADE CAD representation with the current Gmsh
model. This can be called at any time, but since it involves a non trivial
amount of processing, the number of synchronization points should normally be
minimized.
"""
function synchronize()
    ierr = Ref{Cint}()
    ccall((:gmshModelOccSynchronize, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshModelOccSynchronize returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module occ

end # end of module model

"""
    module gmsh.view

Post-processing view functions
"""
module view

import ..gmsh

"""
    gmsh.view.add(name, tag = -1)

Add a new post-processing view, with name `name`. If `tag` is positive use it
(and remove the view with that tag if it already exists), otherwise associate a
new tag. Return the view tag.

Return an integer.
"""
function add(name, tag = -1)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshViewAdd, gmsh.clib), Cint,
          (Ptr{Cchar}, Cint, Ptr{Cint}),
          name, tag, ierr)
    ierr[] != 0 && error("gmshViewAdd returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.view.remove(tag)

Remove the view with tag `tag`.
"""
function remove(tag)
    ierr = Ref{Cint}()
    ccall((:gmshViewRemove, gmsh.clib), Void,
          (Cint, Ptr{Cint}),
          tag, ierr)
    ierr[] != 0 && error("gmshViewRemove returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.view.getIndex(tag)

Get the index of the view with tag `tag` in the list of currently loaded views.
This dynamic index (it can change when views are removed) is used to access view
options.

Return an integer.
"""
function getIndex(tag)
    ierr = Ref{Cint}()
    api__result__ = ccall((:gmshViewGetIndex, gmsh.clib), Cint,
          (Cint, Ptr{Cint}),
          tag, ierr)
    ierr[] != 0 && error("gmshViewGetIndex returned non-zero error code: $(ierr[])")
    return api__result__
end

"""
    gmsh.view.getTags(tags)

Get the tags of all views.

Return 'tags'.
"""
function getTags()
    api_tags_ = Ref{Ptr{Cint}}()
    api_tags_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshViewGetTags, gmsh.clib), Void,
          (Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Cint}),
          api_tags_, api_tags_n_, ierr)
    ierr[] != 0 && error("gmshViewGetTags returned non-zero error code: $(ierr[])")
    tags = unsafe_wrap(Array, api_tags_[], api_tags_n_[], true)
    return tags
end

"""
    gmsh.view.addModelData(tag, step, modelName, dataType, tags, data, time = 0., numComponents = -1, partition = 0)

Add model-based post-processing data to the view with tag `tag`. `modelName`
identifies the model the data is attached to. `dataType` specifies the type of
data, currently either "NodeData", "ElementData" or "ElementNodeData". `step`
specifies the identifier (>= 0) of the data in a sequence. `tags` gives the tags
of the nodes or elements in the mesh to which the data is associated. `data` is
a vector of the same length as `tags`: each entry is the vector of double
precision numbers representing the data associated with the corresponding tag.
The optional `time` argument associate a time value with the data.
`numComponents` gives the number of data components (1 for scalar data, 3 for
vector data, etc.) per entity; if negative, it is automatically inferred (when
possible) from the input data. `partition` allows to specify data in several
sub-sets.
"""
function addModelData(tag, step, modelName, dataType, tags, data, time = 0., numComponents = -1, partition = 0)
    api_data_n_ = [ length(data[i]) for i in 1:length(data) ]
    ierr = Ref{Cint}()
    ccall((:gmshViewAddModelData, gmsh.clib), Void,
          (Cint, Cint, Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}, Csize_t, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Csize_t, Cdouble, Cint, Cint, Ptr{Cint}),
          tag, step, modelName, dataType, convert(Vector{Cint}, tags), length(tags), convert(Vector{Vector{Cdouble}},data), api_data_n_, length(data), time, numComponents, partition, ierr)
    ierr[] != 0 && error("gmshViewAddModelData returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.view.getModelData(tag, step, dataType, tags, data, time, numComponents)

Get model-based post-processing data from the view with tag `tag` at step
`step`. Return the `data` associated to the nodes or the elements with tags
`tags`, as well as the `dataType` and the number of components `numComponents`.

Return 'dataType', 'tags', 'data', 'time', 'numComponents'.
"""
function getModelData(tag, step)
    api_dataType_ = Ref{Ptr{Cchar}}()
    api_tags_ = Ref{Ptr{Cint}}()
    api_tags_n_ = Ref{Csize_t}()
    api_data_ = Ref{Ptr{Ptr{Cdouble}}}()
    api_data_n_ = Ref{Ptr{Csize_t}}()
    api_data_nn_ = Ref{Csize_t}()
    api_time_ = Ref{Cdouble}()
    api_numComponents_ = Ref{Cint}()
    ierr = Ref{Cint}()
    ccall((:gmshViewGetModelData, gmsh.clib), Void,
          (Cint, Cint, Ptr{Ptr{Cchar}}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Cdouble}, Ptr{Cint}, Ptr{Cint}),
          tag, step, api_dataType_, api_tags_, api_tags_n_, api_data_, api_data_n_, api_data_nn_, api_time_, api_numComponents_, ierr)
    ierr[] != 0 && error("gmshViewGetModelData returned non-zero error code: $(ierr[])")
    dataType = unsafe_string(api_dataType_[])
    tags = unsafe_wrap(Array, api_tags_[], api_tags_n_[], true)
    tmp_api_data_ = unsafe_wrap(Array, api_data_[], api_data_nn_[], true)
    tmp_api_data_n_ = unsafe_wrap(Array, api_data_n_[], api_data_nn_[], true)
    data = [ unsafe_wrap(Array, tmp_api_data_[i], tmp_api_data_n_[i], true) for i in 1:api_data_nn_[] ]
    return dataType, tags, data, api_time_[], api_numComponents_[]
end

"""
    gmsh.view.addListData(tag, dataType, numEle, data)

Add list-based post-processing data to the view with tag `tag`. `dataType`
identifies the data: "SP" for scalar points, "VP", for vector points, etc.
`numEle` gives the number of elements in the data. `data` contains the data for
the `numEle` elements.
"""
function addListData(tag, dataType, numEle, data)
    ierr = Ref{Cint}()
    ccall((:gmshViewAddListData, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cint, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          tag, dataType, numEle, data, length(data), ierr)
    ierr[] != 0 && error("gmshViewAddListData returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.view.getListData(tag, dataType, numElements, data)

Get list-based post-processing data from the view with tag `tag`. Return the
types `dataTypes`, the number of elements `numElements` for each data type and
the `data` for each data type.

Return 'dataType', 'numElements', 'data'.
"""
function getListData(tag)
    api_dataType_ = Ref{Ptr{Ptr{Cchar}}}()
    api_dataType_n_ = Ref{Csize_t}()
    api_numElements_ = Ref{Ptr{Cint}}()
    api_numElements_n_ = Ref{Csize_t}()
    api_data_ = Ref{Ptr{Ptr{Cdouble}}}()
    api_data_n_ = Ref{Ptr{Csize_t}}()
    api_data_nn_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshViewGetListData, gmsh.clib), Void,
          (Cint, Ptr{Ptr{Cchar}}, Ptr{Csize_t}, Ptr{Ptr{Cint}}, Ptr{Csize_t}, Ptr{Ptr{Ptr{Cdouble}}}, Ptr{Ptr{Csize_t}}, Ptr{Csize_t}, Ptr{Cint}),
          tag, api_dataType_, api_dataType_n_, api_numElements_, api_numElements_n_, api_data_, api_data_n_, api_data_nn_, ierr)
    ierr[] != 0 && error("gmshViewGetListData returned non-zero error code: $(ierr[])")
    tmp_api_dataType_ = unsafe_wrap(Array, api_dataType_[], api_dataType_n_[], true)
    dataType = [unsafe_string(tmp_api_dataType_[i]) for i in 1:length(tmp_api_dataType_) ]
    numElements = unsafe_wrap(Array, api_numElements_[], api_numElements_n_[], true)
    tmp_api_data_ = unsafe_wrap(Array, api_data_[], api_data_nn_[], true)
    tmp_api_data_n_ = unsafe_wrap(Array, api_data_n_[], api_data_nn_[], true)
    data = [ unsafe_wrap(Array, tmp_api_data_[i], tmp_api_data_n_[i], true) for i in 1:api_data_nn_[] ]
    return dataType, numElements, data
end

"""
    gmsh.view.probe(tag, x, y, z, value, step = -1, numComp = -1, gradient = false, tolerance = 0., xElemCoord = Cdouble[], yElemCoord = Cdouble[], zElemCoord = Cdouble[])

Probe the view `tag` for its `value` at point (`x`, `y`, `z`). Return only the
value at step `step` is `step` is positive. Return only values with `numComp` if
`numComp` is positive. Return the gradient of the `value` if `gradient` is set.
Probes with a geometrical tolerance (in the reference unit cube) of `tolerance`
if `tolerance` is not zero. Return the result from the element described by its
coordinates if `xElementCoord`, `yElementCoord` and `zElementCoord` are
provided.

Return 'value'.
"""
function probe(tag, x, y, z, step = -1, numComp = -1, gradient = false, tolerance = 0., xElemCoord = Cdouble[], yElemCoord = Cdouble[], zElemCoord = Cdouble[])
    api_value_ = Ref{Ptr{Cdouble}}()
    api_value_n_ = Ref{Csize_t}()
    ierr = Ref{Cint}()
    ccall((:gmshViewProbe, gmsh.clib), Void,
          (Cint, Cdouble, Cdouble, Cdouble, Ptr{Ptr{Cdouble}}, Ptr{Csize_t}, Cint, Cint, Cint, Cdouble, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cdouble}, Csize_t, Ptr{Cint}),
          tag, x, y, z, api_value_, api_value_n_, step, numComp, gradient, tolerance, xElemCoord, length(xElemCoord), yElemCoord, length(yElemCoord), zElemCoord, length(zElemCoord), ierr)
    ierr[] != 0 && error("gmshViewProbe returned non-zero error code: $(ierr[])")
    value = unsafe_wrap(Array, api_value_[], api_value_n_[], true)
    return value
end

"""
    gmsh.view.write(tag, fileName, append = false)

Write the view to a file `fileName`. The export format is determined by the file
extension. Append to the file if `append` is set.
"""
function write(tag, fileName, append = false)
    ierr = Ref{Cint}()
    ccall((:gmshViewWrite, gmsh.clib), Void,
          (Cint, Ptr{Cchar}, Cint, Ptr{Cint}),
          tag, fileName, append, ierr)
    ierr[] != 0 && error("gmshViewWrite returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module view

"""
    module gmsh.plugin

Plugin functions
"""
module plugin

import ..gmsh

"""
    gmsh.plugin.setNumber(name, option, value)

Set the numerical option `option` to the value `value` for plugin `name`.
"""
function setNumber(name, option, value)
    ierr = Ref{Cint}()
    ccall((:gmshPluginSetNumber, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Cdouble, Ptr{Cint}),
          name, option, value, ierr)
    ierr[] != 0 && error("gmshPluginSetNumber returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.plugin.setString(name, option, value)

Set the string option `option` to the value `value` for plugin `name`.
"""
function setString(name, option, value)
    ierr = Ref{Cint}()
    ccall((:gmshPluginSetString, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          name, option, value, ierr)
    ierr[] != 0 && error("gmshPluginSetString returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.plugin.run(name)

Run the plugin `name`.
"""
function run(name)
    ierr = Ref{Cint}()
    ccall((:gmshPluginRun, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cint}),
          name, ierr)
    ierr[] != 0 && error("gmshPluginRun returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module plugin

"""
    module gmsh.graphics

Graphics functions
"""
module graphics

import ..gmsh

"""
    gmsh.graphics.draw()

Draw all the OpenGL scenes.
"""
function draw()
    ierr = Ref{Cint}()
    ccall((:gmshGraphicsDraw, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshGraphicsDraw returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module graphics

"""
    module gmsh.fltk

Fltk graphical user interface functions
"""
module fltk

import ..gmsh

"""
    gmsh.fltk.initialize()

Create the Fltk graphical user interface.
"""
function initialize()
    ierr = Ref{Cint}()
    ccall((:gmshFltkInitialize, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshFltkInitialize returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.fltk.wait(time = -1.)

Wait at most `time` seconds for user interface events and return. If `time` < 0,
wait indefinitely. First automatically create the user interface if it has not
yet been initialized.
"""
function wait(time = -1.)
    ierr = Ref{Cint}()
    ccall((:gmshFltkWait, gmsh.clib), Void,
          (Cdouble, Ptr{Cint}),
          time, ierr)
    ierr[] != 0 && error("gmshFltkWait returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.fltk.run()

Run the event loop of the Fltk graphical user interface, i.e. repeatedly calls
`wait`. First automatically create the user interface if it has not yet been
initialized.
"""
function run()
    ierr = Ref{Cint}()
    ccall((:gmshFltkRun, gmsh.clib), Void,
          (Ptr{Cint},),
          ierr)
    ierr[] != 0 && error("gmshFltkRun returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module fltk

"""
    module gmsh.onelab

ONELAB server functions
"""
module onelab

import ..gmsh

"""
    gmsh.onelab.get(data, format = "json")

Get `data` from the ONELAB server.

Return 'data'.
"""
function get(format = "json")
    api_data_ = Ref{Ptr{Cchar}}()
    ierr = Ref{Cint}()
    ccall((:gmshOnelabGet, gmsh.clib), Void,
          (Ptr{Ptr{Cchar}}, Ptr{Cchar}, Ptr{Cint}),
          api_data_, format, ierr)
    ierr[] != 0 && error("gmshOnelabGet returned non-zero error code: $(ierr[])")
    data = unsafe_string(api_data_[])
    return data
end

"""
    gmsh.onelab.set(data, format = "json")

Set `data` in the ONELAB server.
"""
function set(data, format = "json")
    ierr = Ref{Cint}()
    ccall((:gmshOnelabSet, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          data, format, ierr)
    ierr[] != 0 && error("gmshOnelabSet returned non-zero error code: $(ierr[])")
    return nothing
end

"""
    gmsh.onelab.run(name = "", command = "")

Run a ONELAB client. If `name` is provided, create a new ONELAB client with name
`name` and executes `command`. If not, try to run a client that might be linked
to the processed input files.
"""
function run(name = "", command = "")
    ierr = Ref{Cint}()
    ccall((:gmshOnelabRun, gmsh.clib), Void,
          (Ptr{Cchar}, Ptr{Cchar}, Ptr{Cint}),
          name, command, ierr)
    ierr[] != 0 && error("gmshOnelabRun returned non-zero error code: $(ierr[])")
    return nothing
end

end # end of module onelab

end # end of module gmsh
