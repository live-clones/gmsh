// HighOrderMeshOptimizer - Copyright (C) 2013-2024 UCLouvain-ULiege
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished
// to do so, provided that the above copyright notice(s) and this
// permission notice appear in all copies of the Software and that
// both the above copyright notice(s) and this permission notice
// appear in supporting documentation.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR
// ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY
// DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
// WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
// ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
// OF THIS SOFTWARE.
//
// Contributors: Amaury Johnen

#include <vector>
#include <tuple>
#include <unordered_set>
#include "BoundaryLayerCurver.h"
#include "MQuadrangle.h"
#include "MTriangle.h"
#include "BasisFactory.h"
#include "GFace.h"
#include "orthogonalBasis.h"
#include "bezierBasis.h"
#include "gmshVertex.h"
#include "Geo.h"
#include "MLine.h"
#include "GModel.h"
#include "Options.h"
#include "AnalyseMeshQuality.h"
#include "InnerVertexPlacement.h"
#include "pointsGenerators.h"
#include "qualityMeasuresJacobian.h"

#if defined(HAVE_POST)
#include "PView.h"
#endif

#if defined(HAVE_FLTK)
#include "FlGui.h"
#endif

namespace {
  void drawEquidistantPoints(GEdge *gedge, int N)
  {
    return;
    const std::size_t numLine = gedge->getNumMeshElements();
    for(std::size_t i = 0; i < numLine; ++i) {
      gedge->getMeshElement(i)->setVisibility(0);
    }

    const double umin = gedge->getLowerBound();
    const double umax = gedge->getUpperBound();
    const double step = (umax - umin) / (N - 1);

    for(int i = 0; i < N; ++i) {
      const double u = umin + i * step;
      const GPoint p = gedge->point(u);
      MVertex *v = new MVertex(p.x(), p.y(), p.z());
      gedge->addMeshVertex(v);
      gedge->addLine(new MLine(v, v));
    }
  }

  void drawBezierControlPolygon(const bezierCoeff &controlPoints, GEdge *gedge)
  {
    const int nVert = controlPoints.getNumCoeff();

    MVertex *previous = nullptr;
    for(int i = 0; i < nVert; ++i) {
      MVertex *v = new MVertex(controlPoints(i, 0), controlPoints(i, 1),
                               controlPoints(i, 2), gedge);
      if(previous) {
        MLine *line = new MLine(v, previous);
        gedge->addLine(line);
      }
      gedge->addMeshVertex(v);
      previous = v;
    }
  }

  void drawBezierControlPolygon(const std::vector<MVertex *> &vertices,
                                GEdge *gedge = nullptr)
  {
    if(!gedge) { gedge = *GModel::current()->firstEdge(); }

    const int nVert = (int)vertices.size();
    fullMatrix<double> xyz(nVert, 3);
    for(int i = 0; i < nVert; ++i) {
      xyz(i, 0) = vertices[i]->x();
      xyz(i, 1) = vertices[i]->y();
      xyz(i, 2) = vertices[i]->z();
    }

    bezierCoeff *controlPoints =
      new bezierCoeff(FuncSpaceData(TYPE_LIN, nVert - 1, false), xyz);
    std::vector<bezierCoeff *> allControlPoints(1, controlPoints);

    int numSubdivision = 0; // change this to choose num subdivision
    while(numSubdivision-- > 0) {
      std::vector<bezierCoeff *> gatherSubs;
      for(std::size_t i = 0; i < allControlPoints.size(); ++i) {
        std::vector<bezierCoeff *> tmp;
        allControlPoints[i]->subdivide(tmp);
        gatherSubs.insert(allControlPoints.end(), tmp.begin(), tmp.end());
      }
      allControlPoints.swap(gatherSubs);
    }

    for(std::size_t i = 0; i < allControlPoints.size(); ++i) {
      drawBezierControlPolygon(*allControlPoints[i], gedge);
    }
  }

  void draw3DFrame(SPoint3 &p, SVector3 &t, SVector3 &n, SVector3 &w,
                   double unitDimension, GFace *gFace = nullptr)
  {
    //return;
    if(!gFace) gFace = *GModel::current()->firstFace();

    MVertex *v = new MVertex(p.x(), p.y(), p.z(), gFace);

    SPoint3 pnt = p + n * unitDimension * .75;
    MVertex *vn = new MVertex(pnt.x(), pnt.y(), pnt.z(), gFace);

    pnt = p + w * unitDimension * 2;
    MVertex *vw = new MVertex(pnt.x(), pnt.y(), pnt.z(), gFace);

    pnt = p + t * unitDimension;
    MVertex *vt = new MVertex(pnt.x(), pnt.y(), pnt.z(), gFace);

    gFace->addMeshVertex(v);
    gFace->addMeshVertex(vn);
    //gFace->addMeshVertex(vw);
    //gFace->addMeshVertex(vt);

    MLine *line = new MLine(v, vn);
    gFace->edges().front()->addLine(line);

    line = new MLine(v, vw);
    gFace->edges().front()->addLine(line);

    line = new MLine(v, vt);
    gFace->edges().front()->addLine(line);
  }

  double mat_lagToQLP_data[49] = {
    +1.0000000000000000e+00, -1.8483013037629372e-17, +6.4874230781787556e-02, -1.1460260316410287e-02, +3.2596233474845665e-02, +1.2425652401037421e-02, -3.3488927136802599e-03, +0.0000000000000000e+00,
    +1.0000000000000000e+00, -3.3488927136802876e-03, +1.2425652401037157e-02, +3.2596233474845540e-02, -1.1460260316410287e-02, +6.4874230781787945e-02, +0.0000000000000000e+00, +2.7718569305104452e-17,
    +7.8404322367895740e-01, +8.5610605622495117e-02, -1.2748657963601556e-01, -1.5469623069192057e-02, +2.3854348054117361e-03, +0.0000000000000000e+00, +8.2248352261609840e-17, +2.8608319680218147e-01,
    +8.0925103421550171e-01, +2.4114667168223775e-01, -6.0246246553466248e-02, +5.4068145035681525e-02, +0.0000000000000000e+00, -5.6409248159640818e-17, -1.8810533839033941e-01, +1.7988883770003475e-01,
    +7.0748734895786358e-01, +1.7988883770003464e-01, -1.8810533839033916e-01, +0.0000000000000000e+00, -7.4143747047910334e-17, +5.4068145035681026e-02, -6.0246246553466193e-02, +2.4114667168223808e-01,
    +8.0925103421550171e-01, +2.8608319680218131e-01, +0.0000000000000000e+00, +3.5272587045606591e-18, +2.3854348054116771e-03, -1.5469623069192140e-02, -1.2748657963601540e-01, +8.5610605622495228e-02,
    +7.8404322367895762e-01
  };
  double mat_hsrToLag_data[49] = {
    +1.0000000000000000e+00, +0.0000000000000000e+00, +8.3333333333333337e-01, +6.6666666666666674e-01, +5.0000000000000000e-01, +3.3333333333333337e-01, +1.6666666666666663e-01, +0.0000000000000000e+00,
    +1.0000000000000000e+00, +1.6666666666666663e-01, +3.3333333333333331e-01, +5.0000000000000000e-01, +6.6666666666666663e-01, +8.3333333333333337e-01, +0.0000000000000000e+00, +0.0000000000000000e+00,
    +7.3766570201547352e-02, +1.2661601687589272e-01, +1.4600389466457570e-01, +1.2661601687589275e-01, +7.3766570201547352e-02, +0.0000000000000000e+00, +0.0000000000000000e+00, +1.6519310155726549e-01,
    +1.4532513760587437e-01, +0.0000000000000000e+00, -1.4532513760587432e-01, -1.6519310155726549e-01, +0.0000000000000000e+00, +0.0000000000000000e+00, +2.3809805617891111e-01, +3.5003890277797871e-02,
    -1.2119890071674008e-01, +3.5003890277797746e-02, +2.3809805617891111e-01, +0.0000000000000000e+00, +0.0000000000000000e+00, -2.5169083230401351e-01, +1.0327462051989611e-01, +0.0000000000000000e+00,
    -1.0327462051989629e-01, +2.5169083230401351e-01, +0.0000000000000000e+00, +0.0000000000000000e+00, +1.6035395888188619e-01, -1.0316644759726000e-01, +9.9074883079202328e-02, -1.0316644759726017e-01,
    +1.6035395888188619e-01
  };
  double mat_lagToHSR_data[49] = {
    +1.0000000000000000e+00, +0.0000000000000000e+00, -3.9085820282083903e+00, -1.4238860442116279e+00, -7.5082824553250616e-01, +3.8983216244998015e-01, -2.0521204385347230e-01, +0.0000000000000000e+00,
    +1.0000000000000000e+00, -3.9085820282083903e+00, +1.4238860442116281e+00, -7.5082824553250627e-01, -3.8983216244998015e-01, -2.0521204385347203e-01, +0.0000000000000000e+00, +0.0000000000000000e+00,
    +4.2945074397434818e-01, +9.6271342970829399e-01, +1.3121264025666655e+00, -1.3547032266308625e+00, +9.7226252922883349e-01, +0.0000000000000000e+00, +0.0000000000000000e+00, +2.0448770326048513e+00,
    +2.3462312732182942e+00, +7.6539307473166673e-01, +1.5399099659117839e+00, -2.0771683518642017e+00, +0.0000000000000000e+00, +0.0000000000000000e+00, +2.8685085032583806e+00, -0.0000000000000000e+00,
    -2.6533824635316523e+00, -0.0000000000000000e+00, +2.6202357329776813e+00, +0.0000000000000000e+00, +0.0000000000000000e+00, +2.0448770326048509e+00, -2.3462312732182928e+00, +7.6539307473166651e-01,
    -1.5399099659117832e+00, -2.0771683518642008e+00, +0.0000000000000000e+00, +0.0000000000000000e+00, +4.2945074397434929e-01, -9.6271342970829632e-01, +1.3121264025666659e+00, +1.3547032266308614e+00,
    +9.7226252922883238e-01
  };
  double mat_alphaPoly_data[7] = {
    +1.9984014443252818e-15, +7.7715611723760958e-16, +4.3367759511373782e-03, +2.1117769933503935e-02, +6.3880615828660545e-02, +1.3614063665692966e-01, +1.1962310313379761e-01
  };
  double mat_alphaLag_data[7] = {
    +1.1102230246251565e-16, +1.1102230246251565e-16, +4.7572983373069255e-03, +2.2484806934916141e-02, +7.3262303253209315e-02, +2.4993557912680645e-01, +4.4688682527495810e-01
  };
  double vec_RSReval_data[61] = {
    -1.0000000000000000e+00, -9.6666666666666667e-01, -9.3333333333333335e-01, -9.0000000000000002e-01, -8.6666666666666670e-01, -8.3333333333333337e-01, -8.0000000000000004e-01, -7.6666666666666661e-01,
    -7.3333333333333339e-01, -6.9999999999999996e-01, -6.6666666666666674e-01, -6.3333333333333330e-01, -5.9999999999999998e-01, -5.6666666666666665e-01, -5.3333333333333333e-01, -5.0000000000000000e-01,
    -4.6666666666666667e-01, -4.3333333333333335e-01, -4.0000000000000002e-01, -3.6666666666666670e-01, -3.3333333333333337e-01, -3.0000000000000004e-01, -2.6666666666666672e-01, -2.3333333333333339e-01,
    -1.9999999999999996e-01, -1.6666666666666663e-01, -1.3333333333333330e-01, -9.9999999999999978e-02, -6.6666666666666652e-02, -3.3333333333333326e-02, +0.0000000000000000e+00, +3.3333333333333215e-02,
    +6.6666666666666652e-02, +1.0000000000000009e-01, +1.3333333333333330e-01, +1.6666666666666674e-01, +1.9999999999999996e-01, +2.3333333333333339e-01, +2.6666666666666661e-01, +3.0000000000000004e-01,
    +3.3333333333333326e-01, +3.6666666666666670e-01, +3.9999999999999991e-01, +4.3333333333333335e-01, +4.6666666666666656e-01, +5.0000000000000000e-01, +5.3333333333333321e-01, +5.6666666666666665e-01,
    +6.0000000000000009e-01, +6.3333333333333330e-01, +6.6666666666666674e-01, +6.9999999999999996e-01, +7.3333333333333339e-01, +7.6666666666666661e-01, +8.0000000000000004e-01, +8.3333333333333326e-01,
    +8.6666666666666670e-01, +8.9999999999999991e-01, +9.3333333333333335e-01, +9.6666666666666656e-01, +1.0000000000000000e+00
  };
  double mat_lagToTgRSR_A_data[420] = {
  -4.7070343328376065e+00, -4.4401199475910467e+00, -4.1326385822699203e+00, -3.7816443025768853e+00, -3.3878445628582199e+00, -2.9573561753158355e+00, -2.5026575066397760e+00, -2.0418602028799007e+00,
  -1.5959865009711431e+00, -1.1850038450243647e+00, -8.2417885601164753e-01, -5.2213848957268161e-01, -2.8100163255432958e-01, -9.7927851253613959e-02, +3.2925959832948576e-02, +1.1878692670043890e-01,
  +1.6726103057097708e-01, +1.8585736623099650e-01, +1.8180086274275084e-01, +1.6190211072613445e-01, +1.3236051183791817e-01, +9.8508185723893110e-02, +6.4586435596162436e-02, +3.3647511219908173e-02,
  +7.6122579864368765e-03, -1.2555064520272052e-02, -2.6626084559005475e-02, -3.4902602227863393e-02, -3.8053717589358459e-02, -3.6992128764864157e-02, -3.2770301011197038e-02, -2.6480216294980076e-02,
  -1.9155068385638171e-02, -1.1685261324576023e-02, -4.7643446788077455e-03, +1.1279779774876295e-03, +5.7114255971265505e-03, +8.8732602109315283e-03, +1.0633050274893143e-02, +1.1112234619891947e-02,
  +1.0509217329907216e-02, +9.0759092041902498e-03, +7.0915244942546416e-03, +4.8333886804241798e-03, +2.5492839908458813e-03, +4.3768085115326801e-04, -1.3602799556601184e-03, -2.7579491902554347e-03,
  -3.7141059671481828e-03, -4.2231473258694096e-03, -4.3082116797623499e-03, -4.0177927530642690e-03, -3.4234244123097085e-03, -2.6146785712623101e-03, -1.6891428518846232e-03, -7.3873552360500031e-04,
  +1.6301672783743798e-04, +9.6806781762516969e-04, +1.6537463516839467e-03, +2.2173651463924678e-03, -2.6688963458759963e-03, -2.2173651463899022e-03, -1.6537463516860483e-03, -9.6806781762147690e-04,
  -1.6301672783730164e-04, +7.3873552360358391e-04, +1.6891428518798020e-03, +2.6146785712630083e-03, +3.4234244123200232e-03, +4.0177927530662952e-03, +4.3082116797645790e-03, +4.2231473258681901e-03,
  +3.7141059671485155e-03, +2.7579491902561351e-03, +1.3602799556597356e-03, -4.3768085115324145e-04, -2.5492839908461337e-03, -4.8333886804251920e-03, -7.0915244942537977e-03, -9.0759092041892524e-03,
  -1.0509217329906850e-02, -1.1112234619891715e-02, -1.0633050274893065e-02, -8.8732602109311155e-03, -5.7114255971265748e-03, -1.1279779774874038e-03, +4.7643446788074219e-03, +1.1685261324575978e-02,
  +1.9155068385637491e-02, +2.6480216294981138e-02, +3.2770301011196511e-02, +3.6992128764865871e-02, +3.8053717589357078e-02, +3.4902602227863143e-02, +2.6626084559004674e-02, +1.2555064520272217e-02,
  -7.6122579864368618e-03, -3.3647511219907174e-02, -6.4586435596161923e-02, -9.8508185723891986e-02, -1.3236051183791628e-01, -1.6190211072612526e-01, -1.8180086274273977e-01, -1.8585736623101154e-01,
  -1.6726103057098027e-01, -1.1878692670043796e-01, -3.2925959832949991e-02, +9.7927851253627546e-02, +2.8100163255434474e-01, +5.2213848957263520e-01, +8.2417885601173102e-01, +1.1850038450243585e+00,
  +1.5959865009717153e+00, +2.0418602028799131e+00, +2.5026575066393395e+00, +2.9573561753156170e+00, +3.3878445628582399e+00, +3.7816443025774267e+00, +4.1326385822694824e+00, +4.4401199475915751e+00,
  +7.1894551638290540e+00, +6.5160539551884513e+00, +5.7407857227518919e+00, +4.8576083115468451e+00, +3.8706486261571222e+00, +2.7988207264016562e+00, +1.6782103845745207e+00, +5.5992671915220249e-01,
  -4.9732786542471363e-01, -1.4378772785595850e+00, -2.2187054717562895e+00, -2.8145051750220698e+00, -3.2173408999888373e+00, -3.4328160480933794e+00, -3.4754949905344192e+00, -3.3655044243392389e+00,
  -3.1268401750393893e+00, -2.7868123311180000e+00, -2.3755948373683560e+00, -1.9250081910530719e+00, -1.4662902596748491e+00, -1.0273490332265651e+00, -6.3039855914358478e-01, -2.9071709664171519e-01,
  -1.6705301089827786e-02, +1.8912187467118796e-01, +3.2879793123909840e-01, +4.0769245843807356e-01, +4.3360849316293115e-01, +4.1611289359251935e-01, +3.6590247089693617e-01, +2.9405549589352953e-01,
  +2.1117377955778852e-01, +1.2656921234385368e-01, +4.7688031121129501e-02, -2.0120248413727788e-02, -7.3520973998978764e-02, -1.1092892190068938e-01, -1.3220070965929318e-01, -1.3836931678096426e-01,
  -1.3142549633425801e-01, -1.1409565659487425e-01, -8.9563051072962932e-02, -6.1126358106189722e-02, -3.1851251649021493e-02, -4.2991153715716329e-03, +1.9608671795671009e-02, +3.8591280525492586e-02,
  +5.1925160788354373e-02, +5.9344825457241221e-02, +6.0976935346405914e-02, +5.7317525606713396e-02, +4.9220757420756489e-02, +3.7845660134741582e-02, +2.4523883509218462e-02, +1.0563417256215367e-02,
  -2.9461764206596295e-03, -1.5255181059443082e-02, -2.5971794569811055e-02, -3.4998559748412698e-02, -3.4825011241904247e+00, -2.8957620714905530e+00, -2.2198923290621919e+00, -1.4514650081867313e+00,
  -5.9739258764890146e-01, +3.2069767551240175e-01, +1.2643435393210274e+00, +2.1805505790038406e+00, +3.0091372705192403e+00, +3.6930137139528725e+00, +4.1873785268713020e+00, +4.4645102476742871e+00,
  +4.5136026428789275e+00, +4.3376545802763316e+00, +3.9501346531622654e+00, +3.3731672932303689e+00, +2.6374246990293178e+00, +1.7826512075246730e+00, +8.5722964474009755e-01, -8.4421834359945117e-02,
  -9.8670179951561099e-01, -1.7987085821528623e+00, -2.4792978195400854e+00, -2.9999088763829205e+00, -3.3449257245042925e+00, -3.5103972580353213e+00, -3.5022985976187799e+00, -3.3351546869573214e+00,
  -3.0311462168103285e+00, -2.6192149248094130e+00, -2.1334940387602859e+00, -1.6107048189831310e+00, -1.0867919707061302e+00, -5.9360506394921486e-01, -1.5650203938824159e-01, +2.0667526514875861e-01,
  +4.8540722393121444e-01, +6.7563859917522129e-01, +7.7883789953267391e-01, +8.0128402113657493e-01, +7.5352412403036118e-01, +6.4969546986490812e-01, +5.0640897043155719e-01, +3.4115390618941904e-01,
  +1.7052721066202720e-01, +8.7659635364779193e-03, -1.3305905531664106e-01, -2.4714764380892973e-01, -3.2862394891350927e-01, -3.7510463784908910e-01, -3.8646025097736109e-01, -3.6482929471460468e-01,
  -3.1469327836106070e-01, -2.4267069322358956e-01, -1.5677212701371082e-01, -6.5181230309825061e-02, +2.5032326567164951e-02, +1.0878745148993003e-01, +1.8321898045266685e-01, +2.4735902794463788e-01,
  +1.2618699691509405e+00, +1.0344058972355976e+00, +7.7064612081494444e-01, +4.7000133746465322e-01, +1.3683769122434886e-01, -2.1751877517531415e-01, -5.7383380361182335e-01, -9.0605680693597479e-01,
  -1.1847188494768199e+00, -1.3816621522298482e+00, -1.4742857264142499e+00, -1.4478495427972182e+00, -1.2956730044280820e+00, -1.0182249934030672e+00, -6.2237628593740890e-01, -1.2154526657550944e-01,
  +4.6337968844295613e-01, +1.1031646941260576e+00, +1.7605017737383286e+00, +2.3922036371610975e+00, +2.9532393923785403e+00, +3.4015763686310398e+00, +3.7023801832357770e+00, +3.8305613992901804e+00,
  +3.7716164431370465e+00, +3.5215134425969188e+00, +3.0865483979927753e+00, +2.4836437178171766e+00, +1.7408181817027852e+00, +8.9696462059715887e-01, +1.3333633439933683e-14, -8.9696462059721016e-01,
  -1.7408181817027601e+00, -2.4836437178171731e+00, -3.0865483979927588e+00, -3.5215134425969303e+00, -3.7716164431370447e+00, -3.8305613992902074e+00, -3.7023801832357823e+00, -3.4015763686310505e+00,
  -2.9532393923785745e+00, -2.3922036371611886e+00, -1.7605017737384363e+00, -1.1031646941258957e+00, -4.6337968844292254e-01, +1.2154526657550789e-01, +6.2237628593744154e-01, +1.0182249934029697e+00,
  +1.2956730044280225e+00, +1.4478495427974425e+00, +1.4742857264139417e+00, +1.3816621522294812e+00, +1.1847188494748864e+00, +9.0605680693587909e-01, +5.7383380361285752e-01, +2.1751877517569027e-01,
  -1.3683769122438236e-01, -4.7000133746564288e-01, -7.7064612081424178e-01, -1.0344058972363483e+00, -3.0155445320462426e-01, -2.4735902794441691e-01, -1.8321898045286678e-01, -1.0878745148962600e-01,
  -2.5032326567154387e-02, +6.5181230309710486e-02, +1.5677212701336177e-01, +2.4267069322362986e-01, +3.1469327836174926e-01, +3.6482929471473735e-01, +3.8646025097748382e-01, +3.7510463784900772e-01,
  +3.2862394891353142e-01, +2.4714764380896914e-01, +1.3305905531662518e-01, -8.7659635364768819e-03, -1.7052721066204088e-01, -3.4115390618948116e-01, -5.0640897043151434e-01, -6.4969546986486848e-01,
  -7.5352412403034519e-01, -8.0128402113657016e-01, -7.7883789953267124e-01, -6.7563859917520719e-01, -4.8540722393121538e-01, -2.0667526514875120e-01, +1.5650203938823123e-01, +5.9360506394921342e-01,
  +1.0867919707061138e+00, +1.6107048189831636e+00, +2.1334940387602734e+00, +2.6192149248094574e+00, +3.0311462168103049e+00, +3.3351546869573201e+00, +3.5022985976187662e+00, +3.5103972580353293e+00,
  +3.3449257245042916e+00, +2.9999088763829427e+00, +2.4792978195400868e+00, +1.7987085821528805e+00, +9.8670179951564385e-01, +8.4421834360071890e-02, -8.5722964473996122e-01, -1.7826512075248400e+00,
  -2.6374246990293613e+00, -3.3731672932303676e+00, -3.9501346531622938e+00, -4.3376545802762161e+00, -4.5136026428788494e+00, -4.4645102476746006e+00, -4.1873785268708810e+00, -3.6930137139523223e+00,
  -3.0091372705163524e+00, -2.1805505790037309e+00, -1.2643435393226927e+00, -3.2069767551312389e-01, +5.9739258764896230e-01, +1.4514650081885709e+00, +2.2198923290607913e+00, +2.8957620714920500e+00,
  +4.2433673598536947e-02, +3.4998559748376443e-02, +2.5971794569842332e-02, +1.5255181059391901e-02, +2.9461764206577933e-03, -1.0563417256195981e-02, -2.4523883509155419e-02, -3.7845660134749964e-02,
  -4.9220757420886510e-02, -5.7317525606738730e-02, -6.0976935346431574e-02, -5.9344825457225810e-02, -5.1925160788358640e-02, -3.8591280525500773e-02, -1.9608671795667141e-02, +4.2991153715713692e-03,
  +3.1851251649024387e-02, +6.1126358106202046e-02, +8.9563051072953773e-02, +1.1409565659486466e-01, +1.3142549633425427e-01, +1.3836931678096270e-01, +1.3220070965929237e-01, +1.1092892190068564e-01,
  +7.3520973998978972e-02, +2.0120248413725745e-02, -4.7688031121126614e-02, -1.2656921234385340e-01, -2.1117377955778335e-01, -2.9405549589353880e-01, -3.6590247089693229e-01, -4.1611289359253378e-01,
  -4.3360849316292177e-01, -4.0769245843807211e-01, -3.2879793123909279e-01, -1.8912187467118952e-01, +1.6705301089828182e-02, +2.9071709664170825e-01, +6.3039855914358300e-01, +1.0273490332265596e+00,
  +1.4662902596748362e+00, +1.9250081910530175e+00, +2.3755948373682885e+00, +2.7868123311180937e+00, +3.1268401750394124e+00, +3.3655044243392385e+00, +3.4754949905344326e+00, +3.4328160480933119e+00,
  +3.2173408999887854e+00, +2.8145051750222407e+00, +2.2187054717559258e+00, +1.4378772785594383e+00, +4.9732786542236468e-01, -5.5992671915195025e-01, -1.6782103845731278e+00, -2.7988207264009688e+00,
  -3.8706486261571622e+00, -4.8576083115484670e+00, -5.7407857227505712e+00, -6.5160539551898955e+00
};
double mat_lagToTgRSR_B_data[420] = {
  +7.4352659517194661e+00, +8.5977667107947120e+00, +9.8692847561934567e+00, +1.1187902315705990e+01, +1.2410567728035632e+01, +1.3355758225645987e+01, +1.3833234429040377e+01, +1.3705941577426518e+01,
  +1.2943389771430523e+01, +1.1637571543849653e+01, +9.9690120995254698e+00, +8.1442620486999857e+00, +6.3398898168331161e+00, +4.6751361326836420e+00, +3.2130489672873530e+00, +1.9769980140317056e+00,
  +9.6911534300839153e-01, +1.8288017168491319e-01, -3.9205113428840555e-01, -7.7064862996887629e-01, -9.7498592727103128e-01, -1.0348609111487206e+00, -9.8523728989210357e-01, -8.6165063464151070e-01,
  -6.9583615641714780e-01, -5.1323655630611142e-01, -3.3266844744821911e-01, -1.6736804758423313e-01, -2.6346334946617048e-02, +8.4695999040632519e-02, +1.6306983081861498e-01, +2.0909679997447697e-01,
  +2.2591390558377500e-01, +2.1879352502678362e-01, +1.9407712792382881e-01, +1.5808950046363057e-01, +1.1638419505573526e-01, +7.3449120323380024e-02, +3.2765544649737480e-02, -3.0036021158916810e-03,
  -3.1896101234904640e-02, -5.2681280357642232e-02, -6.4971132543258384e-02, -6.9261036608270501e-02, -6.6786366330448155e-02, -5.9207202704319145e-02, -4.8245578037815179e-02, -3.5417188871203605e-02,
  -2.1930007511295539e-02, -8.7306132888718309e-03, +3.3829465315076438e-03, +1.3680738715304069e-02, +2.1524952678013708e-02, +2.6499726934817513e-02, +2.8561480020973900e-02, +2.8089227270444810e-02,
  +2.5775973072232432e-02, +2.2419181151340759e-02, +1.8712968468590399e-02, +1.5165704563354448e-02, +1.1987712755565573e-02, +1.5165704563224651e-02, +1.8712968468631158e-02, +2.2419181151409014e-02,
  +2.5775973072120026e-02, +2.8089227270366394e-02, +2.8561480020953756e-02, +2.6499726935166543e-02, +2.1524952677999976e-02, +1.3680738715129499e-02, +3.3829465314919472e-03, -8.7306132889265909e-03,
  -2.1930007511231312e-02, -3.5417188871233143e-02, -4.8245578037826344e-02, -5.9207202704305406e-02, -6.6786366330480323e-02, -6.9261036608248921e-02, -6.4971132543213836e-02, -5.2681280357661245e-02,
  -3.1896101234915909e-02, -3.0036021158967342e-03, +3.2765544649743510e-02, +7.3449120323376679e-02, +1.1638419505573298e-01, +1.5808950046362474e-01, +1.9407712792382800e-01, +2.1879352502676780e-01,
  +2.2591390558380736e-01, +2.0909679997446742e-01, +1.6306983081863488e-01, +8.4695999040620418e-02, -2.6346334946664121e-02, -1.6736804758420890e-01, -3.3266844744821894e-01, -5.1323655630609666e-01,
  -6.9583615641713559e-01, -8.6165063464150493e-01, -9.8523728989210346e-01, -1.0348609111487146e+00, -9.7498592727093214e-01, -7.7064862996855488e-01, -3.9205113428895932e-01, +1.8288017168461995e-01,
  +9.6911534300884394e-01, +1.9769980140316163e+00, +3.2130489672874329e+00, +4.6751361326845347e+00, +6.3398898168308664e+00, +8.1442620487027177e+00, +9.9690120995230131e+00, +1.1637571543860362e+01,
  +1.2943389771434118e+01, +1.3705941577403101e+01, +1.3833234429039663e+01, +1.3355758225651613e+01, +1.2410567728054945e+01, +1.1187902315691483e+01, +9.8692847561909929e+00, +8.5977667108179006e+00,
  -1.8753719933009275e+01, -2.1690197100792165e+01, -2.4865741360766680e+01, -2.8106945383885709e+01, -3.1018815797219805e+01, -3.3108674090302124e+01, -3.3865929584005890e+01, -3.2928068226124843e+01,
  -3.0220240011425812e+01, -2.5993331522232864e+01, -2.0730418469484515e+01, -1.4981505281452810e+01, -9.2207489456333747e+00, -3.7834775124315669e+00, +1.1207908462572647e+00, +5.3583602652751514e+00,
  +8.8247014871948366e+00, +1.1425122175857021e+01, +1.3086890199770092e+01, +1.3789689630906162e+01, +1.3591763269020896e+01, +1.2632581497395874e+01, +1.1108163789209403e+01, +9.2316376384030203e+00,
  +7.1976788820165716e+00, +5.1631542516918980e+00, +3.2449950208191995e+00, +1.5282182040510115e+00, +7.5082736121703686e-02, -1.0707099846377053e+00, -1.8857848015104322e+00, -2.3713166022296757e+00,
  -2.5545310100941538e+00, -2.4843248768644877e+00, -2.2218868417472075e+00, -1.8301792243290227e+00, -1.3662067217464433e+00, -8.7777450251175693e-01, -4.0387147763482045e-01, +2.3624873826293413e-02,
  +3.7914118158281668e-01, +6.4443981659053695e-01, +8.1071962557159649e-01, +8.7991854510468404e-01, +8.6366814216439802e-01, +7.7986073235335385e-01, +6.4828203844451149e-01, +4.8714674460438318e-01,
  +3.1161499247944946e-01, +1.3421232933519417e-01, -3.3804599595584864e-02, -1.8145091750036110e-01, -2.9844774371141747e-01, -3.7722600013143404e-01, -4.1536690780126850e-01, -4.1670822773085225e-01,
  -3.9010557496435172e-01, -3.4654332082100137e-01, -2.9602677517527209e-01, -2.4625366048517550e-01, +1.6319211311026692e+01, +1.8912131888944558e+01, +2.1667052694736050e+01, +2.4406393029455213e+01,
  +2.6732351914639260e+01, +2.8158840844909758e+01, +2.8188536133015344e+01, +2.6473775937258122e+01, +2.2947795925791333e+01, +1.7856722504989506e+01, +1.1667027125936144e+01, +4.9098570261933316e+00,
  -1.9462847900232592e+00, -8.5417279319162915e+00, -1.4598922556811175e+01, -1.9866437674975671e+01, -2.4079222615251457e+01, -2.6963119577531167e+01, -2.8285853960653721e+01, -2.7930038349469612e+01,
  -2.5947822624481642e+01, -2.2564478453966402e+01, -1.8127905361855490e+01, -1.3031926579316902e+01, -7.6508997676554564e+00, -2.3084286987772438e+00, +2.7210559824605571e+00, +7.1960361659550101e+00,
  +1.0898513626480044e+01, +1.3644487921436589e+01, +1.5312230712277453e+01, +1.5872498753819157e+01, +1.5400960397319954e+01, +1.4062637609953189e+01, +1.2074582981477263e+01, +9.6642600829554208e+00,
  +7.0402103854520739e+00, +4.3815984376179706e+00, +1.8421566682073647e+00, -4.4213713392556686e-01, -2.3518479277132718e+00, -3.7934407696713404e+00, -4.7147528174937454e+00, -5.1162886911476919e+00,
  -5.0494507971731952e+00, -4.6008229589242404e+00, -3.8700213052099857e+00, -2.9513164813225239e+00, -1.9255531932180026e+00, -8.6260020941979754e-01, +1.7068684515051319e-01, +1.1046337109213560e+00,
  +1.8698058466310874e+00, +2.4104170367456659e+00, +2.7014296276477356e+00, +2.7579161149022000e+00, +2.6293067350222876e+00, +2.3820383069866082e+00, +2.0793388867264593e+00, +1.7720480270312602e+00,
  -6.2948788998663590e+00, -7.3606615700470801e+00, -8.4726211701849756e+00, -9.5452641285980242e+00, -1.0389080978576549e+01, -1.0775222094692857e+01, -1.0470465177907535e+01, -9.3113400521363801e+00,
  -7.2638287413966314e+00, -4.4378260587257490e+00, -1.0458859480690339e+00, +2.6645046999385347e+00, +6.4630121270700140e+00, +1.0149656237255021e+01, +1.3535067588070497e+01, +1.6411248824943204e+01,
  +1.8537974806389560e+01, +1.9660748412639592e+01, +1.9560019219635610e+01, +1.8112679581971580e+01, +1.5335648130097145e+01, +1.1388273729934671e+01, +6.5339281273154919e+00, +1.0846665201260157e+00,
  -4.6413308167052731e+00, -1.0333659355698460e+01, -1.5680155823485311e+01, -2.0353992580537117e+01, -2.4019593320465351e+01, -2.6368752887403112e+01, -2.7179031483171709e+01, -2.6368752887403552e+01,
  -2.4019593320463752e+01, -2.0353992580537653e+01, -1.5680155823485482e+01, -1.0333659355698661e+01, -4.6413308167055414e+00, +1.0846665201258006e+00, +6.5339281273160292e+00, +1.1388273729934147e+01,
  +1.5335648130096159e+01, +1.8112679581968766e+01, +1.9560019219641266e+01, +1.9660748412642555e+01, +1.8537974806384771e+01, +1.6411248824944735e+01, +1.3535067588069044e+01, +1.0149656237250717e+01,
  +6.4630121270801837e+00, +2.6645046999310544e+00, -1.0458859480716123e+00, -4.4378260587611704e+00, -7.2638287413986511e+00, -9.3113400520684575e+00, -1.0470465177910112e+01, -1.0775222094708111e+01,
  -1.0389080978609046e+01, -9.5452641285756918e+00, -8.4726211701755627e+00, -7.3606615700855444e+00, +1.4826615528490099e+00, +1.7720480270198975e+00, +2.0793388867295772e+00, +2.3820383069929791e+00,
  +2.6293067350126256e+00, +2.7579161148968070e+00, +2.7014296276466045e+00, +2.4104170367694975e+00, +1.8698058466302776e+00, +1.1046337109090780e+00, +1.7068684514951121e-01, -8.6260020942277649e-01,
  -1.9255531932141212e+00, -2.9513164813242136e+00, -3.8700213052105905e+00, -4.6008229589235707e+00, -5.0494507971750773e+00, -5.1162886911465124e+00, -4.7147528174914912e+00, -3.7934407696723889e+00,
  -2.3518479277137367e+00, -4.4213713392581810e-01, +1.8421566682076638e+00, +4.3815984376178339e+00, +7.0402103854519753e+00, +9.6642600829552610e+00, +1.2074582981477185e+01, +1.4062637609952828e+01,
  +1.5400960397320951e+01, +1.5872498753818915e+01, +1.5312230712277778e+01, +1.3644487921436566e+01, +1.0898513626478843e+01, +7.1960361659555012e+00, +2.7210559824606122e+00, -2.3084286987770510e+00,
  -7.6508997676551900e+00, -1.3031926579316920e+01, -1.8127905361855650e+01, -2.2564478453966029e+01, -2.5947822624480189e+01, -2.7930038349465999e+01, -2.8285853960660326e+01, -2.6963119577534808e+01,
  -2.4079222615246458e+01, -1.9866437674976940e+01, -1.4598922556809672e+01, -8.5417279319108381e+00, -1.9462847900368199e+00, +4.9098570262035981e+00, +1.1667027125939498e+01, +1.7856722505043564e+01,
  +2.2947795925793766e+01, +2.6473775937154677e+01, +2.8188536133016896e+01, +2.8158840844932413e+01, +2.6732351914702448e+01, +2.4406393029410335e+01, +2.1667052694720891e+01, +1.8912131889019207e+01,
  -2.0052769547340360e-01, -2.4625366048332306e-01, -2.9602677517581999e-01, -3.4654332082200628e-01, -3.9010557496276382e-01, -4.1670822772984845e-01, -4.1536690780103203e-01, -3.7722600013587837e-01,
  -2.9844774371125227e-01, -1.8145091749810327e-01, -3.3804599595388826e-02, +1.3421232933581917e-01, +3.1161499247867613e-01, +4.8714674460472984e-01, +6.4828203844463972e-01, +7.7986073235320486e-01,
  +8.6366814216477961e-01, +8.7991854510443868e-01, +8.1071962557111188e-01, +6.4443981659075034e-01, +3.7914118158293170e-01, +2.3624873826347204e-02, -4.0387147763489084e-01, -8.7777450251172040e-01,
  -1.3662067217464222e+00, -1.8301792243289721e+00, -2.2218868417471955e+00, -2.4843248768643709e+00, -2.5545310100944296e+00, -2.3713166022295993e+00, -1.8857848015105805e+00, -1.0707099846376438e+00,
  +7.5082736122088600e-02, +1.5282182040508374e+00, +3.2449950208191920e+00, +5.1631542516918092e+00, +7.1976788820164916e+00, +9.2316376384030043e+00, +1.1108163789209460e+01, +1.2632581497395764e+01,
  +1.3591763269020303e+01, +1.3789689630904245e+01, +1.3086890199773437e+01, +1.1425122175858899e+01, +8.8247014871920975e+00, +5.3583602652757971e+00, +1.1207908462564857e+00, -3.7834775124350704e+00,
  -9.2207489456243827e+00, -1.4981505281463894e+01, -2.0730418469477346e+01, -2.5993331522279057e+01, -3.0220240011426903e+01, -3.2928068226038377e+01, -3.3865929584013912e+01, -3.3108674090317685e+01,
  -3.1018815797278524e+01, -2.8106945383843065e+01, -2.4865741360756111e+01, -2.1690197100861049e+01
};
double mat_lagToTgRSR_C_data[420] = {
  +1.6619881738702439e+01, +1.8255141033554935e+01, +1.9890400328407431e+01, +1.9668126456968611e+01, +1.7011835912920546e+01, +1.1343879015390220e+01, +2.9804070864414598e+00, -6.7991926348572065e+00,
  -1.6077361545022697e+01, -2.3097185282403363e+01, -2.6959598047322277e+01, -2.7782903477442073e+01, -2.6348263478564011e+01, -2.3594347045920241e+01, -2.0268267915968437e+01, -1.6813260681700989e+01,
  -1.3423219448998447e+01, -1.0163835690705902e+01, -7.0841034884936604e+00, -4.2738213819204631e+00, -1.8562975371441868e+00, +6.0048020813504875e-02, +1.4286606168850031e+00, +2.2789390406327845e+00,
  +2.6954953060980875e+00, +2.7824926972330073e+00, +2.6345505685037605e+00, +2.3244614274158204e+00, +1.9061899517126630e+00, +1.4250800679048237e+00, +9.2613488543465294e-01, +4.5467418924121089e-01,
  +4.9838979037727570e-02, -2.6345039574746731e-01, -4.7804151734118039e-01, -6.0158730646476322e-01, -6.4957185577210086e-01, -6.3848038619855196e-01, -5.8202688401072888e-01, -4.9104751895814258e-01,
  -3.7572745461224927e-01, -2.4782791906987675e-01, -1.2086764649860926e-01, -7.8294754517538485e-03, +8.2069583786424927e-02, +1.4530532499744414e-01, +1.8354341499767629e-01, +2.0130826000066981e-01,
  +2.0330718079657079e-01, +1.9267464587614191e-01, +1.7073214873524120e-01, +1.3820161677865250e-01, +9.7124802102636076e-02, +5.2118425601478627e-02, +9.7341669832127914e-03, -2.3901749499085627e-02,
  -4.5495876447285415e-02, -5.5207881179465193e-02, -5.5978499303045222e-02, -5.0439417854033726e-02, +4.4900336381780460e-02, +5.0439417847991913e-02, +5.5978499314203366e-02, +5.5207881169132292e-02,
  +4.5495876452198068e-02, +2.3901749495193050e-02, -9.7341669775721975e-03, -5.2118425596043967e-02, -9.7124802118953746e-02, -1.3820161676715967e-01, -1.7073214874196796e-01, -1.9267464587058702e-01,
  -2.0330718079855470e-01, -2.0130826000150029e-01, -1.8354341499629592e-01, -1.4530532499807605e-01, -8.2069583787171607e-02, +7.8294754541137612e-03, +1.2086764649693883e-01, +2.4782791906963891e-01,
  +3.7572745461272111e-01, +4.9104751895785426e-01, +5.8202688401135350e-01, +6.3848038619764136e-01, +6.4957185577304366e-01, +6.0158730646370884e-01, +4.7804151734239086e-01, +2.6345039574580270e-01,
  -4.9838979034616142e-02, -4.5467418924558173e-01, -9.2613488542939459e-01, -1.4250800679110478e+00, -1.9061899517074776e+00, -2.3244614274188526e+00, -2.6345505685014676e+00, -2.7824926972348489e+00,
  -2.6954953060963365e+00, -2.2789390406347314e+00, -1.4286606168832359e+00, -6.0048020815089836e-02, +1.8562975371485704e+00, +4.2738213819227253e+00, +7.0841034884651854e+00, +1.0163835690742140e+01,
  +1.3423219448984659e+01, +1.6813260681698431e+01, +2.0268267915976200e+01, +2.3594347045936690e+01, +2.6348263478453163e+01, +2.7782903477702558e+01, +2.6959598046906155e+01, +2.3097185283214479e+01,
  +1.6077361543998133e+01, +6.7991926350713898e+00, -2.9804070859745573e+00, -1.1343879015667010e+01, -1.7011835912232932e+01, -1.9668126458671097e+01, -1.9890400326343411e+01, -1.8255141034849586e+01,
  -4.2254154325306182e+01, -4.5840160708180527e+01, -4.9426167091054879e+01, -4.7809953602515932e+01, -3.9546158797506934e+01, -2.3149589994962653e+01, +4.3192518384953421e-01, +2.7703915552581531e+01,
  +5.3530930888389889e+01, +7.3276323787398013e+01, +8.4611067795053273e+01, +8.7856327845897269e+01, +8.4966362228685838e+01, +7.8151780767368422e+01, +6.8976269993296569e+01, +5.8150812577240053e+01,
  +4.5839424080350518e+01, +3.2173196579515078e+01, +1.7679844137876984e+01, +3.4041387962051854e+00, -9.3419296527632074e+00, -1.9433523495987387e+01, -2.6299007749606798e+01, -2.9996776774584657e+01,
  -3.1021985917008617e+01, -3.0013752992731632e+01, -2.7531023933449347e+01, -2.3972280569596300e+01, -1.9621783468282942e+01, -1.4751998154499340e+01, -9.7002463516824768e+00, -4.8657076698948734e+00,
  -6.3072456603945892e-01, +2.7369085629294343e+00, +5.1362324905889958e+00, +6.6149960319565162e+00, +7.3041790455209226e+00, +7.3487875315196165e+00, +6.8683032147885310e+00, +5.9565873290448463e+00,
  +4.7089019036508883e+00, +3.2500571465806964e+00, +1.7383371228511060e+00, +3.3763046314151873e-01, -8.2514255135010728e-01, -1.6890797429812066e+00, -2.2582810742840809e+00, -2.5757777409197535e+00,
  -2.6901748228282396e+00, -2.6319050714994390e+00, -2.4086027964239172e+00, -2.0207867407193851e+00, -1.4891180456122941e+00, -8.7422964698821237e-01, -2.6999758310681832e-01, +2.2975798521930646e-01,
  +5.6832159777570779e-01, +7.3854602652480594e-01, +7.7695034284706777e-01, +7.1624309785583640e-01, +3.7678806959715850e+01, +4.0108810377820213e+01, +4.2538813795924575e+01, +3.9641396245650363e+01,
  +3.0137370309871017e+01, +1.2657297598243829e+01, -1.1766438955076154e+01, -3.9676366917640301e+01, -6.6103033426363780e+01, -8.6629169197690544e+01, -9.9061692173910927e+01, -1.0365341081837282e+02,
  -1.0203084366812494e+02, -9.5832450588666077e+01, -8.5883388158180381e+01, -7.2142065386754595e+01, -5.4241482821518993e+01, -3.2275426046872418e+01, -7.4066054468041669e+00, +1.8081073782327454e+01,
  +4.1385397967311569e+01, +6.0114927148145846e+01, +7.2982265615181490e+01, +7.9897097860976089e+01, +8.1533706488866784e+01, +7.8740425577479684e+01, +7.2144114859654351e+01, +6.2105290645179259e+01,
  +4.8969033170571770e+01, +3.3410195678124566e+01, +1.6622088047101457e+01, +1.8595319914966424e-01, -1.4332103894125659e+01, -2.5817579726877188e+01, -3.3824059127400844e+01, -3.8485627828254152e+01,
  -4.0235863096846558e+01, -3.9522495338176284e+01, -3.6660757744142188e+01, -3.1868056319845554e+01, -2.5423267493785797e+01, -1.7824517764956148e+01, -9.8148436697160797e+00, -2.2312325399022956e+00,
  +4.2363693591372211e+00, +9.2224657883313679e+00, +1.2701583823096371e+01, +1.4859560893527396e+01, +1.5913337749608143e+01, +1.5975251764338124e+01, +1.5023359872771099e+01, +1.2995046100354282e+01,
  +9.9601179709375991e+00, +6.2582177324998014e+00, +2.4721599945622925e+00, -7.7756537692838135e-01, -3.0807160194689671e+00, -4.3373368216014612e+00, -4.7436457862029684e+00, -4.4750800046530408e+00,
  -1.5640413078032029e+01, -1.6333067027389635e+01, -1.7025720976747241e+01, -1.5153567775644163e+01, -1.0160937723711626e+01, -1.4232957597776263e+00, +1.0566003263337318e+01, +2.4207750509797187e+01,
  +3.7217588812395512e+01, +4.7562491667730640e+01, +5.4195711651971195e+01, +5.7116007788255516e+01, +5.6839215025688844e+01, +5.3760108279861370e+01, +4.7802232244602976e+01, +3.8483204861578187e+01,
  +2.5318574581812637e+01, +8.3646336056882511e+00, -1.1386509395807636e+01, -3.2033679734113370e+01, -5.1277263822119700e+01, -6.7143968182754520e+01, -7.8486399895820867e+01, -8.4991448319863451e+01,
  -8.6788471785074691e+01, -8.3981384384720968e+01, -7.6413509648884570e+01, -6.3801593062669603e+01, -4.6166429135177474e+01, -2.4308357872955298e+01, -1.0290848315625155e-10, +2.4308357873147877e+01,
  +4.6166429135045966e+01, +6.3801593062736558e+01, +7.6413509648829105e+01, +8.3981384384774998e+01, +8.6788471785019254e+01, +8.4991448319920480e+01, +7.8486399895786946e+01, +6.7143968182756225e+01,
  +5.1277263822104516e+01, +3.2033679734073431e+01, +1.1386509396101573e+01, -8.3646336060627142e+00, -2.5318574581671033e+01, -3.8483204861529792e+01, -4.7802232244741276e+01, -5.3760108279808229e+01,
  -5.6839215025307354e+01, -5.7116007789166972e+01, -5.4195711650912692e+01, -4.7562491669774424e+01, -3.7217588809349742e+01, -2.4207750510744610e+01, -1.0566003264504968e+01, +1.4232957605649732e+00,
  +1.0160937722406931e+01, +1.5153567778593841e+01, +1.7025720973409825e+01, +1.6333067029290927e+01, +4.2065142210223661e+00, +4.4750800041042558e+00, +4.7436457871861455e+00, +4.3373368207159126e+00,
  +3.0807160198734733e+00, +7.7756537665198000e-01, -2.4721599941580576e+00, -6.2582177321551127e+00, -9.9601179720215445e+00, -1.2995046099614378e+01, -1.5023359873172723e+01, -1.5975251763995814e+01,
  -1.5913337749744526e+01, -1.4859560893558251e+01, -1.2701583823033070e+01, -9.2224657883563381e+00, -4.2363693591888643e+00, +2.2312325400458137e+00, +9.8148436696048336e+00, +1.7824517764968249e+01,
  +2.5423267493791307e+01, +3.1868056319846271e+01, +3.6660757744158204e+01, +3.9522495338146918e+01, +4.0235863096877047e+01, +3.8485627828221595e+01, +3.3824059127436165e+01, +2.5817579726833102e+01,
  +1.4332103894210563e+01, -1.8595319927160606e-01, -1.6622088046962386e+01, -3.3410195678274221e+01, -4.8969033170457223e+01, -6.2105290645242654e+01, -7.2144114859604528e+01, -7.8740425577524917e+01,
  -8.1533706488819846e+01, -7.9897097861031526e+01, -7.2982265615130942e+01, -6.0114927148179930e+01, -4.1385397967245275e+01, -1.8081073782328875e+01, +7.4066054464990181e+00, +3.2275426047266343e+01,
  +5.4241482821384722e+01, +7.2142065386700239e+01, +8.5883388158318425e+01, +9.5832450588646097e+01, +1.0203084366757382e+02, +1.0365341081963946e+02, +9.9061692172436892e+01, +8.6629169200685737e+01,
  +6.6103033421819902e+01, +3.9676366919007720e+01, +1.1766438956858849e+01, -1.2657297599393420e+01, -3.0137370307505421e+01, -3.9641396251258243e+01, -4.2538813789424744e+01, -4.0108810381626100e+01,
  -6.5553585252946067e-01, -7.1624309776812289e-01, -7.7695034300678512e-01, -7.3854602637880629e-01, -5.6832159784391800e-01, -2.2975798516862256e-01, +2.6999758303311505e-01, +8.7422964692148930e-01,
  +1.4891180458173048e+00, +2.0207867405771527e+00, +2.4086027965042964e+00, +2.6319050714319276e+00, +2.6901748228537832e+00, +2.5757777409278315e+00, +2.2582810742694663e+00, +1.6890797429874849e+00,
  +8.2514255135976078e-01, -3.3763046316999112e-01, -1.7383371228298121e+00, -3.2500571465810340e+00, -4.7089019036535289e+00, -5.9565873290440106e+00, -6.8683032147931318e+00, -7.3487875315117597e+00,
  -7.3041790455292590e+00, -6.6149960319472223e+00, -5.1362324905994958e+00, -2.7369085629157652e+00, +6.3072456601400773e-01, +4.8657076699309059e+00, +9.7002463516396578e+00, +1.4751998154548524e+01,
  +1.9621783468243340e+01, +2.3972280569619009e+01, +2.7531023933431790e+01, +3.0013752992746589e+01, +3.1021985916994062e+01, +2.9996776774601162e+01, +2.6299007749592707e+01, +1.9433523495996273e+01,
  +9.3419296527399869e+00, -3.4041387962217260e+00, -1.7679844137702641e+01, -3.2173196579733251e+01, -4.5839424080271172e+01, -5.8150812577217472e+01, -6.8976269993362351e+01, -7.8151780767383855e+01,
  -8.4966362228294969e+01, -8.7856327846891020e+01, -8.4611067793511992e+01, -7.3276323790539863e+01, -5.3530930883895110e+01, -2.7703915554449598e+01, -4.3192518481642284e-01, +2.3149589995703511e+01,
  +3.9546158795471058e+01, +4.7809953607593044e+01, +4.9426167085015265e+01, +4.5840160711836994e+01
};
double mat_lagToTgRSR_D_data[420] = {
  +1.6352592948524961e+01, +1.6352592948524961e+01, -2.2227387143881931e+00, -2.6562905440480662e+01, -5.6679568975303269e+01, -8.3634719289487620e+01, -9.7795997212986364e+01, -9.2781689101655232e+01,
  -7.0198237373806435e+01, -3.8624127649189283e+01, -8.2330543011979280e+00, +1.4346399988780622e+01, +2.7539164326437707e+01, +3.3260791299518047e+01, +3.4550072342674490e+01, +3.3900412327025428e+01,
  +3.2593837582925460e+01, +3.0797322022122422e+01, +2.8102821065731980e+01, +2.4175238447762773e+01, +1.9163455579576919e+01, +1.3686125960714985e+01, +8.5027842374778153e+00, +4.1655626546530167e+00,
  +8.6997391134919799e-01, -1.4794212872924686e+00, -3.1008914108794015e+00, -4.1827147570315750e+00, -4.8110988380783946e+00, -4.9894518247017086e+00, -4.7146069619344368e+00, -4.0483521020348210e+00,
  -3.1328937478519387e+00, -2.1459112159371383e+00, -1.2354578912358245e+00, -4.7984549307337815e-01, +1.1091469573548861e-01, +5.6453502187823279e-01, +9.0979365052586025e-01, +1.1532006434589372e+00,
  +1.2789953554237212e+00, +1.2696027257126794e+00, +1.1303817104685507e+00, +8.9899059238179091e-01, +6.3235741211019014e-01, +3.8238090000232283e-01, +1.7764845002993468e-01, +1.9989207959009651e-02,
  -1.0632534920428909e-01, -2.1942497140900644e-01, -3.2530531956588815e-01, -4.1076814676016299e-01, -4.5006376501157608e-01, -4.2384258618265702e-01, -3.3635916482298539e-01, -2.1594126948199721e-01,
  -9.7120047321798131e-02, -7.7061812358002642e-03, +5.5390814490115153e-02, +5.5390814490114994e-02, +5.5390814662114540e-02, +5.5390814662114540e-02, -7.7061814507107407e-03, -9.7120047169342263e-02,
  -2.1594126957005022e-01, -3.3635916472765254e-01, -4.2384258618471637e-01, -4.5006376522909941e-01, -4.1076814648205795e-01, -3.2530531974808408e-01, -2.1942497128618996e-01, -1.0632534927967677e-01,
  +1.9989207970544102e-02, +1.7764845005204369e-01, +3.8238089998219882e-01, +6.3235741210904461e-01, +8.9899059241285395e-01, +1.1303817104282510e+00, +1.2696027257270013e+00, +1.2789953554308222e+00,
  +1.1532006434513318e+00, +9.0979365053499262e-01, +5.6453502186287874e-01, +1.1091469575402267e-01, -4.7984549309334834e-01, -1.2354578912131799e+00, -2.1459112159658820e+00, -3.1328937478041894e+00,
  -4.0483521021096571e+00, -4.7146069618381299e+00, -4.9894518248165500e+00, -4.8110988379642832e+00, -4.1827147571137369e+00, -3.1008914108261609e+00, -1.4794212873338084e+00, +8.6997391138512770e-01,
  +4.1655626546160374e+00, +8.5027842375149856e+00, +1.3686125960681419e+01, +1.9163455579636668e+01, +2.4175238447741471e+01, +2.8102821065424703e+01, +3.0797322022769446e+01, +3.2593837582425309e+01,
  +3.3900412327137616e+01, +3.4550072342777810e+01, +3.3260791299604797e+01, +2.7539164325164641e+01, +1.4346399992494002e+01, -8.2330543079640002e+00, -3.8624127636916896e+01, -7.0198237392163236e+01,
  -9.2781689089267772e+01, -9.7795997210459177e+01, -8.3634719296924828e+01, -5.6679568965659044e+01, -2.6562905464381739e+01, -2.2227386767231323e+00, +1.6352592914938299e+01, +1.6352592914938370e+01,
  -3.5860063828743456e+01, -3.5860063828743527e+01, +1.6162134885389467e+01, +8.2637948050090003e+01, +1.6396568802544283e+02, +2.3581515178812191e+02, +2.7271990368731912e+02, +2.5827015335808449e+02,
  +1.9745392899008061e+02, +1.1334744007655300e+02, +3.2452600508439858e+01, -2.8899656172114312e+01, -6.8145814613174181e+01, -9.1755107740718543e+01, -1.0825457416056518e+02, -1.2311388496889538e+02,
  -1.3666227500835444e+02, -1.4493352441638098e+02, -1.4275705341671801e+02, -1.2746068448968396e+02, -1.0091593843224182e+02, -6.8654842536194124e+01, -3.6977690249778597e+01, -1.0252091424239577e+01,
  +1.0082329242769854e+01, +2.4827290592822855e+01, +3.5587433638530477e+01, +4.3504971013133591e+01, +4.8697853137836034e+01, +5.0517518028168645e+01, +4.8345386817876204e+01, +4.2349831038554015e+01,
  +3.3676331289688825e+01, +2.3993239276595698e+01, +1.4787635413675158e+01, +6.8918301356440885e+00, +4.4608485998693798e-01, -4.8048431673108718e+00, -9.1171588574368183e+00, -1.2476854253939624e+01,
  -1.4588447570701874e+01, -1.5117200237295958e+01, -1.4007066597095829e+01, -1.1627730144916301e+01, -8.6393719163109655e+00, -5.6920133130287631e+00, -3.1749666663567169e+00, -1.1439708190848572e+00,
  +5.8269751328800845e-01, +2.2330227507552110e+00, +3.8781605570453341e+00, +5.3166869510708938e+00, +6.1488839862408389e+00, +6.0423206388139219e+00, +4.9975556832612655e+00, +3.3856361255640026e+00,
  +1.7022442874909876e+00, +3.8404316322261700e-01, -6.0707244991231579e-01, -6.0707244991231957e-01, +2.4300034181043635e+01, +2.4300034181043635e+01, -2.8974175502742135e+01, -9.5040259357793474e+01,
  -1.7480072711627190e+02, -2.4423736553319989e+02, -2.7909927962564058e+02, -2.6426666508723571e+02, -2.0526135771326702e+02, -1.2432522976220427e+02, -4.5917186444618778e+01, +1.6225671502478750e+01,
  +6.1983930794588687e+01, +9.9490624304856993e+01, +1.3741322771425789e+02, +1.7900582565235607e+02, +2.1966056774646580e+02, +2.4868820600068256e+02, +2.5487679229131626e+02, +2.3304324184984119e+02,
  +1.8729529180834280e+02, +1.2867338467035648e+02, +6.9148322457946009e+01, +1.6366086278906899e+01, -2.7932809113871009e+01, -6.5963107178253338e+01, -1.0038824214475095e+02, -1.3136257474607493e+02,
  -1.5558837492447208e+02, -1.6788107631023112e+02, -1.6436134847951851e+02, -1.4518057093275277e+02, -1.1485475832751493e+02, -8.0064794005236848e+01, -4.6615687008532944e+01, -1.7502352685924116e+01,
  +7.1336775867027091e+00, +2.8617375940341066e+01, +4.7927014242966195e+01, +6.4447888260597793e+01, +7.5987497288296254e+01, +8.0096740952400978e+01, +7.5836111298137610e+01, +6.4676018990395391e+01,
  +4.9860964291941315e+01, +3.4791180347650155e+01, +2.1579770704310185e+01, +1.0537768560807436e+01, +6.1914014729980815e-01, -9.5189189156702145e+00, -2.0283137724168245e+01, -3.0349281294166730e+01,
  -3.7019002384378112e+01, -3.7860577379374973e+01, -3.2497253714906854e+01, -2.3031506425405784e+01, -1.2566208021324986e+01, -4.0630896460150598e+00, +2.6856578154992854e+00, +2.6856578154993032e+00,
  -6.9265394935760600e+00, -6.9265394935760600e+00, +1.8721532011030785e+01, +4.9926300519325380e+01, +8.7376419639340014e+01, +1.1989299023114948e+02, +1.3641747246459826e+02, +1.3009838302598371e+02,
  +1.0344902855335096e+02, +6.6332199842405785e+01, +2.9202961362843119e+01, -2.7679276256667156e+00, -3.0791067458274746e+01, -5.9578760352583956e+01, -9.3190273830247904e+01, -1.3164630279765552e+02,
  -1.6953940976124389e+02, -1.9751143001495890e+02, -2.0647170338305739e+02, -1.9243584088006335e+02, -1.5866704360634824e+02, -1.1342431713066350e+02, -6.5050484240425860e+01, -1.7970234652112339e+01,
  +2.8070874003537234e+01, +7.5678747358363992e+01, +1.2611916586214970e+02, +1.7635163927492133e+02, +2.1858071262222180e+02, +2.4308357872852395e+02, +2.4308357873250870e+02, +2.1858071261898021e+02,
  +1.7635163927690536e+02, +1.2611916586092593e+02, +7.5678747359458683e+01, +2.8070874002442665e+01, -1.7970234650987692e+01, -6.5050484241335568e+01, -1.1342431713030685e+02, -1.5866704360651767e+02,
  -1.9243584088031025e+02, -2.0647170337971932e+02, -1.9751143002164227e+02, -1.6953940975608378e+02, -1.3164630279858719e+02, -9.3190273832115167e+01, -5.9578760350669342e+01, -3.0791067454991154e+01,
  -2.7679276385961868e+00, +2.9202961382542703e+01, +6.6332199811382921e+01, +1.0344902860424649e+02, +1.3009838298605177e+02, +1.3641747246239601e+02, +1.1989299025069982e+02, +8.7376419618419320e+01,
  +4.9926300561869269e+01, +1.8721531948159789e+01, -6.9265394411890107e+00, -6.9265394411890711e+00, +2.6856578308188976e+00, +2.6856578308188976e+00, -4.0630896647023294e+00, -1.2566208008424397e+01,
  -2.3031506432214940e+01, -3.2497253708100381e+01, -3.7860577379970429e+01, -3.7019002398664448e+01, -3.0349281275928234e+01, -2.0283137735583523e+01, -9.5189189082308854e+00, +6.1914014251287963e-01,
  +1.0537768561862750e+01, +2.1579770705251814e+01, +3.4791180346767334e+01, +4.9860964291674748e+01, +6.4676018992346798e+01, +7.5836111295590214e+01, +8.0096740953634168e+01, +7.5987497288230600e+01,
  +6.4447888260549661e+01, +4.7927014243119331e+01, +2.8617375939887147e+01, +7.1336775873012703e+00, -1.7502352686554520e+01, -4.6615687007854312e+01, -8.0064794006030638e+01, -1.1485475832622542e+02,
  -1.4518057093482173e+02, -1.6436134847690784e+02, -1.6788107631311894e+02, -1.5558837492182954e+02, -1.3136257474785390e+02, -1.0038824214361910e+02, -6.5963107179203689e+01, -2.7932809112949386e+01,
  +1.6366086277883149e+01, +6.9148322459006081e+01, +1.2867338466950972e+02, +1.8729529180934722e+02, +2.3304324184916328e+02, +2.5487679228827983e+02, +2.4868820600767248e+02, +2.1966056774118456e+02,
  +1.7900582565315460e+02, +1.3741322771618235e+02, +9.9490624303276405e+01, +6.1983930789277032e+01, +1.6225671520656476e+01, -4.5917186472025548e+01, -1.2432522971751199e+02, -2.0526135778865773e+02,
  -2.6426666502812276e+02, -2.7909927962148782e+02, -2.4423736556252356e+02, -1.7480072708111948e+02, -9.5040259437528562e+01, -2.8974175381664917e+01, +2.4300034077986524e+01, +2.4300034077986577e+01,
  -6.0707245238662233e-01, -6.0707245238662233e-01, +3.8404316627978841e-01, +1.7022442853488833e+00, +3.3856361267529551e+00, +4.9975556820173770e+00, +6.0423206388837238e+00, +6.1488839889581763e+00,
  +5.3166869475984626e+00, +3.8781605592714512e+00, +2.2330227492763051e+00, +5.8269751421855542e-01, -1.1439708192595168e+00, -3.1749666665836527e+00, -5.6920133128198156e+00, -8.6393719162772431e+00,
  -1.1627730145297521e+01, -1.4007066596598213e+01, -1.5117200237512222e+01, -1.4588447570724952e+01, -1.2476854253904820e+01, -9.1171588574912139e+00, -4.8048431671862799e+00, +4.4608485982500529e-01,
  +6.8918301358203689e+00, +1.4787635413477268e+01, +2.3993239276837311e+01, +3.3676331289297742e+01, +4.2349831039168990e+01, +4.8345386817087530e+01, +5.0517518029088841e+01, +4.8697853136948012e+01,
  +4.3504971013756560e+01, +3.5587433638127933e+01, +2.4827290593147914e+01, +1.0082329242474763e+01, -1.0252091423928963e+01, -3.6977690250084677e+01, -6.8654842535964136e+01, -1.0091593843256321e+02,
  -1.2746068448961674e+02, -1.4275705341480966e+02, -1.4493352442030564e+02, -1.3666227500537971e+02, -1.2311388496946262e+02, -1.0825457416144917e+02, -9.1755107740214754e+01, -6.8145814609110928e+01,
  -2.8899656185960612e+01, +3.2452600533790175e+01, +1.1334744002972170e+02, +1.9745392906644690e+02, +2.5827015329445607e+02, +2.7271990369633090e+02, +2.3581515180520017e+02, +1.6396568799767496e+02,
  +8.2637948121220163e+01, +1.6162134774222160e+01, -3.5860063731782844e+01, -3.5860063731782887e+01
};

  fullMatrix<double> mat_lagToQLP(mat_lagToQLP_data, 7, 7);
  fullMatrix<double> mat_hsrToLag(mat_hsrToLag_data, 7, 7);
  fullMatrix<double> mat_lagToHSR(mat_lagToHSR_data, 7, 7);
  fullVector<double> mat_alphaPoly(mat_alphaPoly_data, 7);
  fullVector<double> mat_alphaLag(mat_alphaLag_data, 7);
  double limit_qlpPlus = 1.22;
  fullVector<double> vec_RSReval(vec_RSReval_data, 61);
  fullMatrix<double> mat_lagToTgRSR_A(mat_lagToTgRSR_A_data, 60, 7);
  fullMatrix<double> mat_lagToTgRSR_B(mat_lagToTgRSR_B_data, 60, 7);
  fullMatrix<double> mat_lagToTgRSR_C(mat_lagToTgRSR_C_data, 60, 7);
  fullMatrix<double> mat_lagToTgRSR_D(mat_lagToTgRSR_D_data, 60, 7);

  void applyQLPfilter(MEdgeN &edge, double fact=1.0)
  {
    fullMatrix<double> xyz(edge.getNumVertices(), 3);

    for(std::size_t i = 0; i < edge.getNumVertices(); ++i) {
      MVertex *v = edge.getVertex(i);
      xyz(i, 0) = v->x();
      xyz(i, 1) = v->y();
      xyz(i, 2) = v->z();
    }

    fullMatrix<double> xyz_filtered(edge.getNumVertices(), 3);
    mat_lagToQLP.mult(xyz, xyz_filtered);

    xyz_filtered.scale(fact);
    xyz_filtered.axpy(xyz, 1.0 - fact);

    for(std::size_t i = 0; i < edge.getNumVertices(); ++i) {
      MVertex *v = edge.getVertex(i);
      v->setXYZ(xyz_filtered(i, 0), xyz_filtered(i, 1), xyz_filtered(i, 2));
    }
  }

  SVector3 computeRSRtangent(const MEdgeN &edge, double paramEdge)
  {
    fullMatrix<double> xyz(edge.getNumVertices(), 3);

    for(std::size_t i = 0; i < edge.getNumVertices(); ++i) {
      MVertex *v = edge.getVertex(i);
      xyz(i, 0) = v->x();
      xyz(i, 1) = v->y();
      xyz(i, 2) = v->z();
    }


    const int nEval = vec_RSReval.size();
    const int nSeg  = nEval - 1;

    // Tangent polynomial coefficients per segment (nSeg x 3):
    // T(s) = A + u*B + u^2*C + u^3*D, where u in [0,1] over each segment
    fullMatrix<double> A(nSeg, 3), B(nSeg, 3), C(nSeg, 3), D(nSeg, 3);

    mat_lagToTgRSR_A.mult(xyz, A);
    mat_lagToTgRSR_B.mult(xyz, B);
    mat_lagToTgRSR_C.mult(xyz, C);
    mat_lagToTgRSR_D.mult(xyz, D);

    // Clamp outside range
    if(paramEdge <= vec_RSReval(0)) {
      return SVector3(A(0, 0), A(0, 1), A(0, 2)).unit();
    }
    if(paramEdge >= vec_RSReval(nEval - 1)) {
      const int s = nSeg - 1;

      const double u = vec_RSReval(s) - vec_RSReval(s-1);

      const double u2 = u * u;
      const double u3 = u2 * u;

      const double tx = A(s,0) + u * B(s,0) + u2 * C(s,0) + u3 * D(s,0);
      const double ty = A(s,1) + u * B(s,1) + u2 * C(s,1) + u3 * D(s,1);
      const double tz = A(s,2) + u * B(s,2) + u2 * C(s,2) + u3 * D(s,2);
      return SVector3(tx, ty, tz).unit();
    }

    // Find segment s such that vec_RSReval(s) <= paramEdge < vec_RSReval(s+1)
    int s = 0;
    while(s + 1 < nEval && vec_RSReval(s + 1) <= paramEdge) ++s;
    if(s < 0) s = 0;
    if(s > nSeg - 1) s = nSeg - 1;

    const double p0 = vec_RSReval(s);
    // const double p1 = vec_RSReval(s + 1);
    // const double denom = (p1 - p0);
    const double denom = 1.0;

    // Normalized local coordinate in [0,1]
    const double u = (denom != 0.) ? (paramEdge - p0) / denom : 0.;

    const double u2 = u * u;
    const double u3 = u2 * u;

    const double tx = A(s,0) + u * B(s,0) + u2 * C(s,0) + u3 * D(s,0);
    const double ty = A(s,1) + u * B(s,1) + u2 * C(s,1) + u3 * D(s,1);
    const double tz = A(s,2) + u * B(s,2) + u2 * C(s,2) + u3 * D(s,2);

    return SVector3(tx, ty, tz).unit();
  }

  void lag2HSR(const fullMatrix<double> &lagCoeff, fullMatrix<double> &hsrCoeff)
  {
    hsrCoeff.resize(lagCoeff.size1(), lagCoeff.size2());
    mat_lagToHSR.mult(lagCoeff, hsrCoeff);
  }

  void hsr2Lag(const fullMatrix<double> &hsrCoeff, fullMatrix<double> &lagCoeff)
  {
    lagCoeff.resize(hsrCoeff.size1(), hsrCoeff.size2());
    mat_hsrToLag.mult(hsrCoeff, lagCoeff);
  }

} // namespace

namespace BoundaryLayerCurver {
  void projectVertexIntoGFace(MVertex *v, const GFace *gface)
  {
    SPoint3 p = v->point();
    SPoint2 param = gface->parFromPoint(p);
    GPoint projected = gface->point(param);
    v->x() = projected.x();
    v->y() = projected.y();
    v->z() = projected.z();
  }

  void projectVerticesIntoGFace(const MEdgeN *edge, const GFace *gface,
                                bool alsoExtremity = true)
  {
    int i = alsoExtremity ? 0 : 2;

    for(; i < edge->getNumVertices(); ++i)
      projectVertexIntoGFace(edge->getVertex(i), gface);
  }

  void projectVerticesIntoGFace(const MFaceN *face, const GFace *gface,
                                bool alsoBoundary = true)
  {
    int i = alsoBoundary ? 0 : face->getNumVerticesOnBoundary();

    for(; i < face->getNumVertices(); ++i)
      projectVertexIntoGFace(face->getVertex(i), gface);
  }

  namespace EdgeCurver2D {
    // TODO: smooth normals if CAD not available
    // TODO: check quality of elements

    _Frame::_Frame(const MEdgeN *edge, const GFace *gface, const GEdge *gedge,
                   const SVector3 &normal)
      : _normalToTheMesh(normal), _gface(gface), _gedge(gedge),
        _edgeOnBoundary(edge), _newIdea(false)
    {
      const int nVert = (int)edge->getNumVertices();

      if(gface) {
        for(int i = 0; i < nVert; ++i) {
          SPoint2 param;
          bool success =
            reparamMeshVertexOnFace(edge->getVertex(i), gface, param, true);
          _paramVerticesOnGFace[2 * i + 0] = param[0];
          _paramVerticesOnGFace[2 * i + 1] = param[1];
          if(!success) {
            Msg::Warning("Could not compute param of node %d on surface %d",
                         edge->getVertex(i)->getNum(), gface->tag());
          }
          // TODO: Check if periodic face
        }
      }

      if(gedge) {
        for(int i = nVert - 1; i >= 0; --i) {
          bool success = reparamMeshVertexOnEdge(edge->getVertex(i), gedge,
                                                 _paramVerticesOnGEdge[i]);
          if(!success) {
            Msg::Warning("Could not compute param of node %d on edge %d",
                         edge->getVertex(i)->getNum(), gedge->tag());
          }
          // Periodicity check
          else if(gedge->periodic(0) && gedge->getBeginVertex() &&
                  edge->getVertex(i) ==
                    gedge->getBeginVertex()->mesh_vertices[0]) {
            double u0 = gedge->getLowerBound();
            double un = gedge->getUpperBound();
            // FIXME: It seems incorrect, in particular when nVert == 2 and i = 1. In this case
            //  _paramVerticesOnGEdge[0] is not defined yet.
            int k = (nVert == 2 ? 1 - i : (i == 0 ? 2 : nVert - 1));
            double uk = _paramVerticesOnGEdge[k];
            _paramVerticesOnGEdge[i] = uk - u0 < un - uk ? u0 : un;
          }
        }
      }
    }

    _Frame::_Frame(const MEdgeN *edge, const GFace *gface,
                   const SVector3 &normal)
      : _normalToTheMesh(normal), _gface(gface), _gedge(nullptr),
        _edgeOnBoundary(edge), _newIdea(true)
    {
      const int nVert = (int)edge->getNumVertices();

      {
        std::vector<MVertex*> cloned;
        cloned.reserve(nVert);
        for(std::size_t i = 0; i < nVert; ++i) {
          cloned.push_back(new MVertex(*edge->getVertex(i)));
        }

        _edgeFiltered = new MEdgeN(cloned);
        applyQLPfilter(*_edgeFiltered);
      }

      if(gface) {
        for(int i = 0; i < nVert; ++i) {
          SPoint2 param;
          bool success =
            reparamMeshVertexOnFace(edge->getVertex(i), gface, param, true);
          _paramVerticesOnGFace[2 * i + 0] = param[0];
          _paramVerticesOnGFace[2 * i + 1] = param[1];
          if(!success) {
            Msg::Warning("Could not compute param of node %d on surface %d",
                         edge->getVertex(i)->getNum(), gface->tag());
          }
          // TODO: Check if periodic face
        }
      }
    }

    void _Frame::computeFrame(double paramEdge, SVector3 &t, SVector3 &n,
                              SVector3 &w, bool atExtremity, int dev_interpType) const
    {
      // std::cout << std::endl << std::setprecision(20) << "paramEdge = " << paramEdge << std::endl;

      // Make sure that we execute the right code:
      if (_newIdea && _gedge) Msg::Error("There was an error in BLCurver computeFrame");

      // Compute tangent using geometry if available
      if(_gedge) {
        double paramGeoEdge;
        if(atExtremity) {
          if(paramEdge < 0)
            paramGeoEdge = _paramVerticesOnGEdge[0];
          else
            paramGeoEdge = _paramVerticesOnGEdge[1];
        }
        else
          paramGeoEdge =
            _edgeOnBoundary->interpolate(_paramVerticesOnGEdge, paramEdge);

        t = _gedge->firstDer(paramGeoEdge);
        t.normalize();
      }

      // Compute tangent using previous edge if necessary
      if(!_gedge || t.norm() == 0) {
        if (_newIdea) {
          // t = tangentBSpline(_edgeOnBoundary, paramEdge);
          // // TODO: Here, I have to change to compute smooth tangent
          switch (dev_interpType) {
          case -1:
            Msg::Error("dev_interpType = -1: unexpected");
          default:
            Msg::Error("not implemented, using BSpline tangent");
          case 3:
            t = tangentBSpline(_edgeOnBoundary, paramEdge);
            break;
          case 0:
            t = _edgeOnBoundary->tangent(paramEdge);
            break;
          case 1:
            t = _edgeFiltered->tangent(paramEdge);
            break;
          case 2:
            // FIXME
            // FIXME
            // FIXME
            t = _edgeFiltered->tangent(paramEdge);
            break;
          case 4:
            // std::cout << "LagrangeTangent = " << _edgeOnBoundary->tangent(paramEdge).x() << std::endl;
            // std::cout << "QLPTangent = " << _edgeFiltered->tangent(paramEdge).x() << std::endl;
            // std::cout << "BSplineTangent = " << tangentBSpline(_edgeOnBoundary, paramEdge).x() << std::endl;
            t = computeRSRtangent(_edgeOnBoundary[0], paramEdge);
            // std::cout << "RSRtangent = " << t.x() << std::endl;
            break;
          }
        }
        else
          t = _edgeOnBoundary->tangent(paramEdge);
      }

      // Compute normal to BL
      if(_gface) {
        SPoint2 paramGFace;
        if(atExtremity) {
          if(paramEdge < 0)
            paramGFace =
              SPoint2(_paramVerticesOnGFace[0], _paramVerticesOnGFace[1]);
          else
            paramGFace =
              SPoint2(_paramVerticesOnGFace[2], _paramVerticesOnGFace[3]);
        }
        else {
          paramGFace = SPoint2(
            _edgeOnBoundary->interpolate(_paramVerticesOnGFace, paramEdge, 2),
            _edgeOnBoundary->interpolate(_paramVerticesOnGFace + 1, paramEdge,
                                         2));
        }
        w = _gface->normal(paramGFace);
      }
      else {
        w = _normalToTheMesh;
      }
      if(w.norm() == 0) {
        Msg::Error("normal to the CAD or 2Dmesh is nul. BL curving will fail.");
      }

      // Compute normal inside BL
      n = crossprod(w, t);
    }

    SVector3 _Frame::tangentBSpline(const MEdgeN *edge, double u) const
    {
      const int orderBSpline = 2;

      // J'ai l'impression qu'il faut que je calcule _computeBSpline pour diffrent
      // knots (k1, k2, k3, k4) puis (k2, k3, k4, k5), puis (..) ...
      // De cette facon, j'aurais chaque fonction de la base auquel j'associe un
      // noeud de 'edge'.
      // Et puis je dois rgulariser.
      //
      // u in [0, 1]
      // Il y a une transformation  faire pour le domaine.
      // Ou pas ?
      // Si N = nombre points
      // step = 1 / (N-1)
      // knots = -5*step/2:step:1+5*step/2. Il y en a N+3
      // Si je donne (k0,...,k3)  (kN+1,...,kN+4), j'en ai N+2...
      // -1.5 -.5 .5 1.5 2.5 3.5

      const int N = static_cast<double>(edge->getNumVertices());
      double stepKnots = 2. / (N - 1.);

      std::vector<double> knots(4); // if orderBSpline=2
      std::vector<double> coeff(N+2); // if orderBSpline=2
      for (int i = 0; i < N+2; ++i) {
        for (int j = 0; j < 4; ++j) {
          knots[j] = -1 + stepKnots * (-2.5 + i + j); // if orderBSpline=2
        }
        coeff[i] = computeBSplineDerivative(orderBSpline, u, knots);
      }

      // Regularize (for orderBSpline=2)
      coeff[1] += 3 * coeff[0];
      coeff[2] -= 3 * coeff[0];
      coeff[3] += 1 * coeff[0];
      coeff[N-2] += 1 * coeff[N+1];
      coeff[N-1] -= 3 * coeff[N+1];
      coeff[N]   += 3 * coeff[N+1];

      coeff[0] = coeff[1];
      coeff[1] = coeff[N];
      double dx = 0, dy = 0, dz = 0;
      for (size_t i = 0; i < N; ++i) {
        const MVertex *v = edge->getVertex(i);
        dx += coeff[i] * v->x();
        dy += coeff[i] * v->y();
        dz += coeff[i] * v->z();
      }

      return SVector3(dx, dy, dz).unit();
    }

    double _Frame::computeBSpline(size_t n, double u, const std::vector<double>& t) const
    {
      if (n == 0) {
        return (u >= t[0] && u < t[1])? 1.0 : 0.0;
      }
      else {
        double a = (u - t[0]) / (t[n] - t[0]) * computeBSpline(n - 1, u, std::vector<double>(t.begin(), t.begin() + n + 1));
        double b = (t[n + 1] - u) / (t[n + 1] - t[1]) * computeBSpline(n - 1, u, std::vector<double>(t.begin() + 1, t.begin() + n + 2));
        return a + b;
      }
    }

    double _Frame::computeBSplineDerivative(size_t n, double u, const std::vector<double>& t) const
    {
      if (n == 0) {
        return 0.0;
      }
      else {
        double a = 1 / (t[n] - t[0]) * computeBSpline(n - 1, u, std::vector<double>(t.begin(), t.begin() + n + 1))
                   + (u - t[0]) / (t[n] - t[0]) * computeBSplineDerivative(n - 1, u, std::vector<double>(t.begin(), t.begin() + n + 1));
        double b = -1 / (t[n + 1] - t[1]) * computeBSpline(n - 1, u, std::vector<double>(t.begin() + 1, t.begin() + n + 2))
                   + (t[n + 1] - u) / (t[n + 1] - t[1]) * computeBSplineDerivative(n - 1, u, std::vector<double>(t.begin() + 1, t.begin() + n + 2));
        return a + b;
      }
    }

    SPoint3 _Frame::pnt(double u) const
    {
      if (_newIdea) return _edgeOnBoundary->pnt(u);

      if(!_gedge) return SPoint3();

      double paramGeoEdge =
        _edgeOnBoundary->interpolate(_paramVerticesOnGEdge, u);
      GPoint p = _gedge->point(paramGeoEdge);
      return SPoint3(p.x(), p.y(), p.z());
    }

    void _computeParameters(const MEdgeN *baseEdge, const MEdgeN *otherEdge,
                            const _Frame &frame, double coeffs[2][3], int dev_interpType)
    {
      SVector3 t, n, w, h;
      MVertex *vb, *vt;

      frame.computeFrame(-1, t, n, w, true, dev_interpType);
      vb = baseEdge->getVertex(0);
      vt = otherEdge->getVertex(0);
      h = SVector3(vt->x() - vb->x(), vt->y() - vb->y(), vt->z() - vb->z());
      coeffs[0][0] = dot(h, n);
      coeffs[0][1] = dot(h, t);
      coeffs[0][2] = dot(h, w);

//      SPoint3 p1 = frame.pnt(-1);
//      //      SPoint3 p1(vb->x(), vb->y(), vb->z());
//      draw3DFrame(p1, t, n, w, .0004);

      frame.computeFrame(1, t, n, w, true, dev_interpType);
      vb = baseEdge->getVertex(1);
      vt = otherEdge->getVertex(1);
      h = SVector3(vt->x() - vb->x(), vt->y() - vb->y(), vt->z() - vb->z());
      coeffs[1][0] = dot(h, n);
      coeffs[1][1] = dot(h, t);
      coeffs[1][2] = dot(h, w);
      //
//      SPoint3 p2 = frame.pnt(1);
//      //      SPoint3 p2(vb->x(), vb->y(), vb->z());
//      draw3DFrame(p2, t, n, w, .0004);
    }

    void _refPntsForALPShiftedCurve(const MEdgeN *baseEdge, const _Frame &frame,
                                    double coeffs[2][3], 
                                    const std::vector<double> &refTarget,
                                    std::vector<double> &refForExtrusion,
                                    int dev_interpType)
    {
      // ALP is for 'arc-length parameterized'
      // The idea is the following:
      //  Consider the points C_i of 'baseEdge' sampled at 'refTarget'.
      //  'baseEdge' is supposed to be ALP, which means that the
      //  arc lengths between the C_i have the same proportions than
      //  the difference between the ref-points 'refTarget'.
      //  Consider the points P_i of 'baseEdge' sampled at 'refForExtrusion'.
      //  Consider the points Q_i of the shifted curve facing the P_i.
      //  Then we want that the arc lengths between the Q_i to have the same
      //  proportions (than the difference between the ref-points 'refTarget').
      // Output:
      //  - 'refForExtrusion' are the ref-points such that the corresponding
      //  shifted xy-points, when associated with ref-points 'refTarget',
      //  implies an ALP of the shifted curve.

      // DONE : Calculer la courbe idale telle que sa param soit curviligne
      //   Actuellement,  tout point de l'arte prcdente, j'associe un point
      //   de la courbe shifte qui a le mme point de rfrence (dit autrement,
      //   avec les notations dcrite plus loin, je fais s(r) = r).
      //   Puis j'applique la correction pour que a match avec
      //   les noeuds P1 de l'arte en court, ce qui me donne la courbe idale
      //   dont la paramtrisation n'est pas curviligne. Je pense qu'il faut
      //   essayer d'avoir une paramtrisation proche de la curviligne (je pense
      //   surtout pour l'lment dans le coin). Pour faire a, voici une ide.
      //   - Soit l'arte prcdente : C(t)
      //   (- Soit la courbe idale : R(r) = C(s(r)) + D(r)
      //       o s(r) est  dfinir
      //       et D(r) est la correction.)
      //   - Soit la courbe shifte : Q(r) = C(s(r)) + N(s(r))
      //       o N(r) est le shift constant dans la direction de la normale.
      //   - Objectif : On veut s(r) tel que Q(r) soit une courbe de
      //      paramtrisation curviligne
      //   - Soit les points de Gauss (augments) : g_i (g_-1 = -1 et g_n+1 = 1)
      //      et leur diffrence : h_i = g_i+1 - g_i
      //   - Soit P_i = C(g_i)
      //   - Soit Q_i = Q(g_i) = C(s(g_i)) + N(s(g_i))  (donc pas forcment
      //      en face des P_i, a dpend de s(r))
      //   - Soit p_i et q_i : o_i = norm(O_i+1 - O_i)  (remplacer o et O)
      //   - On doit calculer s_i = s(g_i) mais on ne connait pas s(r).
      //   - Ici, je fais une approximation (qui est faible si l'paisseur est
      //      faible. Et si l'paisseur est importante, c'est moins grave qu'il
      //      y a une grosse erreur). Sachant que h_i est proportionnel  la
      //      longueur du segment de courbe, je dis que
      //        h_i / p_i = tau_i / q_i,
      //      o tau_i est approximativement proportionnel  la longeur du
      //      segment de la courbe shifte. Donc vu l'objectif, on veut
      //        tau_i / sum(tau_i) = g_i
      //   - Soit une premire approximation s^0(r) = r. On a s^0_i = g_i.
      //      Q^0_i = P_0(s^0_i) + N(s^0_i)
      //      q^0_i = norm(Q^0_i+1 - Q^0_i)
      //      tau^0_i = h_i / p_i * q^0_i
      //      kappa^0_i = sum_0_to_i(tau^0_k) / sum(tau^0_i)
      //   - On calcule s^1_i sur l'interpolation linaire f^0(s) des points
      //      (s^0_i, kappa^0_i) tel que f^0(s^1_i) = g_i

      // FIXME: thickness should be an input, this is a naive code:
      //  or we should keep it and check that ideal curve is ALP instead
      //  of shifted curve
      // FIXME norm3 should be norm3(const double a[3]) 
      //  so that I can have const double coeffs[2][3] here  
      double thickness = .5 * (norm3(coeffs[0]) + norm3(coeffs[1]));
  
      size_t nbPoints = refTarget.size();

      // ratios h_i / p_i
      std::vector<SPoint3> points(nbPoints);
//      points[0] = baseEdge->pnt(-1);
//      points[nbPoints-1] = baseEdge->pnt(1);
      for(size_t i = 0; i < nbPoints; ++i) {
        double u = refTarget[i];
        points[i] = baseEdge->pnt(u);
      }
      std::vector<double> ratios(nbPoints-1);
      for(size_t i = 0; i < nbPoints-1; ++i) {
        double numerator = refTarget[i+1] - refTarget[i];
        ratios[i] = numerator / norm(points[i+1]-points[i]);
      }

      // use now 'points' for shifted ones, extremities are fixed
      SVector3 t, n, w;
      frame.computeFrame(-1, t, n, w, false, dev_interpType);
      points[0] = points[0] + thickness * n;
      frame.computeFrame(1, t, n, w, false, dev_interpType);
      points[nbPoints-1] = points[nbPoints-1] + thickness * n;

      // Init refForExtrusion with refTarget (s^0_i = g_i)
      for(size_t i = 0; i < nbPoints; ++i) refForExtrusion[i] = refTarget[i];

      std::vector<double> taui(nbPoints-1);
      std::vector<double> kappai(nbPoints);
      std::vector<double> refNew(nbPoints);
      int k = 0;
      double maxChanged = 1;

      while(k < 20 && maxChanged > 1e-4) {
        ++k;
        // Compute shifted points
        for(size_t i = 1; i < nbPoints-1; ++i) {
          double u = refForExtrusion[i];
          frame.computeFrame(u, t, n, w, false, dev_interpType);
          points[i] = baseEdge->pnt(u) + thickness * n;
        }
//
//std::cout << "xy{" << k << "} = [" << std::endl;
//for(size_t i = 0; i < nbPoints; ++i) {
//  std::cout << points[i].x() << " " << points[i].y() << std::endl;
//}
//std::cout << "];" << std::endl;

        // Compute corresponding Kappa_i
        double accumulator = 0;
        kappai[0] = 0;
        for(size_t i = 0; i < nbPoints-1; ++i) {
          taui[i] = norm(points[i+1]-points[i]) * ratios[i];
          kappai[i+1] = kappai[i] + taui[i];
          accumulator += taui[i];
        }
        double scale = 2 / accumulator;
        for(size_t i = 0; i < nbPoints; ++i) {
          kappai[i] = scale * kappai[i] - 1;
        }

        // Interpolate
        for(size_t i = 1; i < nbPoints-1; ++i) {
          if(kappai[i] < refTarget[i]) {
            double f = (refTarget[i]-kappai[i]) / (refTarget[i+1]-refTarget[i]);
            refNew[i] = (1-f) * refForExtrusion[i] + f * refForExtrusion[i+1];
          }
          else {
            double f = (kappai[i]-refTarget[i]) / (refTarget[i]-refTarget[i-1]);
            refNew[i] = (1-f) * refForExtrusion[i] + f * refForExtrusion[i-1];
          }
          refNew[i] = .5 * refNew[i] + .5 * refForExtrusion[i];
        }

//
//std::cout << "uv{" << k << "} = [" << std::endl;
//for(size_t i = 0; i < nbPoints; ++i) {
//  std::cout << refForExtrusion[i] << " " << kappai[i] << std::endl;
//}
//std::cout << "];" << std::endl;

        // Update
        maxChanged = 0;
        for(size_t i = 1; i < nbPoints-1; ++i) {
          double diff = std::abs(refNew[i]-refForExtrusion[i]);
          maxChanged = std::max(maxChanged, diff);
          refForExtrusion[i] = refNew[i];
          //std::cout << refForExtrusion[i] << " ";
        }
      }
//      std::cout << k << std::endl;

//int N = 101;
//std::cout << "X = [" << std::endl;
//for(int i = 0; i < N; ++i) {
//  double u = -1 + 2 * (double)i/(N-1);
//  SPoint3 P = baseEdge->pnt(u);
//  std::cout << P.x() << " " << P.y() << " ";
//  frame.computeFrame(u, t, n, w);
//  P = P + thickness * n;
//  std::cout << P.x() << " " << P.y() << std::endl;
//}
//std::cout << "];" << std::endl;


    }

    // FIXME rename sampleIdealCurve?
    void _idealPositionEdge(Parameters params, const MEdgeN *baseEdge, const _Frame &frame,
                            double coeffs[2][3], int nbPoints,
                            const IntPt *points, fullMatrix<double> &xyz)
    {
      // Gauss points + the two extremities
      std::vector<double> refTarget(nbPoints+2);
      refTarget[0] = -1;
      refTarget[nbPoints+1] = 1;
      for(int i = 0; i < nbPoints; ++i) {
        refTarget[i+1] = points[i].pt[0];
      }

      std::vector<double> refPnts(nbPoints+2);
      if (params.activateALP)
        _refPntsForALPShiftedCurve(baseEdge, frame, coeffs, refTarget, refPnts, params.interpolationType);
      else {
        for(size_t i = 0; i < nbPoints+2; ++i) {
          // std::cout << refTarget[i] << " " << refPnts[i] << std:: endl;
          refPnts[i] = refTarget[i];
        }
        // std::cout << std::endl;
      }

      double angle1 = atan2(coeffs[0][1], coeffs[0][0]);
      double angle2 = atan2(coeffs[1][1], coeffs[1][0]);

      for(int i = 0; i < nbPoints; ++i) {
        double u = refPnts[i+1];
        SPoint3 p = baseEdge->pnt(u);
        SVector3 t, n, w;
        frame.computeFrame(u, t, n, w, false, params.interpolationType);

//        //        draw3DFrame(p, t, n, w, .0002);
//        SPoint3 pp = frame.pnt(u);
//        draw3DFrame(pp, t, n, w, .005);

        SVector3 h;
        // TODO: choose in function of expansion/reduction
        //       (Interpolation angulaire si ouverture, linaire si fermeture)
        if (params.useAngularInterp) {
          // TODO: this is for a plane only, adapt the code for 3d!
          double angle = angle1 * (1 - u) / 2 + angle2 * (1 + u) / 2;
          double dist1 = norm3(coeffs[0]);
          double dist2 = norm3(coeffs[1]);
          double dist = dist1 * (1 - u) / 2 + dist2 * (1 + u) / 2;
          h = dist * (std::cos(angle) * n + std::sin(angle) * t);
        }
        else {
          double interpolatedCoeffs[3];
          for(int j = 0; j < 3; ++j) {
            interpolatedCoeffs[j] =
              coeffs[0][j] * (1 - u) / 2 + coeffs[1][j] * (1 + u) / 2;
          }
          h = interpolatedCoeffs[0] * n + interpolatedCoeffs[1] * t +
              interpolatedCoeffs[2] * w;
        }

        xyz(i, 0) = p.x() + h.x();
        xyz(i, 1) = p.y() + h.y();
        xyz(i, 2) = p.z() + h.z();
      }
    }

    void _drawIdealPositionEdge(const MEdgeN *baseEdge, const _Frame &frame,
                                double coeffs[2][3], GEdge *gedge = nullptr,
                                int dev_interpType = -1)
    {
      if(!gedge) gedge = *GModel::current()->firstEdge();
      int N = 100;
      MVertex *previous = nullptr;

      for(int i = 0; i < N + 1; ++i) {
        const double u = (double)i / N * 2 - 1;
        SPoint3 p = baseEdge->pnt(u);
        SVector3 t, n, w;
        frame.computeFrame(u, t, n, w, false, dev_interpType);

        double interpolatedCoeffs[3];
        for(int j = 0; j < 3; ++j) {
          interpolatedCoeffs[j] =
            coeffs[0][j] * (1 - u) / 2 + coeffs[1][j] * (1 + u) / 2;
        }
        SVector3 h;
        h = interpolatedCoeffs[0] * n + interpolatedCoeffs[1] * t +
            interpolatedCoeffs[2] * w;
        double x = p.x() + h.x();
        double y = p.y() + h.y();
        double z = p.z() + h.z();

        MVertex *current = new MVertex(x, y, z, gedge);
        gedge->addMeshVertex(current);
        if(previous) {
          MLine *line = new MLine(previous, current);
          gedge->addLine(line);
        }
        //        MVertex *base = new MVertex(p.x(), p.y(), p.z(), gedge);
        //        MLine *line = new MLine(base, current);
        //        gedge->addLine(line);
        previous = current;
      }
    }

    void curveEdge(Parameters params, const MEdgeN *baseEdge, MEdgeN *edge, const GFace *gface,
                   const GEdge *gedge, const SVector3 &normal)
    {

      // _Frame frame(baseEdge, gface, gedge, normal); // original
      _Frame frame(baseEdge, gface, normal); // (dev) newIdea

      double coeffs[2][3];
      _computeParameters(baseEdge, edge, frame, coeffs, params.interpolationType);

      const int orderCurve = baseEdge->getPolynomialOrder();
      const int orderGauss = orderCurve * 2;
      const int sizeSystem = getNGQLPts(orderGauss);
      const IntPt *gaussPnts = getGQLPts(orderGauss);

      // Least square projection
      fullMatrix<double> xyz(sizeSystem + 2, 3);
      _idealPositionEdge(params, baseEdge, frame, coeffs, sizeSystem, gaussPnts, xyz);
      //      _drawIdealPositionEdge(baseEdge, frame, coeffs, (GEdge*)gedge);
      for(int i = 0; i < 2; ++i) {
        xyz(sizeSystem + i, 0) = edge->getVertex(i)->x();
        xyz(sizeSystem + i, 1) = edge->getVertex(i)->y();
        xyz(sizeSystem + i, 2) = edge->getVertex(i)->z();
      }

      LeastSquareData *data =
        getLeastSquareData(TYPE_LIN, orderCurve, orderGauss);
      fullMatrix<double> newxyz(orderCurve + 1, 3);
      data->invA.mult(xyz, newxyz);

      for(int i = 2; i < edge->getNumVertices(); ++i) {
        edge->getVertex(i)->x() = newxyz(i, 0);
        edge->getVertex(i)->y() = newxyz(i, 1);
        edge->getVertex(i)->z() = newxyz(i, 2);
      }

      if(gface) projectVerticesIntoGFace(edge, gface, false);
    }

    void _reduceCurving_newIdea(const fullMatrix<double> &xyz,
                                fullMatrix<double> &new_xyz, double coeff_tang)
    {
      fullMatrix<double> A(15, 7);
      fullMatrix<double> c(15, 3);

      A(0, 0) = -7.3459;
      A(0, 1) = 17.9843;
      A(0, 2) = -22.4737;
      A(0, 3) = 19.9746;
      A(0, 4) = -11.2352;
      A(0, 5) = 3.5951;
      A(0, 6) = -0.49932;
      A(1, 0) = -3.0189;
      A(1, 1) = 2.4697;
      A(1, 2) = 1.7465;
      A(1, 3) = -2.1449;
      A(1, 4) = 1.3297;
      A(1, 5) = -0.44567;
      A(1, 6) = 0.063588;
      A(2, 0) = 0.068021;
      A(2, 1) = -3.4377;
      A(2, 2) = 3.7162;
      A(2, 3) = -0.38885;
      A(2, 4) = 0.037655;
      A(2, 5) = 0.0068591;
      A(2, 6) = -0.002186;
      A(3, 0) = -0.013929;
      A(3, 1) = 0.19409;
      A(3, 2) = -3.5155;
      A(3, 3) = 3.5192;
      A(3, 4) = -0.19866;
      A(3, 5) = 0.014904;
      A(3, 6) = -0.00010118;
      A(4, 0) = 0.00010118;
      A(4, 1) = -0.014904;
      A(4, 2) = 0.19866;
      A(4, 3) = -3.5192;
      A(4, 4) = 3.5155;
      A(4, 5) = -0.19409;
      A(4, 6) = 0.013929;
      A(5, 0) = 0.002186;
      A(5, 1) = -0.0068591;
      A(5, 2) = -0.037655;
      A(5, 3) = 0.38885;
      A(5, 4) = -3.7162;
      A(5, 5) = 3.4377;
      A(5, 6) = -0.068021;
      A(6, 0) = -0.063588;
      A(6, 1) = 0.44567;
      A(6, 2) = -1.3297;
      A(6, 3) = 2.1449;
      A(6, 4) = -1.7465;
      A(6, 5) = -2.4697;
      A(6, 6) = 3.0189;
      A(7, 0) = 0.49932;
      A(7, 1) = -3.5951;
      A(7, 2) = 11.2352;
      A(7, 3) = -19.9746;
      A(7, 4) = 22.4737;
      A(7, 5) = -17.9843;
      A(7, 6) = 7.3459;

//      c(0, 0) =  (+ -12 * xyz(0, 0) + 21 * xyz(1, 0) + -12 * xyz(2, 0) + 3 * xyz(3, 0))/2;
//      c(0, 1) =  (+ -12 * xyz(0, 1) + 21 * xyz(1, 1) + -12 * xyz(2, 1) + 3 * xyz(3, 1))/2;
//      c(0, 2) =  (+ -12 * xyz(0, 2) + 21 * xyz(1, 2) + -12 * xyz(2, 2) + 3 * xyz(3, 2))/2;
//      c(7, 0) =  (+ -3 * xyz(3, 0) + 12 * xyz(4, 0) + -21 * xyz(5, 0) + 12 * xyz(6, 0))/2;
//      c(7, 1) =  (+ -3 * xyz(3, 1) + 12 * xyz(4, 1) + -21 * xyz(5, 1) + 12 * xyz(6, 1))/2;
//      c(7, 2) =  (+ -3 * xyz(3, 2) + 12 * xyz(4, 2) + -21 * xyz(5, 2) + 12 * xyz(6, 2))/2;
//      c(1, 0) =  (+ -6.408 * xyz(0, 0) + 6.816 * xyz(1, 0) + -0.408 * xyz(2, 0))/2;
//      c(1, 1) =  (+ -6.408 * xyz(0, 1) + 6.816 * xyz(1, 1) + -0.408 * xyz(2, 1))/2;
//      c(1, 2) =  (+ -6.408 * xyz(0, 2) + 6.816 * xyz(1, 2) + -0.408 * xyz(2, 2))/2;
//      c(6, 0) =  (+ 0.408 * xyz(4, 0) + -6.816 * xyz(5, 0) + 6.408 * xyz(6, 0))/2;
//      c(6, 1) =  (+ 0.408 * xyz(4, 1) + -6.816 * xyz(5, 1) + 6.408 * xyz(6, 1))/2;
//      c(6, 2) =  (+ 0.408 * xyz(4, 2) + -6.816 * xyz(5, 2) + 6.408 * xyz(6, 2))/2;
//      c(2, 0) =  + 0.068021 * xyz(0, 0) + -3.4377 * xyz(1, 0) + 3.7162 * xyz(2, 0) + -0.38885 * xyz(3, 0) + 0.037655 * xyz(4, 0) + 0.0068591 * xyz(5, 0) + -0.002186 * xyz(6, 0);
//      c(2, 1) =  + 0.068021 * xyz(0, 1) + -3.4377 * xyz(1, 1) + 3.7162 * xyz(2, 1) + -0.38885 * xyz(3, 1) + 0.037655 * xyz(4, 1) + 0.0068591 * xyz(5, 1) + -0.002186 * xyz(6, 1);
//      c(2, 2) =  + 0.068021 * xyz(0, 2) + -3.4377 * xyz(1, 2) + 3.7162 * xyz(2, 2) + -0.38885 * xyz(3, 2) + 0.037655 * xyz(4, 2) + 0.0068591 * xyz(5, 2) + -0.002186 * xyz(6, 2);
//      c(3, 0) =  + -0.013929 * xyz(0, 0) + 0.19409 * xyz(1, 0) + -3.5155 * xyz(2, 0) + 3.5192 * xyz(3, 0) + -0.19866 * xyz(4, 0) + 0.014904 * xyz(5, 0) + -0.00010118 * xyz(6, 0);
//      c(3, 1) =  + -0.013929 * xyz(0, 1) + 0.19409 * xyz(1, 1) + -3.5155 * xyz(2, 1) + 3.5192 * xyz(3, 1) + -0.19866 * xyz(4, 1) + 0.014904 * xyz(5, 1) + -0.00010118 * xyz(6, 1);
//      c(3, 2) =  + -0.013929 * xyz(0, 2) + 0.19409 * xyz(1, 2) + -3.5155 * xyz(2, 2) + 3.5192 * xyz(3, 2) + -0.19866 * xyz(4, 2) + 0.014904 * xyz(5, 2) + -0.00010118 * xyz(6, 2);
//      c(4, 0) =  + 0.00010118 * xyz(0, 0) + -0.014904 * xyz(1, 0) + 0.19866 * xyz(2, 0) + -3.5192 * xyz(3, 0) + 3.5155 * xyz(4, 0) + -0.19409 * xyz(5, 0) + 0.013929 * xyz(6, 0);
//      c(4, 1) =  + 0.00010118 * xyz(0, 1) + -0.014904 * xyz(1, 1) + 0.19866 * xyz(2, 1) + -3.5192 * xyz(3, 1) + 3.5155 * xyz(4, 1) + -0.19409 * xyz(5, 1) + 0.013929 * xyz(6, 1);
//      c(4, 2) =  + 0.00010118 * xyz(0, 2) + -0.014904 * xyz(1, 2) + 0.19866 * xyz(2, 2) + -3.5192 * xyz(3, 2) + 3.5155 * xyz(4, 2) + -0.19409 * xyz(5, 2) + 0.013929 * xyz(6, 2);
//      c(5, 0) =  + 0.002186 * xyz(0, 0) + -0.0068591 * xyz(1, 0) + -0.037655 * xyz(2, 0) + 0.38885 * xyz(3, 0) + -3.7162 * xyz(4, 0) + 3.4377 * xyz(5, 0) + -0.068021 * xyz(6, 0);
//      c(5, 1) =  + 0.002186 * xyz(0, 1) + -0.0068591 * xyz(1, 1) + -0.037655 * xyz(2, 1) + 0.38885 * xyz(3, 1) + -3.7162 * xyz(4, 1) + 3.4377 * xyz(5, 1) + -0.068021 * xyz(6, 1);
//      c(5, 2) =  + 0.002186 * xyz(0, 2) + -0.0068591 * xyz(1, 2) + -0.037655 * xyz(2, 2) + 0.38885 * xyz(3, 2) + -3.7162 * xyz(4, 2) + 3.4377 * xyz(5, 2) + -0.068021 * xyz(6, 2);

//      c(0, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(0, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(0, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(1, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(1, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(1, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(2, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(2, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(2, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(3, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(3, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(3, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(4, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(4, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(4, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(5, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(5, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(5, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(6, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(6, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(6, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;
//      c(7, 0) =  (-1 * xyz(0, 0) + 1 * xyz(6, 0))/2;
//      c(7, 1) =  (-1 * xyz(0, 1) + 1 * xyz(6, 1))/2;
//      c(7, 2) =  (-1 * xyz(0, 2) + 1 * xyz(6, 2))/2;

      SVector3 tangents[8];
      double norms[8];
      double normsSorted[8];
      tangents[0](0) = ( + -9 * xyz(0, 0) + 12 * xyz(1, 0) + -3 * xyz(2, 0))/2;
      tangents[0](1) = ( + -9 * xyz(0, 1) + 12 * xyz(1, 1) + -3 * xyz(2, 1))/2;
      tangents[0](2) = ( + -9 * xyz(0, 2) + 12 * xyz(1, 2) + -3 * xyz(2, 2))/2;
      tangents[1](0) = ( + -6.4257 * xyz(0, 0) + 6.8515 * xyz(1, 0) + -0.42574 * xyz(2, 0))/2;
      tangents[1](1) = ( + -6.4257 * xyz(0, 1) + 6.8515 * xyz(1, 1) + -0.42574 * xyz(2, 1))/2;
      tangents[1](2) = ( + -6.4257 * xyz(0, 2) + 6.8515 * xyz(1, 2) + -0.42574 * xyz(2, 2))/2;
      tangents[2](0) = ( + -0.37714 * xyz(0, 0) + -5.2457 * xyz(1, 0) + 5.6229 * xyz(2, 0))/2;
      tangents[2](1) = ( + -0.37714 * xyz(0, 1) + -5.2457 * xyz(1, 1) + 5.6229 * xyz(2, 1))/2;
      tangents[2](2) = ( + -0.37714 * xyz(0, 2) + -5.2457 * xyz(1, 2) + 5.6229 * xyz(2, 2))/2;
      tangents[3](0) = ( + -0.0045005 * xyz(1, 0) + -5.991 * xyz(2, 0) + 5.9955 * xyz(3, 0))/2;
      tangents[3](1) = ( + -0.0045005 * xyz(1, 1) + -5.991 * xyz(2, 1) + 5.9955 * xyz(3, 1))/2;
      tangents[3](2) = ( + -0.0045005 * xyz(1, 2) + -5.991 * xyz(2, 2) + 5.9955 * xyz(3, 2))/2;
      tangents[4](0) = ( + -5.9955 * xyz(3, 0) + 5.991 * xyz(4, 0) + 0.0045005 * xyz(5, 0))/2;
      tangents[4](1) = ( + -5.9955 * xyz(3, 1) + 5.991 * xyz(4, 1) + 0.0045005 * xyz(5, 1))/2;
      tangents[4](2) = ( + -5.9955 * xyz(3, 2) + 5.991 * xyz(4, 2) + 0.0045005 * xyz(5, 2))/2;
      tangents[5](0) = ( + -5.6229 * xyz(4, 0) + 5.2457 * xyz(5, 0) + 0.37714 * xyz(6, 0))/2;
      tangents[5](1) = ( + -5.6229 * xyz(4, 1) + 5.2457 * xyz(5, 1) + 0.37714 * xyz(6, 1))/2;
      tangents[5](2) = ( + -5.6229 * xyz(4, 2) + 5.2457 * xyz(5, 2) + 0.37714 * xyz(6, 2))/2;
      tangents[6](0) = ( + 0.42574 * xyz(4, 0) + -6.8515 * xyz(5, 0) + 6.4257 * xyz(6, 0))/2;
      tangents[6](1) = ( + 0.42574 * xyz(4, 1) + -6.8515 * xyz(5, 1) + 6.4257 * xyz(6, 1))/2;
      tangents[6](2) = ( + 0.42574 * xyz(4, 2) + -6.8515 * xyz(5, 2) + 6.4257 * xyz(6, 2))/2;
      tangents[7](0) = ( + 3 * xyz(4, 0) + -12 * xyz(5, 0) + 9 * xyz(6, 0))/2;
      tangents[7](1) = ( + 3 * xyz(4, 1) + -12 * xyz(5, 1) + 9 * xyz(6, 1))/2;
      tangents[7](2) = ( + 3 * xyz(4, 2) + -12 * xyz(5, 2) + 9 * xyz(6, 2))/2;
      for (int i = 0; i < 8; ++i) {
        norms[i] = tangents[i].norm();
        normsSorted[i] = norms[i];
      }
      std::sort(&(normsSorted[0]), &(normsSorted[8]));
      double myNorm = .9*.5 * (normsSorted[3] + normsSorted[4]);
      for (int i = 0; i < 8; ++i) {
//        std::cout << norms[i] << " ";
        tangents[i](0) = tangents[i](0) / norms[i] * myNorm;
        tangents[i](1) = tangents[i](1) / norms[i] * myNorm;
        tangents[i](2) = tangents[i](2) / norms[i] * myNorm;
      }
      for (int i = 0; i < 8; ++i) {
                c(i, 0) = tangents[i](0);
                c(i, 1) = tangents[i](1);
                c(i, 2) = tangents[i](2);
      }

//      std::cout << " => " << norms[7] << "-" << norms[0] << " = " << norms[7] - norms[0];
//      std::cout << "  tang0 (" << tangents[0](0) << ", " << tangents[0](1) << ", " << tangents[0](2) << ")";
//      std::cout << "  tang7 (" << tangents[7](0) << ", " << tangents[7](1) << ", " << tangents[7](2) << ")";
//      std::cout << std::endl;



      for (int i = 0; i < 8; ++i) {
        c(i, 0) -= A(i, 0) * xyz(0, 0);
        c(i, 1) -= A(i, 0) * xyz(0, 1);
        c(i, 2) -= A(i, 0) * xyz(0, 2);
        A(i, 0) = 0;
        c(i, 0) -= A(i, 6) * xyz(6, 0);
        c(i, 1) -= A(i, 6) * xyz(6, 1);
        c(i, 2) -= A(i, 6) * xyz(6, 2);
        A(i, 6) = 0;
      }

      A.scale(coeff_tang);
      c.scale(coeff_tang);

//      A(8, 0) = 1;
//      c(8, 0) = xyz(0, 0);
//      c(8, 1) = xyz(0, 1);
//      c(8, 2) = xyz(0, 2);
//      A(9, 6) = 1;
//      c(9, 0) = xyz(6, 0);
//      c(9, 1) = xyz(6, 1);
//      c(9, 2) = xyz(6, 2);

      for (int i = 0; i < 7; ++i) {
        A(8+i, i) = 1;
        c(8+i, 0) = xyz(i, 0);
        c(8+i, 1) = xyz(i, 1);
        c(8+i, 2) = xyz(i, 2);
      }

      fullMatrix<double> B = A.transpose();
      fullMatrix<double> C(7, 7);
      fullMatrix<double> d(7, 3);
      //fullMatrix<double> x(7, 3);
      B.mult(A, C);
      B.mult(c, d);
      C.invertInPlace();
      new_xyz.resize(7, 3);
      C.mult(d, new_xyz);



      // extremity (from bspln3 : -12 21 -12 3)
      // at .0715 (from bspln2 : -6.408	6.816	-0.408)
      // at .2395 .4165 from curve
    }

    void _reduceCurving_newIdea(MEdgeN *edge, double max_diff, const GFace *gface)
    {
      int order = edge->getPolynomialOrder();

      if (order != 6) {
        Msg::Error("_reduceCurving_newIdea not implemented for order not 6");
        return;
      }

      fullMatrix<double> xyz(order + 1, 3);
      fullMatrix<double> new_xyz;

      MVertex *v0 = edge->getVertex(0);
      MVertex *v1 = edge->getVertex(1);
      xyz(0, 0) = v0->x();
      xyz(0, 1) = v0->y();
      xyz(0, 2) = v0->z();
      xyz(order, 0) = v1->x();
      xyz(order, 1) = v1->y();
      xyz(order, 2) = v1->z();

      for (int i = 2; i < order + 1; ++i) {
        MVertex *v = edge->getVertex(i);
        xyz(i - 1, 0) = v->x();
        xyz(i - 1, 1) = v->y();
        xyz(i - 1, 2) = v->z();
        //std::cout << " (" << xyz(i-2, 0) << "," << xyz(i-2, 1) << "," << xyz(i-2, 2) << ")  ";
      }
      //std::cout << "(max=" << max_diff << ")" << std::endl;

      double coeff = 1;
      double diff = 2 * max_diff;

      int k = 1;
      while (diff > max_diff || diff < .9 * max_diff) {
        _reduceCurving_newIdea(xyz, new_xyz, coeff);
        double thisMaxDiff = 0;
        for (int i = 0; i < order + 1; ++i) {
          double dx = xyz(i, 0) - new_xyz(i, 0);
          double dy = xyz(i, 1) - new_xyz(i, 1);
          double dz = xyz(i, 2) - new_xyz(i, 2);
          double diff = std::sqrt(dx*dx + dy*dy + dz*dz);
          thisMaxDiff = std::max(thisMaxDiff, diff);
          //std::cout << diff << " (" << xyz(i, 0) << "," << xyz(i, 1) << "," << xyz(i, 2) << ")-(" << new_xyz(i, 0) << "," << new_xyz(i, 1) << "," << new_xyz(i, 2) << ")  ";
        }
        //std::cout << "(max=" << max_diff << ")" << std::endl;
//        std::cout << coeff << ": " << thisMaxDiff << "/" << max_diff << std::endl;
        coeff = coeff / thisMaxDiff * max_diff * .95;
        if (++k == 40) break;
        diff = thisMaxDiff;
      }

      for (int i = 0; i < order + 1; ++i) {
        double dx = xyz(i, 0) - new_xyz(i, 0);
        double dy = xyz(i, 1) - new_xyz(i, 1);
        double dz = xyz(i, 2) - new_xyz(i, 2);
        double diff = std::sqrt(dx*dx + dy*dy + dz*dz);
//        std::cout << diff << " (" << xyz(i, 0) << "," << xyz(i, 1) << "," << xyz(i, 2) << ")-(" << new_xyz(i, 0) << "," << new_xyz(i, 1) << "," << new_xyz(i, 2) << ")  ";
      }
//      std::cout << "(max=" << max_diff << ")" << std::endl;

      v0->x() = new_xyz(0, 0);
      v0->y() = new_xyz(0, 1);
      v0->z() = new_xyz(0, 2);
      v1->x() = new_xyz(order, 0);
      v1->y() = new_xyz(order, 1);
      v1->z() = new_xyz(order, 2);

      for (int i = 2; i < order + 1; ++i) {
        MVertex *v = edge->getVertex(i);
        v->x() = new_xyz(i - 1, 0);
        v->y() = new_xyz(i - 1, 1);
        v->z() = new_xyz(i - 1, 2);
      }

      // 1) Create matrix to assemble
      // 2) Add equation tangent
      // 3) Fix extremity nodes
      // 4) solve
      // 5) iterate
      if(gface) projectVerticesIntoGFace(edge, gface, false);
    }

    void _construct_matrices(const fullMatrix<double> &xyz_gmsh,
      const fullMatrix<double> &xyz_seq,
      const SVector3 dir_extremities[2],
      fullMatrix<double> &A_lin, fullMatrix<double> &b_lin,
      fullMatrix<double> &A_pos, fullMatrix<double> &b_pos,
      fullMatrix<double> &A_ext, fullMatrix<double> &b_ext,
      fullMatrix<double> &A_tg1, fullMatrix<double> &b_tg1,
      fullMatrix<double> &A_tg2, fullMatrix<double> &b_tg2)
    {
      int polyo = xyz_gmsh.size1() - 1;

      fullMatrix<double> bspl_tg(2*polyo - 1, 3);
      for(int i = 0; i < 2*polyo - 1; ++i) {
        if (i % 2 == 0) {
          int ii = i / 2;
          for (int j = 0; j < 3; ++j) {
            bspl_tg(i, j) = xyz_seq(ii + 1, j) - xyz_seq(ii, j);
          }
        }
        else {
          int ii = (i-1) / 2;
          for (int j = 0; j < 3; ++j) {
            bspl_tg(i, j) = .5 * (xyz_seq(ii + 2, j) - xyz_seq(ii, j));
          }
        }
      }
      bspl_tg.scale(polyo/2);
      fullVector<double> bspl_tg_length(2*polyo - 1);
      for(int i = 0; i < 2*polyo - 1; ++i) {
        SVector3 v(bspl_tg(i, 0), bspl_tg(i, 1), bspl_tg(i, 2));
        bspl_tg_length(i) = v.norm();
      }

      const int tagLine = ElementType::getType(TYPE_LIN, polyo);
      const nodalBasis *nb = BasisFactory::getNodalBasis(tagLine);
      const fullMatrix<double> &refNodes_gmsh = nb->getReferenceNodes();
      // refNodes_gmsh.print(std::string("refNodes_gmsh"), std::string(""));
      int nbDof = refNodes_gmsh.size1();
      fullMatrix<double> refNodes_seq(polyo + 1, 1);
      refNodes_seq(0, 0) = refNodes_gmsh(0, 0);
      // refNodes_seq(0, 1) = refNodes_gmsh(0, 1);
      // refNodes_seq(0, 2) = refNodes_gmsh(0, 2);
      for(int i = 1; i < polyo; ++i) {
        refNodes_seq(i, 0) = refNodes_gmsh(i+1, 0);
        // refNodes_seq(i, 1) = refNodes_gmsh(i+1, 1);
        // refNodes_seq(i, 2) = refNodes_gmsh(i+1, 2);
      }
      refNodes_seq(polyo, 0) = refNodes_gmsh(1, 0);
      // refNodes_seq(polyo, 1) = refNodes_gmsh(1, 1);
      // refNodes_seq(polyo, 2) = refNodes_gmsh(1, 2);

      // 1) Construct Position linear system
      A_pos = fullMatrix<double>(polyo - 1, polyo + 1);
      b_pos = fullMatrix<double>(polyo - 1, 3);
      for(int i = 2; i < polyo + 1; ++i) {
        int I = i - 2;
        A_pos(I, i) = 1;
        for(int j = 0; j < 3; ++j) { b_pos(I, j) = xyz_gmsh(i, j); }
      }
      // A_pos.print(std::string("A_pos:"),std::string(""));
      // b_pos.print(std::string("b_pos:"),std::string(""));

      // 2) Construct Tangent linear system
      const double amplification = 1.; // Hack
      A_tg1 = fullMatrix<double>(polyo, polyo + 1);
      b_tg1 = fullMatrix<double>(polyo, 3);
      for(int i = 0; i < polyo; ++i) {
        int I = i;
        double u = .5 * (refNodes_seq(i, 0) + refNodes_seq(i+1, 0));
        // std::cout << "u = " << u << std::endl;
        // double sf[100];
        double grads[100][3];
        nb->df(u, 0, 0, grads);
        for(int j = 0; j < nbDof; ++j) { A_tg1(I, j) = grads[j][0]; }
        // for(int j = 0; j < 3; ++j) { b_tg(I, j) = xyz(i+1, j) - xyz(i, j); }
        for(int j = 0; j < 3; ++j) { b_tg1(I, j) = bspl_tg(i*2, j); }
      }

      A_tg2 = fullMatrix<double>(polyo - 1, polyo + 1);
      b_tg2 = fullMatrix<double>(polyo - 1, 3);
      for(int i = 1; i < polyo; ++i) {
        int I = i - 1;
        double u = refNodes_seq(i, 0);
        // std::cout << "_u = " << u << std::endl;
        // double sf[100];
        // nb->f(u, 0, 0, sf);
        // for(int j = 0; j < nbDof; ++j) { A_tg(I, j) = sf[j]; }
        double grads[100][3];
        nb->df(u, 0, 0, grads);
        for(int j = 0; j < nbDof; ++j) { A_tg2(I, j) = grads[j][0]; }
        // for(int j = 0; j < 3; ++j) {
        //   b_tg(I, j) = .5 * (xyz(i+1, j) - xyz(i-1, j));
        // }
        for(int j = 0; j < 3; ++j) { b_tg2(I, j) = bspl_tg(i*2-1, j); }
      }

      b_tg1.scale(amplification);
      b_tg2.scale(amplification);
      // A_tg1.print(std::string("A_tg1:"),std::string(""));
      // b_tg1.print(std::string("b_tg1:"),std::string(""));
      // A_tg2.print(std::string("A_tg2:"),std::string(""));
      // b_tg2.print(std::string("b_tg2:"),std::string(""));

      // 3) Construct Extremity tangent linear system
      A_ext = fullMatrix<double>(2, polyo + 1);
      b_ext = fullMatrix<double>(2, 3);

      double desired_lengths[2] = {2*bspl_tg_length(0) - bspl_tg_length(1),
        2*bspl_tg_length(2*polyo-2) - bspl_tg_length(2*polyo-3)};
      // bspl_tg_length.print(std::string("bspl_tg_length:"),std::string(""));

      for(int i = 0; i < 2; ++i) {
        // double sf[100];
        double grads[100][3];
        nb->df(i ? 1 : -1, 0, 0, grads);
        for(int j = 0; j < nbDof; ++j) { A_ext(i, j) = grads[j][0]; } // TODO check
        for(int j = 0; j < 3; ++j) { b_ext(i, j) = desired_lengths[i] * dir_extremities[i](j); }
      }
      b_ext.scale(amplification);
      // A_ext.print(std::string("A_ext:"),std::string(""));
      // b_ext.print(std::string("b_ext:"),std::string(""));

      // 4) Construct Linear tangent linear system
      fullMatrix<double> A_lin_tg(polyo, polyo + 1);
      fullMatrix<double> b_lin_tg(polyo, 3);
      double vx = xyz_gmsh(1, 0) - xyz_gmsh(0, 0);
      double vy = xyz_gmsh(1, 1) - xyz_gmsh(0, 1);
      double vz = xyz_gmsh(1, 2) - xyz_gmsh(0, 2);
      SVector3 t(vx, vy, vz);
      t *= .5;
      for(int i = 0; i < polyo; ++i) {
        for(int j = 0; j < polyo+1; ++j) { A_lin_tg(i, j) = A_tg1(i, j); }
        for(int j = 0; j < 3; ++j) { b_lin_tg(i, j) = t(j); }
      }

      fullMatrix<double> A_lin_pos = A_pos;
      fullMatrix<double> b_lin_pos(polyo - 1, 3);
      // SPoint3 x_0(xyz_gmsh(0, 0), xyz_gmsh(0, 1), xyz_gmsh(0, 2));
      t *= 2;
      for(int i = 0; i < polyo - 1; ++i) {
        for(int j = 0; j < 3; ++j) { b_lin_pos(i, j) = xyz_gmsh(0, j) + (i+1.) / polyo * t(j); }
      }

      // A_lin = A_lin_tg;
      // b_lin = b_lin_tg;
      A_lin = A_lin_pos;
      b_lin = b_lin_pos;
      // A_lin = fullMatrix<double>(2 * polyo - 1, polyo + 1);
      // b_lin = fullMatrix<double>(2 * polyo - 1, 3);
      // A_lin.copy(A_lin_tg, 0, polyo, 0, polyo + 1, 0, 0);
      // b_lin.copy(b_lin_tg, 0, polyo, 0,         3, 0, 0);
      // A_lin.copy(A_lin_pos, 0, polyo - 1, 0, polyo + 1, polyo, 0);
      // b_lin.copy(b_lin_pos, 0, polyo - 1, 0,         3, polyo, 0);
      // A_lin.print(std::string("A_lin:"),std::string(""));
      // b_lin.print(std::string("b_lin:"),std::string(""));
      // bspl_tg_length.print(std::string("bspl_tg_length:"),std::string(""));
      // bspl_tg.print(std::string("bspl_tg:"),std::string(""));
    }

    void _construct_test_system(
      const fullMatrix<double> &A_lin, const fullMatrix<double> &b_lin,
      const fullMatrix<double> &A_pos, const fullMatrix<double> &b_pos,
      const fullMatrix<double> &A_ext, const fullMatrix<double> &b_ext,
      const fullMatrix<double> &A_tg1, const fullMatrix<double> &b_tg1,
      const fullMatrix<double> &A_tg2, const fullMatrix<double> &b_tg2,
      fullMatrix<double> &A, fullMatrix<double> &b)
    {
      // Choose
      int sz_lin = A_lin.size1();
      int sz_ext = A_ext.size1();
      int sz_pos = A_pos.size1();
      int sz_tg1 = A_tg1.size1();
      int sz_tg2 = A_tg2.size1();

      double coeff_lin = .0000001;
      double coeff_pos = .00000001;
      double coeff_ext = .00000001;
      // Between those two, none is stable alone, but they seems stable together.
      // This observation may be dependent on the way edges are curved, in
      // particular the preservation of arc-length nature of edges (see ALP)
      double coeff_tg1 = 1000;
      double coeff_tg2 = 1000;

      int SZ = sz_lin + sz_pos + sz_ext + sz_tg1 + sz_tg2;
      int polyo = A_lin.size2() - 1;
      A = fullMatrix<double>(SZ, polyo+1);
      b = fullMatrix<double>(SZ, 3);

      int desti0 = 0;
      fullMatrix<double> tmp;
      tmp = A_lin; tmp.scale(coeff_lin);
      A.copy(tmp, 0, sz_lin, 0, polyo+1, desti0, 0); desti0 += sz_lin;
      tmp = A_pos; tmp.scale(coeff_pos);
      A.copy(tmp, 0, sz_pos, 0, polyo+1, desti0, 0); desti0 += sz_pos;
      tmp = A_ext; tmp.scale(coeff_ext);
      A.copy(tmp, 0, sz_ext, 0, polyo+1, desti0, 0); desti0 += sz_ext;
      tmp = A_tg1; tmp.scale(coeff_tg1);
      A.copy(tmp, 0, sz_tg1, 0, polyo+1, desti0, 0); desti0 += sz_tg1;
      tmp = A_tg2; tmp.scale(coeff_tg2);
      A.copy(tmp, 0, sz_tg2, 0, polyo+1, desti0, 0); desti0 += sz_tg2;

      desti0 = 0;
      tmp = b_lin; tmp.scale(coeff_lin);
      b.copy(tmp, 0, sz_lin, 0, 3, desti0, 0); desti0 += sz_lin;
      tmp = b_pos; tmp.scale(coeff_pos);
      b.copy(tmp, 0, sz_pos, 0, 3, desti0, 0); desti0 += sz_pos;
      tmp = b_ext; tmp.scale(coeff_ext);
      b.copy(tmp, 0, sz_ext, 0, 3, desti0, 0); desti0 += sz_ext;
      tmp = b_tg1; tmp.scale(coeff_tg1);
      b.copy(tmp, 0, sz_tg1, 0, 3, desti0, 0); desti0 += sz_tg1;
      tmp = b_tg2; tmp.scale(coeff_tg2);
      b.copy(tmp, 0, sz_tg2, 0, 3, desti0, 0); desti0 += sz_tg2;
    }

    void _construct_system(double kappa, double f_0, double f_s, double f_l,
      const fullMatrix<double> &A_lin, const fullMatrix<double> &b_lin,
      const fullMatrix<double> &A_pos, const fullMatrix<double> &b_pos,
      const fullMatrix<double> &A_ext, const fullMatrix<double> &b_ext,
      const fullMatrix<double> &A_tg1, const fullMatrix<double> &b_tg1,
      const fullMatrix<double> &A_tg2, const fullMatrix<double> &b_tg2,
      fullMatrix<double> &A, fullMatrix<double> &b)
    {
      // Choose
      int sz_lin = A_lin.size1();
      int sz_ext = A_ext.size1();
      int sz_pos = A_pos.size1();
      int sz_tg1 = A_tg1.size1();
      int sz_tg2 = A_tg2.size1();

      double coeff_lin = f_l;
      double coeff_pos = f_0;
      double coeff_ext = kappa * f_s;
      // Between those two, none is stable alone, but they seems stable together.
      // This observation may be dependent on the way edges are curved, in
      // particular the preservation of arc-length nature of edges (see ALP)
      double coeff_tg1 = f_s;
      double coeff_tg2 = f_s;

      int SZ = sz_lin + sz_pos + sz_ext + sz_tg1 + sz_tg2;
      int polyo = A_lin.size2() - 1;
      A = fullMatrix<double>(SZ, polyo+1);
      b = fullMatrix<double>(SZ, 3);

      int desti0 = 0;
      fullMatrix<double> tmp;
      tmp = A_lin; tmp.scale(coeff_lin);
      A.copy(tmp, 0, sz_lin, 0, polyo+1, desti0, 0); desti0 += sz_lin;
      tmp = A_pos; tmp.scale(coeff_pos);
      A.copy(tmp, 0, sz_pos, 0, polyo+1, desti0, 0); desti0 += sz_pos;
      tmp = A_ext; tmp.scale(coeff_ext);
      A.copy(tmp, 0, sz_ext, 0, polyo+1, desti0, 0); desti0 += sz_ext;
      tmp = A_tg1; tmp.scale(coeff_tg1);
      A.copy(tmp, 0, sz_tg1, 0, polyo+1, desti0, 0); desti0 += sz_tg1;
      tmp = A_tg2; tmp.scale(coeff_tg2);
      A.copy(tmp, 0, sz_tg2, 0, polyo+1, desti0, 0); desti0 += sz_tg2;

      desti0 = 0;
      tmp = b_lin; tmp.scale(coeff_lin);
      b.copy(tmp, 0, sz_lin, 0, 3, desti0, 0); desti0 += sz_lin;
      tmp = b_pos; tmp.scale(coeff_pos);
      b.copy(tmp, 0, sz_pos, 0, 3, desti0, 0); desti0 += sz_pos;
      tmp = b_ext; tmp.scale(coeff_ext);
      b.copy(tmp, 0, sz_ext, 0, 3, desti0, 0); desti0 += sz_ext;
      tmp = b_tg1; tmp.scale(coeff_tg1);
      b.copy(tmp, 0, sz_tg1, 0, 3, desti0, 0); desti0 += sz_tg1;
      tmp = b_tg2; tmp.scale(coeff_tg2);
      b.copy(tmp, 0, sz_tg2, 0, 3, desti0, 0); desti0 += sz_tg2;
    }

    void _construct_system_lin(double coeff,
      const fullMatrix<double> &A_lin, const fullMatrix<double> &b_lin,
      const fullMatrix<double> &A_pos, const fullMatrix<double> &b_pos,
      fullMatrix<double> &A, fullMatrix<double> &b)
    {
      int sz_lin = A_lin.size1();
      int sz_pos = A_pos.size1();

      double coeff_lin = coeff;
      double coeff_pos = 1-coeff;

      int SZ = sz_lin + sz_pos;
      int polyo = A_lin.size2() - 1;
      A = fullMatrix<double>(SZ, polyo+1);
      b = fullMatrix<double>(SZ, 3);

      int desti0 = 0;
      fullMatrix<double> tmp;
      tmp = A_lin; tmp.scale(coeff_lin);
      A.copy(tmp, 0, sz_lin, 0, polyo+1, desti0, 0); desti0 += sz_lin;
      tmp = A_pos; tmp.scale(coeff_pos);
      A.copy(tmp, 0, sz_pos, 0, polyo+1, desti0, 0); desti0 += sz_pos;

      desti0 = 0;
      tmp = b_lin; tmp.scale(coeff_lin);
      b.copy(tmp, 0, sz_lin, 0, 3, desti0, 0); desti0 += sz_lin;
      tmp = b_pos; tmp.scale(coeff_pos);
      b.copy(tmp, 0, sz_pos, 0, 3, desti0, 0); desti0 += sz_pos;
    }

    void solve_system(const fullMatrix<double> &A, const fullMatrix<double> &b,
                      const fullMatrix<double> &xyz_gmsh,
                      fullMatrix<double> &new_xyz_HO, bool verbose = false)
    {
      fullMatrix<double> A_fixed_boundary = A;
      const fullMatrix<double> &b_fixed_boundary = b;
      if (verbose) {
        A_fixed_boundary.print(std::string("A_fixed_boundary"), std::string(""));
        b_fixed_boundary.print(std::string("b_fixed_boundary"), std::string(""));
      }

      // Fix extremities
      fullVector<double> proxA, proxb;

      proxA.setAsProxy(A_fixed_boundary, 0);
      for(int j = 0; j < 3; ++j) {
        proxb.setAsProxy(b_fixed_boundary, j);
        proxb.axpy(proxA, -xyz_gmsh(0, j));
      }
      if (verbose) {
        A_fixed_boundary.print(std::string("A_fixed_boundary"), std::string(""));
        b_fixed_boundary.print(std::string("b_fixed_boundary"), std::string(""));
      }

      proxA.setAsProxy(A_fixed_boundary, 1);
      for(int j = 0; j < 3; ++j) {
        proxb.setAsProxy(b_fixed_boundary, j);
        proxb.axpy(proxA, -xyz_gmsh(1, j));
      }
      if (verbose) {
        A_fixed_boundary.print(std::string("A_fixed_boundary"), std::string(""));
        b_fixed_boundary.print(std::string("b_fixed_boundary"), std::string(""));
      }

      fullMatrix<double> tmpA(A_fixed_boundary, 2, A_fixed_boundary.size2() - 2);
      fullMatrix<double> tmpA2 = tmpA;
      if (verbose) {
        tmpA.print(std::string("tmpA"), std::string(""));
        tmpA2.print(std::string("tmpA2"), std::string(""));
      }
      A_fixed_boundary = tmpA2;
      if (verbose) {
        A_fixed_boundary.print(std::string("A_fixed_boundary"), std::string(""));
        b_fixed_boundary.print(std::string("b_fixed_boundary"), std::string(""));
      }

      // TRANSPOSE

      // A_fixed_boundary.print(std::string("A_fb:"),std::string(""));
      // b_fixed_boundary.print(std::string("b_fb:"),std::string(""));

      // Transform into square linear system
      int sz = A_fixed_boundary.size2();
      fullMatrix<double> A_sq(sz, sz);
      fullMatrix<double> b_sq(sz, 3);
      fullMatrix<double> A_T = A_fixed_boundary.transpose();

      A_T.mult(A_fixed_boundary, A_sq);
      A_T.mult(b_fixed_boundary, b_sq);

      // A_sq.print(std::string("A_sq:"),std::string(""));
      // b_sq.print(std::string("b_sq:"),std::string(""));


      fullVector<double> y, c;
      // new_xyz_HO.print(std::string("new_xyz_HO:"),std::string(""));
      for(int j = 0; j < 3; ++j) {
        y.setAsProxy(new_xyz_HO, j);
        c.setAsProxy(b_sq, j);
        A_sq.luSolve(c, y);
        // A_sq.print(std::string("A_sq:"),std::string(""));
        // c.print(std::string("c:"),std::string(""));
        // y.print(std::string("y:"),std::string(""));
        // new_xyz_HO.print(std::string("new_xyz_HO:"),std::string(""));
      }

      // new_xyz_HO.print(std::string("new_xyz_HO:"),std::string(""));
      // xyz_gmsh.print(std::string("xyz_gmsh:"),std::string(""));
      // xyz_seq.print(std::string("xyz_seq:"),std::string(""));
    }

    double _one_iteration(double alpha, double gamma, double kappa,
      const fullMatrix<double> &xyz_gmsh,
      const fullMatrix<double> &A_lin, const fullMatrix<double> &b_lin,
      const fullMatrix<double> &A_pos, const fullMatrix<double> &b_pos,
      const fullMatrix<double> &A_ext, const fullMatrix<double> &b_ext,
      const fullMatrix<double> &A_tg1, const fullMatrix<double> &b_tg1,
      const fullMatrix<double> &A_tg2, const fullMatrix<double> &b_tg2,
      fullMatrix<double> &A, fullMatrix<double> &b,
      fullMatrix<double> &new_xyz)
    {
      double f_0 = 1 - alpha;
      double f_s = alpha * (1 - gamma * alpha);
      double f_l = gamma * alpha * alpha;

      // Construct the system
      _construct_system(kappa * (1 - gamma), f_0, f_s, f_l, A_lin, b_lin, A_pos, b_pos,
                             A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2, A, b);

      // Solve the system
      solve_system(A, b, xyz_gmsh, new_xyz);

      // Update max_displ
      int polyo = A_lin.size2() - 1;
      // prev_max_displ = max_displ;
      double max_displ = 0;

      for (int i = 0; i < polyo - 2; ++i) {
        double vx = xyz_gmsh(i+2, 0) - new_xyz(i, 0);
        double vy = xyz_gmsh(i+2, 1) - new_xyz(i, 1);
        double vz = xyz_gmsh(i+2, 2) - new_xyz(i, 2);
        double displ = sqrt(vx*vx + vy*vy + vz*vz);
        if (displ > max_displ) {
          max_displ = displ;
        }
      }
      return max_displ;
    }

    void _find_best_reduction(double max_displ_ub, double gamma, double kappa,
      const fullMatrix<double> &xyz_gmsh, const fullMatrix<double> &xyz_seq,
      const fullMatrix<double> &A_lin, const fullMatrix<double> &b_lin,
      const fullMatrix<double> &A_pos, const fullMatrix<double> &b_pos,
      const fullMatrix<double> &A_ext, const fullMatrix<double> &b_ext,
      const fullMatrix<double> &A_tg1, const fullMatrix<double> &b_tg1,
      const fullMatrix<double> &A_tg2, const fullMatrix<double> &b_tg2,
      fullMatrix<double> &new_xyz)
    {
      fullMatrix<double> A, b;

      // _construct_test_system(A_lin, b_lin, A_pos, b_pos, A_ext, b_ext,
      //   A_tg1, b_tg1, A_tg2, b_tg2, A, b);
      //
      // solve_system(A, b, xyz_gmsh, new_xyz);
      // return;

      // NOTE
      //  1. Choose alpha = .5 and gamma_target = .5
      //  2. Assemble matrix
      //  3. Solve
      //  4. Compute max_displacement
      //  5. Update alpha
      //  6. Loop

      // Define data storage for iterations
      std::vector<std::tuple<double, double, double, double, double>> iteration_data; // Stores (x_i, y_i, a_i, s_i, q_i)

      // Initial values for i = 0 and i = 1
      iteration_data.emplace_back(0, 0, std::numeric_limits<double>::quiet_NaN(), std::numeric_limits<double>::quiet_NaN(), std::numeric_limits<double>::quiet_NaN());
      double alpha = 1.;
      double max_displ = _one_iteration(alpha, gamma, kappa, xyz_gmsh, A_lin, b_lin, A_pos, b_pos, A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2, A, b, new_xyz);
      iteration_data.emplace_back(alpha, max_displ, alpha/2, max_displ, std::numeric_limits<double>::quiet_NaN());

      if(max_displ < .9 * max_displ_ub) return;

      double target = 0.95 * max_displ_ub; // Y = target
      double tol = 0.05 * max_displ_ub;
      double next_x_i = alpha / max_displ * target;

      int k = 1; // Start after initialization
      while (true) {
        ++k; // Increment iteration counter

        // Previous iteration data
        double prev_x = std::get<0>(iteration_data[k - 1]);
        double prev_y = std::get<1>(iteration_data[k - 1]);
        double prev_a = std::get<2>(iteration_data[k - 1]);
        double prev_s = std::get<3>(iteration_data[k - 1]);
        // double prev_q = std::get<4>(iteration_data[k - 1]);

        double x_i = next_x_i;
        double y_i = _one_iteration(x_i, gamma, kappa, xyz_gmsh, A_lin, b_lin, A_pos, b_pos, A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2, A, b, new_xyz);
        double a_i = (x_i + prev_x) / 2;                             // Midpoint of current and previous alpha
        double s_i = (y_i - prev_y) / (x_i - prev_x);          // Slope between current and previous values
        double q_i = (s_i - prev_s) / (a_i - prev_a);    // Slope change rate, with special handling for i=2
        // if(k > 2) q_i = (q_i + prev_q) / 2;
        iteration_data.emplace_back(x_i, y_i, a_i, s_i, q_i);

        // Quadratic coefficients
        double q_coef = q_i / 2;
        double lin_coef = s_i - q_i * a_i;
        double const_coef = prev_y - target - s_i * x_i - q_i * x_i * (x_i / 2 - a_i);

        // Solve the quadratic equation q_coef * X^2 + lin_coef * X + const_coef = 0
        double discriminant = lin_coef * lin_coef - 4 * q_coef * const_coef;
        if (discriminant >= 0) {
          // Take the root that satisfies the direction of progression
          double root1 = (-lin_coef + sqrt(discriminant)) / (2 * q_coef);
          double root2 = (-lin_coef - sqrt(discriminant)) / (2 * q_coef);
          // std::cout << "root1: " << root1 << ", root2: " << root2 << std::endl;
          next_x_i = root1;
          if(next_x_i <= 0) next_x_i = .5 * std::min(x_i, prev_x);
          else if(next_x_i >= 1) next_x_i = .5 + .5 * std::max(x_i, prev_x);
        }
        else {
          // In case the discriminant is negative (unlikely), fallback to halving alpha
          next_x_i = 0.5 * (x_i + prev_x);
        }
        next_x_i = .5 * (next_x_i + x_i); //FIXME Hack

        // Print iteration information
        // std::cout << "Iteration " << k << ": "
        //           << "x_i = " << x_i << ", y_i = " << y_i << ", y_i/target = " << y_i / target
        //           << ", a_i = " << a_i << ", s_i = " << s_i << ", q_i = " << q_i << std::endl;

        // Stopping condition
        if (std::abs(y_i - target) < tol) {
          break;
        }

        // Safety break to prevent infinite loops
        if (k > 1000) {
          std::cerr << "Iteration limit reached. Exiting loop to avoid infinite iterations." << std::endl;
          break;
        }
      }

      // std::cout << "k = " << k << " alpha = " << std::get<0>(iteration_data[k]) << std::endl;
    }

    void compute_xyz_gmsh_seq(const MEdgeN *edge, fullMatrix<double> &xyz_gmsh,
      fullMatrix<double> &xyz_seq)
    {
      int polyo = edge->getPolynomialOrder();
      xyz_gmsh = fullMatrix<double>(polyo + 1, 3);
      for (int i = 0; i < polyo + 1; ++i) {
        MVertex *v = edge->getVertex(i);
        xyz_gmsh(i, 0) = v->x();
        xyz_gmsh(i, 1) = v->y();
        xyz_gmsh(i, 2) = v->z();
      }

      xyz_seq = fullMatrix<double>(polyo + 1, 3);
      xyz_seq(0, 0) = xyz_gmsh(0, 0);
      xyz_seq(0, 1) = xyz_gmsh(0, 1);
      xyz_seq(0, 2) = xyz_gmsh(0, 2);
      for(int i = 1; i < polyo; ++i) {
        xyz_seq(i, 0) = xyz_gmsh(i+1, 0);
        xyz_seq(i, 1) = xyz_gmsh(i+1, 1);
        xyz_seq(i, 2) = xyz_gmsh(i+1, 2);
      }
      xyz_seq(polyo, 0) = xyz_gmsh(1, 0);
      xyz_seq(polyo, 1) = xyz_gmsh(1, 1);
      xyz_seq(polyo, 2) = xyz_gmsh(1, 2);
    }

    void _reduceCurving_newIdea2(MEdgeN *edge, double max_displ_ub, const GFace *gface,
      double gamma, double kappa, const MEdgeN *previous, const MEdgeN *next)
    {
      fullMatrix<double> xyz_gmsh, xyz_seq;
      compute_xyz_gmsh_seq(edge, xyz_gmsh, xyz_seq);

      int polyo = edge->getPolynomialOrder();

      SVector3 dirs[2];
      for(int i = 0; i < 2; ++i) {
        MVertex *v0 = previous->getVertex(i);
        MVertex *v1 = edge->getVertex(i);
        SVector3 n = v1->point() - v0->point();
        n.normalize();
        if(next) {
          MVertex *v2 = next->getVertex(i);
          SVector3 n2 = v2->point() - v1->point();
          n2.normalize();
          n = n + n2;
          n.normalize();
        }
        // Projection
        SVector3 t = edge->tangent(i ? 1 : -1);
        if(i == 0) {
          t = edge->getVertex(2)->point() - v1->point();
        }
        else {
          t = v1->point() - edge->getVertex(polyo)->point();
        }
        dirs[i] = t - dot(t, n) * n;
        dirs[i].normalize();
        // A_ext(i, 0) = dir(0);
      }

      fullMatrix<double> A_lin, b_lin, A_pos, b_pos, A_ext, b_ext,
      A_tg1, b_tg1, A_tg2, b_tg2;
      _construct_matrices(xyz_gmsh, xyz_seq, dirs, A_lin, b_lin, A_pos, b_pos,
        A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2);

      fullMatrix<double> new_xyz(polyo - 1, 3);
      _find_best_reduction(max_displ_ub, gamma, kappa, xyz_gmsh, xyz_seq,
        A_lin, b_lin, A_pos, b_pos, A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2,
        new_xyz);

      for (int i = 2; i < polyo + 1; ++i) {
        MVertex *v = edge->getVertex(i);
        v->x() = new_xyz(i - 2, 0);
        v->y() = new_xyz(i - 2, 1);
        v->z() = new_xyz(i - 2, 2);
      }
    }

    double computeChordDeviation(fullMatrix<double> &xyz_seq, const fullMatrix<double> &xyz_HO)
    {
      int polyo = xyz_seq.size1() - 1;
      xyz_seq.copy(xyz_HO, 0, polyo-1, 0, 3, 1, 0);

      double vx, vy, vz;

      // Compute L_linear
      vx = xyz_seq(polyo, 0) - xyz_seq(0, 0);
      vy = xyz_seq(polyo, 1) - xyz_seq(0, 1);
      vz = xyz_seq(polyo, 2) - xyz_seq(0, 2);
      double L_lin = std::sqrt(vx*vx + vy*vy + vz*vz);

      if(L_lin <= 0.) return 0.; // degenerate

      // Compute Z
      double Z = 0;
      for(int i = 1; i < polyo; ++i) {
        double f = static_cast<double>(i) / polyo;
        double x_lin = xyz_seq(0, 0) + f * vx;
        double y_lin = xyz_seq(0, 1) + f * vy;
        double z_lin = xyz_seq(0, 2) + f * vz;
        double dx = x_lin - xyz_seq(i, 0);
        double dy = y_lin - xyz_seq(i, 1);
        double dz = z_lin - xyz_seq(i, 2);
        Z += std::sqrt(dx*dx + dy*dy + dz*dz);
      }
      Z /= polyo; // not polyo+1 because simpson integration

      const double k = 8.0;
      return std::exp(-k * (Z / L_lin));
    }

    double compute_R(fullMatrix<double> &xyz_seq, const fullMatrix<double> &xyz_HO)
    {
      return computeChordDeviation(xyz_seq, xyz_HO);

      int polyo = xyz_seq.size1() - 1;
      xyz_seq.copy(xyz_HO, 0, polyo-1, 0, 3, 1, 0);

      double vx, vy, vz;

      // Compute L_discrete
      double L_disc = 0;
      for(int i = 0; i < polyo; ++i) {
        vx = xyz_seq(i+1, 0) - xyz_seq(i, 0);
        vy = xyz_seq(i+1, 1) - xyz_seq(i, 1);
        vz = xyz_seq(i+1, 2) - xyz_seq(i, 2);
        L_disc += std::sqrt(vx*vx + vy*vy + vz*vz);
      }

      // Compute L_linear
      vx = xyz_seq(polyo, 0) - xyz_seq(0, 0);
      vy = xyz_seq(polyo, 1) - xyz_seq(0, 1);
      vz = xyz_seq(polyo, 2) - xyz_seq(0, 2);
      double L_lin = std::sqrt(vx*vx + vy*vy + vz*vz);

      // Compute Z
      double Z = 0;
      for(int i = 1; i < polyo; ++i) {
        double f = static_cast<double>(i) / polyo;
        double x_lin = xyz_seq(0, 0) + f * vx;
        double y_lin = xyz_seq(0, 1) + f * vy;
        double z_lin = xyz_seq(0, 2) + f * vz;
        double dx = x_lin - xyz_seq(i, 0);
        double dy = y_lin - xyz_seq(i, 1);
        double dz = z_lin - xyz_seq(i, 2);
        Z += std::sqrt(dx*dx + dy*dy + dz*dz);
      }
      Z /= polyo; // not polyo+1 because simpson integration

      // Compute R
      double L = .5 * (L_disc + L_lin);
      double R = 1 - 2 * Z / L;
      R *= R; // R^2
      return R * R; // R^4
    }

    double match_gamma(double gamma, MEdgeN *edge, const GFace *gface, const SVector3 &normal)
    {
      int polyo = edge->getPolynomialOrder();

      if(gamma >= 1.) {
        fullMatrix<double> xyz(2, 3);
        for(int i = 0; i < 2; ++i) {
          xyz(i, 0) = edge->getVertex(i)->x();
          xyz(i, 1) = edge->getVertex(i)->y();
          xyz(i, 2) = edge->getVertex(i)->z();
        }
        for(int i = 2; i < polyo+1; ++i) {
          double f = (i - 1.) / polyo;
          edge->getVertex(i)->x() = (1-f) * xyz(0, 0) + f * xyz(1, 0);
          edge->getVertex(i)->y() = (1-f) * xyz(0, 1) + f * xyz(1, 1);
          edge->getVertex(i)->z() = (1-f) * xyz(0, 2) + f * xyz(1, 2);
        }
        return 1.;
      }

      fullMatrix<double> xyz_gmsh, xyz_seq;
      compute_xyz_gmsh_seq(edge, xyz_gmsh, xyz_seq);

      SVector3 dirs[2];
      fullMatrix<double> A_lin, b_lin, A_pos, b_pos, A_ext, b_ext,
      A_tg1, b_tg1, A_tg2, b_tg2;
      _construct_matrices(xyz_gmsh, xyz_seq, dirs, A_lin, b_lin, A_pos, b_pos,
        A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2);

      // solve R
      // (coeff - 1) / (R - 1) + 1
      fullMatrix<double> new_xyz_HO(polyo-1, 3);
      for(int i = 0; i < polyo-1; ++i) {
        new_xyz_HO(i, 0) = edge->getVertex(i+2)->x();
        new_xyz_HO(i, 1) = edge->getVertex(i+2)->y();
        new_xyz_HO(i, 2) = edge->getVertex(i+2)->z();
      }

      double R = compute_R(xyz_seq, new_xyz_HO);
      double coeff = 0;
      double target = .95 * gamma;
      double tol = .05 * gamma;

      while(R + tol < target) {
        coeff = 1 + (coeff-1) / (R-1) * (target-1) ;
        // Solve R
        // Update

        fullMatrix<double> A, b;
        _construct_system_lin(coeff, A_lin, b_lin, A_pos, b_pos, A, b);
        // A.print(std::string("A"), std::string(""));
        // b.print(std::string("b"), std::string(""));
        solve_system(A, b, xyz_gmsh, new_xyz_HO, false);
        // xyz_gmsh.print(std::string("xyz_gmsh"), std::string(""));
        // new_xyz_HO.print(std::string("new_xyz_HO"), std::string(""));
        R = compute_R(xyz_seq, new_xyz_HO);
      }

      for(int i = 2; i < polyo+1; ++i) {
        edge->getVertex(i)->x() = new_xyz_HO(i-2, 0);
        edge->getVertex(i)->y() = new_xyz_HO(i-2, 1);
        edge->getVertex(i)->z() = new_xyz_HO(i-2, 2);
      }
      std::cout << "(" << R << ", " << coeff << ", " << tol << ")" << std::endl;
      return coeff;
    }

    void linearize(double coeff, MEdgeN *edge, const GFace *gface, const SVector3 &normal)
    {
      if(coeff < 1e-5) return;
      int polyo = edge->getPolynomialOrder();

      fullMatrix<double> xyz_gmsh, xyz_seq;
      compute_xyz_gmsh_seq(edge, xyz_gmsh, xyz_seq);

      SVector3 dirs[2];
      fullMatrix<double> A_lin, b_lin, A_pos, b_pos, A_ext, b_ext,
      A_tg1, b_tg1, A_tg2, b_tg2;
      _construct_matrices(xyz_gmsh, xyz_seq, dirs, A_lin, b_lin, A_pos, b_pos,
        A_ext, b_ext, A_tg1, b_tg1, A_tg2, b_tg2);

      fullMatrix<double> A, b;
      _construct_system_lin(coeff, A_lin, b_lin, A_pos, b_pos, A, b);
      fullMatrix<double> new_xyz_HO(polyo-1, 3);
      solve_system(A, b, xyz_gmsh, new_xyz_HO, false);

      // xyz_gmsh.print("xyz_gmsh");
      // xyz_seq.print("xyz_seq");
      // new_xyz_HO.print("new_xyz_HO");

      for(int i = 2; i < polyo+1; ++i) {
        edge->getVertex(i)->x() = new_xyz_HO(i-2, 0);
        edge->getVertex(i)->y() = new_xyz_HO(i-2, 1);
        edge->getVertex(i)->z() = new_xyz_HO(i-2, 2);
      }
    }

    void curveEdge_newIdea(Parameters params, const MEdgeN *baseEdge, MEdgeN *edge, const GFace *gface,
                           const SVector3 &normal, MEdgeN *next, double current_h)
    {
      _Frame frame(baseEdge, gface, normal);

      double coeffs[2][3];
      _computeParameters(baseEdge, edge, frame, coeffs, params.interpolationType);

      const int orderCurve = baseEdge->getPolynomialOrder();
      const int orderGauss = orderCurve * 2;
      const int sizeSystem = getNGQLPts(orderGauss);
      const IntPt *gaussPnts = getGQLPts(orderGauss);

      // Least square projection
      fullMatrix<double> xyz(sizeSystem + 2, 3);
      _idealPositionEdge(params, baseEdge, frame, coeffs, sizeSystem, gaussPnts, xyz);
      // _drawIdealPositionEdge(baseEdge, frame, coeffs, params.interpolationType);
      for(int i = 0; i < 2; ++i) {
        xyz(sizeSystem + i, 0) = edge->getVertex(i)->x();
        xyz(sizeSystem + i, 1) = edge->getVertex(i)->y();
        xyz(sizeSystem + i, 2) = edge->getVertex(i)->z();
      }

      LeastSquareData *data =
        getLeastSquareData(TYPE_LIN, orderCurve, orderGauss);
      fullMatrix<double> newxyz(orderCurve + 1, 3);
      data->invA.mult(xyz, newxyz);

      for(int i = 2; i < edge->getNumVertices(); ++i) {
        edge->getVertex(i)->x() = newxyz(i, 0);
        edge->getVertex(i)->y() = newxyz(i, 1);
        edge->getVertex(i)->z() = newxyz(i, 2);
      }

      double minThickness = 1e10;
      MVertex *v0 = edge->getVertex(0);
      MVertex *v1 = baseEdge->getVertex(0);
      if (v0 != v1) {
        SVector3 vec = v0->point() - v1->point();
        minThickness = std::min(minThickness, vec.norm());
      }
      v0 = edge->getVertex(6);
      v1 = baseEdge->getVertex(6);
      if (v0 != v1) {
        SVector3 vec = v0->point() - v1->point();
        minThickness = std::min(minThickness, vec.norm());
      }

      // _reduceCurving_newIdea(edge, minThickness*.1, gface);
      // NOTE
      //  1) Calculer les h_i. -> H = h_N, z_i = h_i / H
      //  2) Param z_lin : Si h_i / H < z_lin, pas de rduction de courbure
      //  3) Param gamma_out : gamma(z) = 0 si z <= z_lin,
      //                                = f*(z-z_lin) si z >= z_lin
      //                                  f tq gamma(z_out) = gamma_out
      //  4) Param tau : tq max_displ = tau * (h_i+1 - h_i)
      //  5) Param kappa : imposition perpendicularit aux extrmits

      // TODO
      //  0x Sparer les tangentes BSpline dans la matrice
      //  1x Calculer h_i
      //  2. Dterminer relation entre gamma (degr linarit voulu) et
      //     Sum (b_i-x_i)^2 / L^2
      //     =>  L = (L_lin + L_disc) / 2
      //         Z = sum |x_i-z_i| / (N-1) (car Simpson)
      //         R = (1 - 2*Z/L) ** 4
      //         R >= gamma
      //  3. Dterminer relation entre gamma voulu et coefficient dans la matrice
      //     (recalculer relation pour deux F_a = (x-x_a)^2 et F_b. On veut
      //      x_opt = (1 - w) * x_a + w * x_b, alors quelle fonctionnel minimiser ?
      //      F = c_a * F_a + c_b * F_b
      //      => c_a = (1-w) et c_b = w => barycentric weight
      //  4. Mettre tout ensemble pour obtenir le rsultat final

      // double gamma = current_h < .5 ? 0 : 2 * current_h - .5;
      // gamma = current_h;
      // // gamma = 1;
      // gamma = 0; // 0 = curved
      // double kappa = params.alignmentFactor;
      // double tau = .1;
      // _reduceCurving_newIdea2(edge, minThickness*tau, gface, gamma, kappa, baseEdge, next);

      if(gface) projectVerticesIntoGFace(edge, gface, false);


      //drawBezierControlPolygon(edge->getVertices());
    }

    void _reduceCurving(MEdgeN *edge, double factor, const GFace *gface)
    {
      int order = edge->getPolynomialOrder();

      MVertex *v0 = edge->getVertex(0);
      MVertex *v1 = edge->getVertex(1);

      for(int i = 2; i < order + 1; ++i) {
        double f = (double)(i - 1) / order;
        MVertex *v = edge->getVertex(i);
        v->x() =
          (1 - factor) * v->x() + factor * ((1 - f) * v0->x() + f * v1->x());
        v->y() =
          (1 - factor) * v->y() + factor * ((1 - f) * v0->y() + f * v1->y());
        v->z() =
          (1 - factor) * v->z() + factor * ((1 - f) * v0->z() + f * v1->z());
      }
      if(gface) projectVerticesIntoGFace(edge, gface, false);
    }

    void _reduceCurving2(MEdgeN *edge, double dx, const GFace *gface)
    {
      int order = edge->getPolynomialOrder();

      MVertex *v0 = edge->getVertex(0);
      MVertex *v1 = edge->getVertex(1);

      double max_h = 0;
      for(int i = 2; i < order + 1; ++i) {
        double f = (double)(i - 1) / order;
        MVertex *v = edge->getVertex(i);
        double dh_x = v->x() - ((1 - f) * v0->x() + f * v1->x());
        double dh_y = v->y() - ((1 - f) * v0->y() + f * v1->y());
        double dh_z = v->z() - ((1 - f) * v0->z() + f * v1->z());
        max_h = std::max(max_h, std::sqrt(dh_x*dh_x + dh_y*dh_y + dh_z*dh_z));
      }

      double factor = dx / max_h;

      for(int i = 2; i < order + 1; ++i) {
        double f = (double)(i - 1) / order;
        MVertex *v = edge->getVertex(i);
        v->x() =
          (1 - factor) * v->x() + factor * ((1 - f) * v0->x() + f * v1->x());
        v->y() =
          (1 - factor) * v->y() + factor * ((1 - f) * v0->y() + f * v1->y());
        v->z() =
          (1 - factor) * v->z() + factor * ((1 - f) * v0->z() + f * v1->z());
      }
      if(gface) projectVerticesIntoGFace(edge, gface, false);
    }

    void _reduceOrderCurve(MEdgeN *edge, int order, const GFace *gface)
    {
      const int orderCurve = edge->getPolynomialOrder();
      const int orderGauss = order * 2;
      const int sizeSystem = getNGQLPts(orderGauss);
      const IntPt *gaussPnts = getGQLPts(orderGauss);

      // Least square projection
      fullMatrix<double> xyz(sizeSystem + 2, 3);
      for(int i = 0; i < sizeSystem; ++i) {
        SPoint3 p = edge->pnt(gaussPnts[i].pt[0]);
        xyz(i, 0) = p.x();
        xyz(i, 1) = p.y();
        xyz(i, 2) = p.z();
      }
      for(int i = 0; i < 2; ++i) {
        xyz(sizeSystem + i, 0) = edge->getVertex(i)->x();
        xyz(sizeSystem + i, 1) = edge->getVertex(i)->y();
        xyz(sizeSystem + i, 2) = edge->getVertex(i)->z();
      }

      LeastSquareData *data = getLeastSquareData(TYPE_LIN, order, orderGauss);
      fullMatrix<double> newxyzLow(order + 1, 3);
      data->invA.mult(xyz, newxyzLow);

      std::vector<MVertex *> vertices = edge->getVertices();
      vertices.resize(static_cast<std::size_t>(order) + 1);
      MEdgeN lowOrderEdge(vertices);

      for(std::size_t i = 2; i < vertices.size(); ++i) {
        vertices[i]->x() = newxyzLow(i, 0);
        vertices[i]->y() = newxyzLow(i, 1);
        vertices[i]->z() = newxyzLow(i, 2);
      }

      const int tagLine = ElementType::getType(TYPE_LIN, orderCurve);
      const nodalBasis *nb = BasisFactory::getNodalBasis(tagLine);
      const fullMatrix<double> &refpnts = nb->getReferenceNodes();

      fullMatrix<double> newxyz(edge->getNumVertices(), 3);
      for(std::size_t i = 2; i < edge->getNumVertices(); ++i) {
        SPoint3 p = lowOrderEdge.pnt(refpnts(i, 0));
        newxyz(i, 0) = p.x();
        newxyz(i, 1) = p.y();
        newxyz(i, 2) = p.z();
      }

      for(int i = 2; i < edge->getNumVertices(); ++i) {
        edge->getVertex(i)->x() = newxyz(i, 0);
        edge->getVertex(i)->y() = newxyz(i, 1);
        edge->getVertex(i)->z() = newxyz(i, 2);
      }

      if(gface) projectVerticesIntoGFace(edge, gface, false);
    }

    void recoverQualityElements(std::vector<MEdgeN> &stackEdges,
                                std::vector<MFaceN> &stackFaces,
                                std::vector<MElement *> &stackElements,
                                int iFirst, int iLast, const GFace *gface)
    {
      std::vector<MEdgeN> subsetEdges(4);
      subsetEdges[0] = stackEdges[0];
      subsetEdges[1] = stackEdges[iFirst];
      subsetEdges[2] = stackEdges[iLast - 1];
      subsetEdges[3] = stackEdges[iLast];
      MEdgeN *lastEdge = &stackEdges[iLast];
      std::vector<MFaceN> subsetFaces;
      subsetFaces.push_back(stackFaces[iLast - 1]);
      subsetFaces.push_back(stackFaces[iLast]);
      // Warning: subsetFaces should contain 2 faces since
      // repositionInnerVertices() need a column of BL faces + the exterior face

      // First get sure that last element of the BL is of good quality
      MElement *lastElementBL = stackElements[iLast - 1];
      MElement *linear = createPrimaryElement(lastElementBL);
      double qualLinear = jacobianBasedQuality::minIGEMeasure(linear);
      delete linear;

      InteriorEdgeCurver::curveEdges(subsetEdges, 1, 3, gface);
      repositionInnerVertices(subsetFaces, gface);
      double qual = jacobianBasedQuality::minIGEMeasure(lastElementBL);
      int currentOrder = lastEdge->getPolynomialOrder();
      while(qual < .75 && qual < .8 * qualLinear && currentOrder > 2) {
        _reduceOrderCurve(lastEdge, --currentOrder, gface);
        InteriorEdgeCurver::curveEdges(subsetEdges, 1, 3, gface);
        repositionInnerVertices(subsetFaces, gface);
        qual = jacobianBasedQuality::minIGEMeasure(lastElementBL);
      }
      int iter = 0;
      const int maxIter = 15;
      while(qual < .75 && qual < .8 * qualLinear && ++iter < maxIter) {
        _reduceCurving(lastEdge, .25, gface);
        InteriorEdgeCurver::curveEdges(subsetEdges, 1, 3, gface);
        repositionInnerVertices(subsetFaces, gface);
        qual = jacobianBasedQuality::minIGEMeasure(lastElementBL);
      }

      // Now, get sure the exterior element is of good quality
      MElement *lastElement = stackElements[iLast];
      linear = createPrimaryElement(lastElement);
      qualLinear = jacobianBasedQuality::minIGEMeasure(linear);
      delete linear;

      qual = jacobianBasedQuality::minIGEMeasure(lastElement);
      while(qual < .75 && qual < .8 * qualLinear && ++iter < maxIter) {
        _reduceCurving(lastEdge, .25, gface);
        repositionInnerVertices(subsetFaces, gface);
        qual = jacobianBasedQuality::minIGEMeasure(lastElement);
      }
      if(iter == maxIter) _reduceCurving(lastEdge, 1, gface);
    }

    double match_gamma_simpler(double gamma, MEdgeN *edge, const GFace *gface, const SVector3 &normal)
    {
      int polyo = edge->getPolynomialOrder();

      if(gamma >= 1.) {
        fullMatrix<double> xyz(2, 3);
        for(int i = 0; i < 2; ++i) {
          xyz(i, 0) = edge->getVertex(i)->x();
          xyz(i, 1) = edge->getVertex(i)->y();
          xyz(i, 2) = edge->getVertex(i)->z();
        }
        for(int i = 2; i < polyo+1; ++i) {
          double f = (i - 1.) / polyo;
          edge->getVertex(i)->x() = (1-f) * xyz(0, 0) + f * xyz(1, 0);
          edge->getVertex(i)->y() = (1-f) * xyz(0, 1) + f * xyz(1, 1);
          edge->getVertex(i)->z() = (1-f) * xyz(0, 2) + f * xyz(1, 2);
        }
        return 1.;
      }

      fullMatrix<double> xyz_gmsh, xyz_seq;
      compute_xyz_gmsh_seq(edge, xyz_gmsh, xyz_seq);

      // _reduceCurving(edge, .25, gface);

      fullMatrix<double> xyz_HO(polyo-1, 3), xyz_lin(polyo-1, 3);
      for(int i = 0; i < polyo-1; ++i) {
        xyz_HO(i, 0) = edge->getVertex(i+2)->x();
        xyz_HO(i, 1) = edge->getVertex(i+2)->y();
        xyz_HO(i, 2) = edge->getVertex(i+2)->z();
        double f = (i + 1.) / polyo;
        xyz_lin(i, 0) = (1-f) * edge->getVertex(0)->x() + f * edge->getVertex(1)->x();
        xyz_lin(i, 1) = (1-f) * edge->getVertex(0)->y() + f * edge->getVertex(1)->y();
        xyz_lin(i, 2) = (1-f) * edge->getVertex(0)->z() + f * edge->getVertex(1)->z();
      }

      double R = compute_R(xyz_seq, xyz_HO);
      double coeff = 0;
      double target = .95 * gamma;
      double tol = .05 * gamma;
      fullMatrix<double> new_xyz_HO = xyz_HO;

      while(R + tol < target) {
        coeff = 1 + (coeff-1) / (R-1) * (target-1) ;

        new_xyz_HO = xyz_HO;
        new_xyz_HO.scale(1-coeff);
        new_xyz_HO.axpy(xyz_lin, coeff);

        // xyz_gmsh.print(std::string("xyz_gmsh"), std::string(""));
        // new_xyz_HO.print(std::string("new_xyz_HO"), std::string(""));
        R = compute_R(xyz_seq, new_xyz_HO);
      }

      for(int i = 2; i < polyo+1; ++i) {
        edge->getVertex(i)->x() = new_xyz_HO(i-2, 0);
        edge->getVertex(i)->y() = new_xyz_HO(i-2, 1);
        edge->getVertex(i)->z() = new_xyz_HO(i-2, 2);
      }
      std::cout << "(" << R << ", " << coeff << ", " << tol << ")" << std::endl;
      return coeff;
    }

    double match_gamma_simpler2(double gamma, MEdgeN *edge, const GFace *gface, const SVector3 &normal)
    {
      int polyo = edge->getPolynomialOrder();

      if(gamma >= 1.) {
        fullMatrix<double> xyz(2, 3);
        for(int i = 0; i < 2; ++i) {
          xyz(i, 0) = edge->getVertex(i)->x();
          xyz(i, 1) = edge->getVertex(i)->y();
          xyz(i, 2) = edge->getVertex(i)->z();
        }
        double max_displ = 0;
        for(int i = 2; i < polyo+1; ++i) {
          double f = (i - 1.) / polyo;
          double dx = edge->getVertex(i)->x() - ((1-f) * xyz(0, 0) + f * xyz(1, 0));
          double dy = edge->getVertex(i)->y() - ((1-f) * xyz(0, 1) + f * xyz(1, 1));
          double dz = edge->getVertex(i)->z() - ((1-f) * xyz(0, 2) + f * xyz(1, 2));
          max_displ = std::max(max_displ, sqrt(dx*dx + dy*dy + dz*dz));
          edge->getVertex(i)->x() = (1-f) * xyz(0, 0) + f * xyz(1, 0);
          edge->getVertex(i)->y() = (1-f) * xyz(0, 1) + f * xyz(1, 1);
          edge->getVertex(i)->z() = (1-f) * xyz(0, 2) + f * xyz(1, 2);
        }
        return max_displ;
      }

      fullMatrix<double> xyz_gmsh, xyz_seq;
      compute_xyz_gmsh_seq(edge, xyz_gmsh, xyz_seq);

      // _reduceCurving(edge, .25, gface);

      fullMatrix<double> xyz_HO(polyo-1, 3), xyz_lin(polyo-1, 3);
      for(int i = 0; i < polyo-1; ++i) {
        xyz_HO(i, 0) = edge->getVertex(i+2)->x();
        xyz_HO(i, 1) = edge->getVertex(i+2)->y();
        xyz_HO(i, 2) = edge->getVertex(i+2)->z();
        double f = (i + 1.) / polyo;
        xyz_lin(i, 0) = (1-f) * edge->getVertex(0)->x() + f * edge->getVertex(1)->x();
        xyz_lin(i, 1) = (1-f) * edge->getVertex(0)->y() + f * edge->getVertex(1)->y();
        xyz_lin(i, 2) = (1-f) * edge->getVertex(0)->z() + f * edge->getVertex(1)->z();
      }

      double R = compute_R(xyz_seq, xyz_HO);
      double coeff = 0;
      double target = .95 * gamma;
      double tol = .05 * gamma;
      fullMatrix<double> new_xyz_HO = xyz_HO;

      while(R + tol < target) {
        coeff = 1 + (coeff-1) / (R-1) * (target-1) ;

        new_xyz_HO = xyz_HO;
        new_xyz_HO.scale(1-coeff);
        new_xyz_HO.axpy(xyz_lin, coeff);

        // xyz_gmsh.print(std::string("xyz_gmsh"), std::string(""));
        // new_xyz_HO.print(std::string("new_xyz_HO"), std::string(""));
        R = compute_R(xyz_seq, new_xyz_HO);
      }

      double max_displ = 0;
      for(int i = 2; i < polyo+1; ++i) {
        double dx = edge->getVertex(i)->x() - new_xyz_HO(i-2, 0);
        double dy = edge->getVertex(i)->y() - new_xyz_HO(i-2, 1);
        double dz = edge->getVertex(i)->z() - new_xyz_HO(i-2, 2);
        max_displ = std::max(max_displ, sqrt(dx*dx + dy*dy + dz*dz));
        edge->getVertex(i)->x() = new_xyz_HO(i-2, 0);
        edge->getVertex(i)->y() = new_xyz_HO(i-2, 1);
        edge->getVertex(i)->z() = new_xyz_HO(i-2, 2);
      }
      std::cout << "(" << R << ", " << coeff << ", " << tol << ")" << std::endl;
      return max_displ;
    }
  } // namespace EdgeCurver2D

  namespace InteriorEdgeCurver {
    static std::map<std::pair<int, int>, TFIData *> tfiData;

    TFIData *_constructTFIData(int typeElement, int order)
    {
      TFIData *data = new TFIData;
      int nbDof = order + 1;

      fullMatrix<double> Mh; // lag coeff p n -> lag coeff p (n+1)
      fullMatrix<double> M0; // lag coeff p (n+1) c -> (1-xi) * c
      fullMatrix<double> M1; // lag coeff p (n+1) c ->    xi  * c
      fullMatrix<double> Ml; // lag coeff p (n+1) -> leg coeff p n
      fullMatrix<double> Me; // leg coeff p n -> lag coeff p n

      if(typeElement == TYPE_LIN) {
        int tagLine = ElementType::getType(TYPE_LIN, order);
        const nodalBasis *fs = BasisFactory::getNodalBasis(tagLine);
        const fullMatrix<double> &refNodes = fs->getReferenceNodes();
        const fullMatrix<double> refNodesh = gmshGeneratePointsLine(order + 1);

        int nbDofh = refNodesh.size1();

        //      refNodesh.print("refNodesh");

        Mh.resize(nbDofh, nbDof);
        for(int i = 0; i < nbDofh; ++i) {
          double sf[100];
          fs->f(refNodesh(i, 0), refNodesh(i, 1), refNodesh(i, 2), sf);
          for(int j = 0; j < nbDof; ++j) { Mh(i, j) = sf[j]; }
        }
        //      Mh.print("Mh");

        M0.resize(nbDofh, nbDofh, true);
        M1.resize(nbDofh, nbDofh, true);
        for(int i = 0; i < nbDofh; ++i) {
          M0(i, i) = .5 - refNodesh(i, 0) / 2;
          M1(i, i) = .5 + refNodesh(i, 0) / 2;
        }
        //      M0.print("M0");
        //      M1.print("M1");

        Ml.resize(nbDof, nbDofh);
        {
          fullMatrix<double> vandermonde(nbDofh, nbDofh);

          double *val = new double[nbDofh];
          for(int i = 0; i < nbDofh; ++i) {
            LegendrePolynomials::fc(order + 1, refNodesh(i, 0), val);
            for(int j = 0; j < nbDofh; ++j) { vandermonde(i, j) = val[j]; }
          }
          delete val;

          fullMatrix<double> tmp;
          vandermonde.invert(tmp);
          //        vandermonde.print("vandermonde");
          //        tmp.print("tmp");
          Ml.copy(tmp, 0, nbDof, 0, nbDofh, 0, 0);
        }
        //      Ml.print("Ml");

        Me.resize(nbDof, nbDof);
        {
          double *val = new double[nbDof];
          for(int i = 0; i < nbDof; ++i) {
            LegendrePolynomials::fc(order, refNodes(i, 0), val);
            for(int j = 0; j < nbDof; ++j) { Me(i, j) = val[j]; }
          }
          delete val;
        }
        //      Me.print("Me");

        fullMatrix<double> tmp0(nbDofh, nbDof);
        fullMatrix<double> tmp1(nbDofh, nbDof);
        M0.mult(Mh, tmp0);
        M1.mult(Mh, tmp1);
        fullMatrix<double> tmp(nbDof, nbDofh);
        Me.mult(Ml, tmp);
        //      tmp.print("tmp");
        data->T0.resize(nbDof, nbDof);
        data->T1.resize(nbDof, nbDof);
        tmp.mult(tmp0, data->T0);
        tmp.mult(tmp1, data->T1);

        //      data->T0.print("data->T0");
        //      data->T1.print("data->T1");
      }

      //    fullVector<double> x(nbDof);
      //    x.setAll(1);
      //    fullVector<double> b1(nbDof);
      //    fullVector<double> b2(nbDof);
      //    data->T0.mult(x, b1);
      //    b1.print("b");
      //    data->T1.mult(x, b1);
      //    b1.print("b");
      //
      //    x(0) = 0;
      //    x(2) = 1/6.;
      //    x(3) = 2/6.;
      //    x(4) = 3/6.;
      //    x(5) = 4/6.;
      //    x(6) = 5/6.;
      //    x(1) = 1;
      //    data->T0.mult(x, b1);
      //    b1.print("b1");
      //    data->T1.mult(x, b2);
      //    b2.print("b2");
      //    b1.axpy(b2);
      //    b1.print("b");
      //
      //    x(0) = 0;
      //    x(2) = 0.000021433470508;
      //    x(3) = 0.001371742112483;
      //    x(4) = 0.015625000000000;
      //    x(5) = 0.087791495198903;
      //    x(6) = 0.334897976680384;
      //    x(1) = 1.000000000000000;
      //    data->T0.mult(x, b1);
      //    b1.print("b1");
      //    data->T1.mult(x, b2);
      //    b2.print("b2");
      //    b1.axpy(b2);
      //    b1.print("b");

      return data;
    }

    TFIData *_getTFIData(int typeElement, int order)
    {
      std::pair<int, int> typeOrder(typeElement, order);
      std::map<std::pair<int, int>, TFIData *>::iterator it;
      it = tfiData.find(typeOrder);

      if(it != tfiData.end()) return it->second;

      TFIData *data = _constructTFIData(typeElement, order);

      tfiData[typeOrder] = data;
      return data;
    }

    void _linearize(const fullMatrix<double> &x, fullMatrix<double> &lin)
    {
      int n = x.size1();
      lin.copy(x, 0, 2, 0, 3, 0, 0);
      for(int i = 2; i < n; ++i) {
        double fact = ((double)i - 1) / (n - 1);
        for(int j = 0; j < 3; ++j)
          lin(i, j) = (1 - fact) * x(0, j) + fact * x(1, j);
      }
    }

    void _computeEtas(const std::vector<MEdgeN> &stack,
                      std::vector<std::pair<double, double> > &eta)
    {
      eta.resize(stack.size());
      eta[0] = std::make_pair(0, 0);
      MVertex *vb0 = stack[0].getVertex(0);
      MVertex *vb1 = stack[0].getVertex(1);

      for(std::size_t i = 1; i < stack.size(); ++i) {
        MVertex *v0 = stack[i].getVertex(0);
        MVertex *v1 = stack[i].getVertex(1);
        eta[i].first = vb0->distance(v0);
        eta[i].second = vb1->distance(v1);
      }

      for(int i = 1; i < eta.size(); ++i) {
        eta[i].first /= eta.back().first;
        eta[i].second /= eta.back().second;
      }
    }

    void _computeDeltaForTFI(const std::vector<MEdgeN> &stack, int iFirst,
                             int iLast, fullMatrix<double> &delta0,
                             fullMatrix<double> &delta1,
                             fullMatrix<double> &deltaN)
    {
      const int numVertices = stack[0].getNumVertices();

      fullMatrix<double> x0(numVertices, 3);
      fullMatrix<double> x1(numVertices, 3);
      fullMatrix<double> xN(numVertices, 3);
      for(int k = 0; k < numVertices; ++k) {
        x0(k, 0) = stack[0].getVertex(k)->x();
        x0(k, 1) = stack[0].getVertex(k)->y();
        x0(k, 2) = stack[0].getVertex(k)->z();
        x1(k, 0) = stack[iFirst].getVertex(k)->x();
        x1(k, 1) = stack[iFirst].getVertex(k)->y();
        x1(k, 2) = stack[iFirst].getVertex(k)->z();
        xN(k, 0) = stack[iLast].getVertex(k)->x();
        xN(k, 1) = stack[iLast].getVertex(k)->y();
        xN(k, 2) = stack[iLast].getVertex(k)->z();
      }

      fullMatrix<double> x0linear(numVertices, 3);
      fullMatrix<double> x1linear(numVertices, 3);
      fullMatrix<double> xNlinear(numVertices, 3);
      _linearize(x0, x0linear);
      _linearize(x1, x1linear);
      _linearize(xN, xNlinear);
      delta0 = x0;
      delta0.axpy(x0linear, -1);
      delta1 = x1;
      delta1.axpy(x1linear, -1);
      deltaN = xN;
      deltaN.axpy(xNlinear, -1);
    }

    void _computeTerms(const fullMatrix<double> &delta0,
                       const fullMatrix<double> &delta1,
                       const fullMatrix<double> &deltaN, double eta1,
                       fullMatrix<double> terms[8])
    {
      fullMatrix<double> &term0 = terms[0];
      fullMatrix<double> &term1d10 = terms[1];
      fullMatrix<double> &term1d11 = terms[2];
      fullMatrix<double> &term1dN0 = terms[3];
      fullMatrix<double> &term1dN1 = terms[4];
      fullMatrix<double> &term20 = terms[5];
      fullMatrix<double> &term21 = terms[6];
      fullMatrix<double> &term22 = terms[7];

      const int numVertices = delta0.size1();

      fullMatrix<double> delta10 = delta1;
      delta10.axpy(delta0, -1);
      delta10.scale(1 / eta1);
      fullMatrix<double> deltaN0 = deltaN;
      deltaN0.axpy(delta0, -1);

      term0.resize(numVertices, 3);
      term1d10.resize(numVertices, 3);
      term1d11.resize(numVertices, 3);
      term1dN0.resize(numVertices, 3);
      term1dN1.resize(numVertices, 3);
      term20.resize(numVertices, 3);
      term21.resize(numVertices, 3);
      term22.resize(numVertices, 3);

      TFIData *tfiData = _getTFIData(TYPE_LIN, numVertices - 1);

      term0.copy(delta0);
      tfiData->T0.mult(delta10, term1d10);
      tfiData->T1.mult(delta10, term1d11);
      tfiData->T0.mult(deltaN0, term1dN0);
      tfiData->T1.mult(deltaN0, term1dN1);
      fullMatrix<double> diff(numVertices, 3);
      fullMatrix<double> dum0(numVertices, 3);
      fullMatrix<double> dum1(numVertices, 3);
      diff.copy(deltaN0);
      diff.axpy(delta10, -1);
      tfiData->T0.mult(diff, dum0);
      tfiData->T1.mult(diff, dum1);
      tfiData->T0.mult(dum0, term20);
      tfiData->T1.mult(dum0, term21);
      tfiData->T1.mult(dum1, term22);
    }

    void _generalTFI(std::vector<MEdgeN> &stack, int iLast,
                     const std::vector<std::pair<double, double> > &eta,
                     const fullMatrix<double> terms[8], double coeffHermite,
                     const GFace *gface)
    {
      // Let L() be the linear TFI transformation
      // Let H() be the semi-Hermite TFI transformation
      // This function return (1-coeffHermite) * L() + coeffHermite * H()

      const fullMatrix<double> &term0 = terms[0];
      const fullMatrix<double> &term1d10 = terms[1];
      const fullMatrix<double> &term1d11 = terms[2];
      const fullMatrix<double> &term1dN0 = terms[3];
      const fullMatrix<double> &term1dN1 = terms[4];
      const fullMatrix<double> &term20 = terms[5];
      const fullMatrix<double> &term21 = terms[6];
      const fullMatrix<double> &term22 = terms[7];

      int numVertices = stack[0].getNumVertices();

      for(std::size_t i = 1; i < stack.size(); ++i) {
        if(i == iLast) continue;
        // we want to change stack[iFirst] but not stack[iLast]

        fullMatrix<double> x(numVertices, 3);
        for(int j = 0; j < numVertices; ++j) {
          MVertex *v = stack[i].getVertex(j);
          x(j, 0) = v->x();
          x(j, 1) = v->y();
          x(j, 2) = v->z();
        }
        _linearize(x, x);

        double &c = coeffHermite;
        x.axpy(term0);
        x.axpy(term1d10, c * eta[i].first);
        x.axpy(term1d11, c * eta[i].second);
        x.axpy(term1dN0, (1 - c) * eta[i].first);
        x.axpy(term1dN1, (1 - c) * eta[i].second);
        x.axpy(term20, c * eta[i].first * eta[i].first);
        x.axpy(term21, c * 2 * eta[i].first * eta[i].second);
        x.axpy(term22, c * eta[i].second * eta[i].second);

        for(int j = 2; j < numVertices; ++j) {
          MVertex *v = stack[i].getVertex(j);
          v->x() = x(j, 0);
          v->y() = x(j, 1);
          v->z() = x(j, 2);
        }
        if(gface) projectVerticesIntoGFace(&stack[i], gface, false);
      }
    }

    void _computeEtaAndTerms(std::vector<MEdgeN> &stack, int iFirst, int iLast,
                             std::vector<std::pair<double, double> > &eta,
                             fullMatrix<double> terms[8])
    {
      // Compute eta_i^k, k=0,1
      _computeEtas(stack, eta);

      // Precompute Delta(x_i), i=0,1,n
      fullMatrix<double> delta0, delta1, deltaN;
      _computeDeltaForTFI(stack, iFirst, iLast, delta0, delta1, deltaN);

      // Compute terms
      double eta1 = .5 * (eta[iFirst].first + eta[iFirst].second);
      _computeTerms(delta0, delta1, deltaN, eta1, terms);
    }

    void curveEdges(std::vector<MEdgeN> &stack, int iFirst, int iLast,
                    const GFace *gface)
    {
      std::vector<std::pair<double, double> > eta;
      fullMatrix<double> terms[8];
      _computeEtaAndTerms(stack, iFirst, iLast, eta, terms);

      _generalTFI(stack, iLast, eta, terms, 1, gface);
    }

    void curveEdgesAndPreserveQuality(std::vector<MEdgeN> &stackEdges,
                                      std::vector<MFaceN> &stackFaces,
                                      std::vector<MElement *> &stackElements,
                                      int iFirst, int iLast, const GFace *gface)
    {
      std::vector<std::pair<double, double> > eta;
      fullMatrix<double> terms[8];
      _computeEtaAndTerms(stackEdges, iFirst, iLast, eta, terms);

      // Compute quality of primary elements
      unsigned long numElements = stackElements.size() - 1;
      std::vector<double> qualitiesLinear(numElements);
      for(std::size_t i = 0; i < numElements; ++i) {
        MElement *linear = createPrimaryElement(stackElements[i]);
        qualitiesLinear[i] = jacobianBasedQuality::minIGEMeasure(linear);
        delete linear;
      }

      static double coeffHermite[11] = {1,  .9, .8, .7, .6, .5,
                                        .4, .3, .2, .1, 0};
      for(int i = 0; i < 11; ++i) {
        _generalTFI(stackEdges, iLast, eta, terms, coeffHermite[i], gface);
        repositionInnerVertices(stackFaces, gface);

        bool allOk = true;
        if(coeffHermite[i]) {
          for(std::size_t i = 0; i < numElements; ++i) {
            double qual = jacobianBasedQuality::minIGEMeasure(stackElements[i]);
            if(qual < .5 && qual < .8 * qualitiesLinear[i]) {
              allOk = false;
              break;
            }
          }
        }

        if(allOk) return;
      }
    }

    void linearizeEndOfBL(Parameters &params, std::vector<MEdgeN> &stackEdges,
                          std::vector<double> &relativePositions,
                          const GFace *gface, const SVector3 &normal)
    {
      MEdgeN &endEdge = stackEdges.back();
      const int nV = (int)endEdge.getNumVertices();

      // Save stackEdges.back() xyz coordinates (N x 3) -> original
      fullMatrix<double> xyz_original(nV, 3);
      for(int k = 0; k < nV; ++k) {
        MVertex *v = endEdge.getVertex(k);
        xyz_original(k, 0) = v->x();
        xyz_original(k, 1) = v->y();
        xyz_original(k, 2) = v->z();
      }

      // Linearize last edge in-place
      EdgeCurver2D::match_gamma_simpler(params.endLinearizationFactor, &endEdge, gface,
                                       normal);

      // Save stackEdges.back() xyz coordinates (N x 3) -> linearized
      fullMatrix<double> xyz_linearized(nV, 3);
      for(int k = 0; k < nV; ++k) {
        MVertex *v = endEdge.getVertex(k);
        xyz_linearized(k, 0) = v->x();
        xyz_linearized(k, 1) = v->y();
        xyz_linearized(k, 2) = v->z();
      }

      // Compute difference -> diff (in Lagrange nodal values)
      fullMatrix<double> diff_lag(nV, 3);
      diff_lag.copy(xyz_linearized);
      diff_lag.axpy(xyz_original, -1);

      // Transform to HSR coeff (so we can apply the same "shape" correction
      // to other edges regardless of their current nodal placement)
      fullMatrix<double> diff_hsr;
      lag2HSR(diff_lag, diff_hsr);

      fullMatrix<double> original_hsr;
      lag2HSR(xyz_original, original_hsr);
      std::cout << original_hsr(2,0) << ", " << std::endl;
      std::cout << diff_hsr(2,0) << ", " << std::endl;

      const std::size_t N = stackEdges.size();
      const double denom = 1.0 - params.backpropLimit;

      if(denom <= 0.0) return;

      for(std::size_t i = 1; i < N - 1; ++i) {
        if(relativePositions[i] <= params.backpropLimit) continue;

        const double fact = (relativePositions[i] - params.backpropLimit) / denom;

        MEdgeN &e = stackEdges[i];
        const std::size_t nEi = e.getNumVertices();

        // Read current edge xyz (Lagrange nodal values)
        fullMatrix<double> xyz_e_lag((int)nEi, 3);
        for(std::size_t k = 0; k < nEi; ++k) {
          MVertex *v = e.getVertex(k);
          xyz_e_lag((int)k, 0) = v->x();
          xyz_e_lag((int)k, 1) = v->y();
          xyz_e_lag((int)k, 2) = v->z();
        }

        // Convert to HSR, add correction in HSR space, convert back
        fullMatrix<double> xyz_e_hsr;
        lag2HSR(xyz_e_lag, xyz_e_hsr);

        std::cout << xyz_e_hsr(2,0) << ", " << fact;

        // Safety: only proceed if dimensions match (same edge order)
        if(xyz_e_hsr.size1() == diff_hsr.size1() &&
           xyz_e_hsr.size2() == diff_hsr.size2()) {
          xyz_e_hsr.axpy(diff_hsr, fact);
          std::cout << ", " << xyz_e_hsr(2,0) << std::endl;

          fullMatrix<double> xyz_e_new_lag;
          hsr2Lag(xyz_e_hsr, xyz_e_new_lag);

          for(std::size_t k = 0; k < nEi; ++k) {
            MVertex *v = e.getVertex(k);
            v->setXYZ(xyz_e_new_lag((int)k, 0), xyz_e_new_lag((int)k, 1),
                      xyz_e_new_lag((int)k, 2));
          }
        }
      }
    }
  } // namespace InteriorEdgeCurver

  MElement *createPrimaryElement(MElement *el)
  {
    int tagLinear = ElementType::getType(el->getType(), 1);
    std::vector<MVertex *> vertices;
    el->getVertices(vertices);
    MElementFactory f;
    return f.create(tagLinear, vertices, -1);
  }

  LeastSquareData *constructLeastSquareData(int typeElement, int order,
                                            int orderGauss)
  {
    // invM1 gives
    //     value of coefficients in Legendre basis
    //   + value of Lagrange multipliers
    // from
    //     Ij + value of function f at extremities
    // M2 gives
    //     Ij = integral of product function f with Legendre polynomial j
    //   + value of function f at extremities
    // from
    //     the values of function f at Gauss points
    //   + value of function f at extremities

    orthogonalBasis basis(typeElement, order);
    LeastSquareData *data = new LeastSquareData;

    if(typeElement == TYPE_LIN) {
      data->nbPoints = getNGQLPts(orderGauss);
      data->intPoints = getGQLPts(orderGauss);

      const int szSpace = order + 1;
      const int nGP = data->nbPoints;

      double *val = new double[szSpace];

      fullMatrix<double> M2(szSpace + 2, nGP + 2, true);
      {
        for(int j = 0; j < nGP; ++j) {
          basis.f(data->intPoints[j].pt[0], 0, 0, val);
          for(int i = 0; i < szSpace; ++i) {
            M2(i, j) = val[i] * data->intPoints[j].weight;
          }
        }
        M2(szSpace, nGP) = M2(szSpace + 1, nGP + 1) = 1;
      }

      fullMatrix<double> M1(szSpace + 2, szSpace + 2, true);
      {
        basis.integralfSquared(val);
        for(int k = 0; k < szSpace; ++k) M1(k, k) = val[k];

        basis.f(-1, 0, 0, val);
        for(int k = 0; k < szSpace; ++k)
          M1(szSpace, k) = M1(k, szSpace) = val[k];

        basis.f(1, 0, 0, val);
        for(int k = 0; k < szSpace; ++k)
          M1(szSpace + 1, k) = M1(k, szSpace + 1) = val[k];
      }
      fullMatrix<double> invM1;
      M1.invert(invM1);

      fullMatrix<double> Leg2Lag(szSpace, szSpace, true);
      {
        int tagLine = ElementType::getType(TYPE_LIN, order);
        const nodalBasis *fs = BasisFactory::getNodalBasis(tagLine);
        const fullMatrix<double> &refNodes = fs->getReferenceNodes();
        for(int i = 0; i < szSpace; ++i) {
          basis.f(refNodes(i, 0), 0, 0, val);
          for(int j = 0; j < szSpace; ++j) { Leg2Lag(i, j) = val[j]; }
        }
      }

      delete val;

      fullMatrix<double> tmp(szSpace + 2, nGP + 2, false);
      invM1.mult(M2, tmp);
      fullMatrix<double> tmp2(szSpace, nGP + 2, false);
      tmp2.copy(tmp, 0, szSpace, 0, nGP + 2, 0, 0);

      data->invA.resize(szSpace, nGP + 2, false);
      Leg2Lag.mult(tmp2, data->invA);
      return data;
    }

    else if(typeElement == TYPE_QUA) {
      data->nbPoints = getNGQQPts(orderGauss);
      data->intPoints = getGQQPts(orderGauss);

      fullMatrix<double> refNodes = gmshGeneratePointsQuadrangle(order);

      const int szSpace = (order + 1) * (order + 1);
      const int nGP = data->nbPoints;
      const int nConstraint = 4 * order;

      double *val = new double[szSpace];

      fullMatrix<double> M2(szSpace + nConstraint, nGP + nConstraint, true);
      {
        for(int j = 0; j < nGP; ++j) {
          basis.f(data->intPoints[j].pt[0], data->intPoints[j].pt[1], 0, val);
          for(int i = 0; i < szSpace; ++i) {
            M2(i, j) = val[i] * data->intPoints[j].weight;
          }
        }
        for(int i = 0; i < nConstraint; ++i) { M2(szSpace + i, nGP + i) = 1; }
      }

      fullMatrix<double> M1(szSpace + nConstraint, szSpace + nConstraint, true);
      {
        basis.integralfSquared(val);
        for(int k = 0; k < szSpace; ++k) M1(k, k) = val[k];

        for(int i = 0; i < nConstraint; ++i) {
          basis.f(refNodes(i, 0), refNodes(i, 1), 0, val);
          for(int k = 0; k < szSpace; ++k) {
            M1(szSpace + i, k) = M1(k, szSpace + i) = val[k];
          }
        }
      }
      fullMatrix<double> invM1;
      M1.invert(invM1);

      fullMatrix<double> Leg2Lag(szSpace, szSpace, true);
      {
        for(int i = 0; i < szSpace; ++i) {
          basis.f(refNodes(i, 0), refNodes(i, 1), 0, val);
          for(int j = 0; j < szSpace; ++j) { Leg2Lag(i, j) = val[j]; }
        }
      }

      delete val;

      fullMatrix<double> tmp(szSpace + nConstraint, nGP + nConstraint, false);
      invM1.mult(M2, tmp);
      fullMatrix<double> tmp2(szSpace, nGP + nConstraint, false);
      tmp2.copy(tmp, 0, szSpace, 0, nGP + nConstraint, 0, 0);

      data->invA.resize(szSpace, nGP + nConstraint, false);
      Leg2Lag.mult(tmp2, data->invA);
      return data;
    }

    else if(typeElement == TYPE_TRI) {
      data->nbPoints = getNGQTPts(orderGauss);
      data->intPoints = getGQTPts(orderGauss);

      fullMatrix<double> refNodes = gmshGeneratePointsTriangle(order);

      const int szSpace = (order + 1) * (order + 2) / 2;
      const int nGP = data->nbPoints;
      const int nConstraint = 3 * order;

      double *val = new double[szSpace];

      fullMatrix<double> M2(szSpace + nConstraint, nGP + nConstraint, true);
      {
        for(int j = 0; j < nGP; ++j) {
          basis.f(data->intPoints[j].pt[0], data->intPoints[j].pt[1], 0, val);
          for(int i = 0; i < szSpace; ++i) {
            M2(i, j) = val[i] * data->intPoints[j].weight;
          }
        }
        for(int i = 0; i < nConstraint; ++i) { M2(szSpace + i, nGP + i) = 1; }
      }

      fullMatrix<double> M1(szSpace + nConstraint, szSpace + nConstraint, true);
      {
        basis.integralfSquared(val);
        for(int k = 0; k < szSpace; ++k) M1(k, k) = val[k];

        for(int i = 0; i < nConstraint; ++i) {
          basis.f(refNodes(i, 0), refNodes(i, 1), 0, val);
          for(int k = 0; k < szSpace; ++k) {
            M1(szSpace + i, k) = M1(k, szSpace + i) = val[k];
          }
        }
      }
      fullMatrix<double> invM1;
      M1.invert(invM1);

      fullMatrix<double> Leg2Lag(szSpace, szSpace, true);
      {
        for(int i = 0; i < szSpace; ++i) {
          basis.f(refNodes(i, 0), refNodes(i, 1), 0, val);
          for(int j = 0; j < szSpace; ++j) { Leg2Lag(i, j) = val[j]; }
        }
      }

      delete val;

      fullMatrix<double> tmp(szSpace + nConstraint, nGP + nConstraint, false);
      invM1.mult(M2, tmp);
      fullMatrix<double> tmp2(szSpace, nGP + nConstraint, false);
      tmp2.copy(tmp, 0, szSpace, 0, nGP + nConstraint, 0, 0);

      data->invA.resize(szSpace, nGP + nConstraint, false);
      Leg2Lag.mult(tmp2, data->invA);
      return data;
    }
  }

  LeastSquareData *getLeastSquareData(int typeElement, int order,
                                      int orderGauss)
  {
    TupleLeastSquareData typeOrder(typeElement,
                                   std::make_pair(order, orderGauss));
    std::map<TupleLeastSquareData, LeastSquareData *>::iterator it;
    it = leastSquareData.find(typeOrder);

    if(it != leastSquareData.end()) return it->second;

    LeastSquareData *data =
      constructLeastSquareData(typeElement, order, orderGauss);
    leastSquareData[typeOrder] = data;
    return data;
  }

  bool computeCommonEdge(MElement *el1, MElement *el2, MEdge &e)
  {
    for(int i = 0; i < el1->getNumEdges(); ++i) {
      e = el1->getEdge(i);
      for(int j = 0; j < el2->getNumEdges(); ++j) {
        MEdge e2 = el2->getEdge(j);
        if(e == e2) return true;
      }
    }
    e = MEdge();
    return false;
  }

  void compute2DstackPrimaryVertices(const PairMElemVecMElem &column,
                                     std::vector<MVertex *> &stack)
  {
    MElement *bottomElement = column.first;
    const std::vector<MElement *> &stackElements = column.second;
    int numVertexPerLayer = 2;
    unsigned long numLayers = stackElements.size();
    stack.assign(numVertexPerLayer * numLayers, nullptr);

    int k = 0;
    for(int i = 0; i < numVertexPerLayer; ++i) {
      stack[k++] = bottomElement->getVertex(i);
    }
    MEdge bottomEdge = bottomElement->getEdge(0);
    for(std::size_t i = 0; i < numLayers - 1; ++i) {
      MElement *currentElement = stackElements[i];
      MEdge topEdge;
      if(!computeCommonEdge(currentElement, stackElements[i + 1], topEdge)) {
        Msg::Error("Did not find common edge");
      }

      // Eeach edge that is not the bottom edge nor the top edge links a bottom
      // node with the corresponding top node
      for(int j = 0; j < currentElement->getNumEdges(); ++j) {
        MEdge edge = currentElement->getEdge(j);
        if(edge == bottomEdge || edge == topEdge) continue;

        MVertex *vbot, *vtop;
        if(edge.getVertex(0) == bottomEdge.getVertex(0) ||
           edge.getVertex(0) == bottomEdge.getVertex(1)) {
          vbot = edge.getVertex(0);
          vtop = edge.getVertex(1);
        }
        else {
          vbot = edge.getVertex(1);
          vtop = edge.getVertex(0);
        }

        for(int l = k - numVertexPerLayer; l < k; ++l) {
          if(stack[l] == vbot) { stack[l + numVertexPerLayer] = vtop; }
        }
      }

      // If there remains NULL values, it is because the vertex is the same
      // on bottom face and top face.
      for(int l = k; l < k + numVertexPerLayer; ++l) {
        if(stack[l] == nullptr) { stack[l] = stack[l - numVertexPerLayer]; }
      }

      k += numVertexPerLayer;
      bottomEdge = topEdge;
    }
  }

  void computeStackHOEdgesFaces(const PairMElemVecMElem &column,
                                std::vector<MEdgeN> &stackEdges,
                                std::vector<MFaceN> &stackFaces)
  {
    const std::vector<MElement *> &stackElements = column.second;
    const int numElements = (int)stackElements.size();
    stackEdges.resize(numElements);
    stackFaces.resize(numElements);

    std::vector<MVertex *> primVert;
    compute2DstackPrimaryVertices(column, primVert);

    for(std::size_t i = 0; i < numElements; ++i) {
      MEdge e(primVert[2 * i + 0], primVert[2 * i + 1]);
      stackEdges[i] = stackElements[i]->getHighOrderEdge(e);
    }
    for(std::size_t i = 0; i < numElements - 1; ++i) {
      MFace face;
      if(primVert[2 * i + 0] == primVert[2 * i + 2])
        face =
          MFace(primVert[2 * i + 1], primVert[2 * i + 0], primVert[2 * i + 3]);
      else if(primVert[2 * i + 1] == primVert[2 * i + 3])
        face =
          MFace(primVert[2 * i + 0], primVert[2 * i + 1], primVert[2 * i + 2]);
      else
        face = MFace(primVert[2 * i + 0], primVert[2 * i + 1],
                     primVert[2 * i + 3], primVert[2 * i + 2]);
      stackFaces[i] = stackElements[i]->getHighOrderFace(face);
    }
    // We don't care about the orientation of the last element
    stackFaces.back() = stackElements.back()->getHighOrderFace(0, 0, 0);
  }

  bool edgesShareVertex(MEdgeN *e0, MEdgeN *e1)
  {
    MVertex *v = e0->getVertex(0);
    MVertex *v0 = e1->getVertex(0);
    if(v == v0) return true;
    MVertex *v1 = e1->getVertex(1);
    if(v == v1) return true;
    v = e0->getVertex(1);
    if(v == v0) return true;
    if(v == v1) return true;
    return false;
  }

  void repositionInnerVertices(const std::vector<MFaceN> &stackFaces,
                               const GFace *gface)
  {
    if(stackFaces.empty()) return;

    int order = stackFaces[0].getPolynomialOrder();
    const fullMatrix<double> *placementTri, *placementQua, *placement;

    placementTri = InnerVertPlacementMatrices::triangle(order, true);
    placementQua = InnerVertPlacementMatrices::quadrangle(order, true);

    for(std::size_t i = 0; i < stackFaces.size() - 1; ++i) {
      const MFaceN &face = stackFaces[i];
      if(face.getType() == TYPE_QUA)
        face.repositionInnerVertices(placementQua);
      else
        face.repositionInnerVertices(placementTri);
      if(gface) projectVerticesIntoGFace(&face, gface, false);
    }

    if(stackFaces.back().getType() == TYPE_QUA) {
      placement = InnerVertPlacementMatrices::quadrangle(order, false);
    }
    else {
      placement = InnerVertPlacementMatrices::triangle(order, false);
    }
    stackFaces.back().repositionInnerVertices(placement);
    if(gface) projectVerticesIntoGFace(&stackFaces.back(), gface, false);
  }

  bool curve2Dcolumn(PairMElemVecMElem &column, const GFace *gface,
                     const GEdge *gedge, const SVector3 &normal)
  {
    // This approach consists in:
    // 1. Curving the first edge not on the boundary of the geometry and
    //    the last edge of the column, using data from the edge on the boundary
    //    for both.
    // 2. In `recoverQualityElements`, checking that the curving computed
    //    in `1.` will allow to generate good quality elements.
    //    If this is not the case, the order and/or the curving
    //    of the last edge is reduced.
    // 3. In `curveEdgesAndPreserveQuality`, curving the other edges
    //    of the column and positioning the interior nodes of each element.
    //
    // Note: Here, either gface is defined and not normal, or the normal
    // is defined and not gface.

    if(column.second.size() < 2) return true;

    // Compute stack high order edges and faces
    std::vector<MEdgeN> stackEdges;
    std::vector<MFaceN> stackFaces;
    computeStackHOEdgesFaces(column, stackEdges, stackFaces);

    // Curve topEdge of first element and last edge
    int iFirst = 1, iLast = (int)stackEdges.size() - 1;
    MEdgeN *baseEdge = &stackEdges[0];
    MEdgeN *firstEdge = &stackEdges[iFirst];
    if(edgesShareVertex(baseEdge, firstEdge)) {
      iFirst = 2;
      firstEdge = &stackEdges[iFirst];
    }
    MEdgeN *topEdge = &stackEdges[iLast];

    // FIXME: (dev) hack for compilation
    Msg::Error("Should not be here calling curveEdge with Parameters() as first argument");
    EdgeCurver2D::curveEdge(Parameters(), baseEdge, firstEdge, gface, gedge, normal);
    EdgeCurver2D::curveEdge(Parameters(), baseEdge, topEdge, gface, gedge, normal);
    EdgeCurver2D::recoverQualityElements(stackEdges, stackFaces, column.second,
                                         iFirst, iLast, gface);

    // Curve interior edges and inner vertices
    InteriorEdgeCurver::curveEdgesAndPreserveQuality(
      stackEdges, stackFaces, column.second, iFirst, iLast, gface);
    return true;
  }

  void computeRelativePositions(const std::vector<MEdgeN> &stackEdges, std::vector<double> &relativePositions)
  {
    // FIXME: this is some basic code, need generalization for extrusion normal
    //        changing direction

    // Compute total thickness (left and right)
    const MEdgeN *baseEdge = &stackEdges[0];
    SVector3 v = stackEdges.back().pnt(-1) - baseEdge->pnt(-1);
    double thickness_left = v.norm();
    v = stackEdges.back().pnt(1) - baseEdge->pnt(1);
    double thickness_right = v.norm();

    // Compute ratios
    relativePositions.resize(stackEdges.size());
    relativePositions[0] = 0.0;
    for(auto i = 1; i < stackEdges.size(); ++i) {
      const MEdgeN *edge = &stackEdges[i];
      v = edge->pnt(-1) - baseEdge->pnt(-1);
      double ratio = v.norm() / thickness_left;
      v = edge->pnt(1) - baseEdge->pnt(1);
      relativePositions[i] = std::min(ratio, v.norm() / thickness_right);
    }
  }

  static std::map<MVertex*, SPoint3> dev_positionBoundaryVertices;

  bool curve2Dcolumn_newIdea(Parameters params, PairMElemVecMElem &column, const GFace *gface,
                             const GEdge *gedge, const SVector3 &normal)
  {
    // This approach consists in:
    // 1. Curving the edges of the column sequentially. For each, the data
    //    that is used to compute the curving is taken from the previous edge.
    // 2. Positioning the interior nodes of each element.
    //
    // Some quality checks will be needed but are not yet implemented (FIXME)
    //
    // Note: Here, either gface is defined and not normal, or the normal
    // is defined and not gface.

    if(column.second.size() < 2) return true;

    // Compute stack high order edges and faces
    std::vector<MEdgeN> stackEdges;
    std::vector<MFaceN> stackFaces;
    computeStackHOEdgesFaces(column, stackEdges, stackFaces);

    // Compute relative positions
    std::vector<double> relativePositions(stackEdges.size());
    computeRelativePositions(stackEdges, relativePositions);

    // Smooth first edge if requested
    // FIXME: Hack so that first edge go back to original position (for testing purpose)
    std: size_t numVertices = stackEdges[0].getNumVertices();
    for(size_t i = 0; i < numVertices; ++i) {
      MVertex *v = stackEdges[0].getVertex(i);

      if(dev_positionBoundaryVertices.find(v) == dev_positionBoundaryVertices.end()) {
        // xyz_boundary(i, 0) = v->x();
        // xyz_boundary(i, 1) = v->y();
        // xyz_boundary(i, 2) = v->z();
        dev_positionBoundaryVertices[v] = SPoint3(v->x(), v->y(), v->z());
      }
      else {
        SPoint3 p = dev_positionBoundaryVertices[v];
        v->x() = p.x();
        v->y() = p.y();
        v->z() = p.z();
      }
    }
    if(params.smoothBoundary) {
      applyQLPfilter(stackEdges[0]);
    }

    // Curve all edges
    for(auto i = 1; i < stackEdges.size(); ++i) {
      MEdgeN *next = nullptr;
      if(i+1 < stackEdges.size()) {
       next = &stackEdges[i+1];
      }
      EdgeCurver2D::curveEdge_newIdea(params, &stackEdges[i-1], &stackEdges[i], gface, normal, next, relativePositions[i]);
      // FIXME: Should we check the quality of first element? In which case, if
      //  the quality is not good, what do we do? I don't know for now
      // FIXME: (dev) this was for testing
      // EdgeCurver2D::curveEdge(params, &stackEdges[i-1], &stackEdges[i], gface, nullptr, normal);
      if(params.smoothIntermediate) applyQLPfilter(stackEdges[i]);
    }

    /*
     * TODO:
     *  0. store:
     *     - smoothingFactor = params.smoothEndOfBL
     *     - linearizationFactor = params.endLinearizationFactor
     *  1. Smooth last edge (if params.smoothEndOfBL=true)
     *  2. Linearize last edge (if linearizationFactor > 0)
     *  3. If ensureQualityOuterMesh is True, check the validity/quality of the
     *     last elements (exterior one) and increase smoothingFactor up to one,
     *     then linearizationFactor up to one until having a satisfying
     *     situation.
     *  4. Backpropagate: Smooth/Linearize edges with smoothingFactor and
     *                    linearizationFactor going from 0 at
     *                    params.backpropLimit to actual value for last edge
     */

    if(params.smoothEndOfBL) {
      // applyQLPfilter(stackEdges.back());

      std::size_t N = stackEdges.size();
      for(std::size_t i = 1; i < N; ++i) {
        double fact = relativePositions[i] * relativePositions[i];
        applyQLPfilter(stackEdges[i], fact);
      }
    }

    double gamma = params.endLinearizationFactor;
    double start = params.backpropLimit;
    int start_index = -1;
    int N = (int)stackEdges.size();
    if(gamma) {
      double coeff = 0, max_displ = 0;
      coeff = EdgeCurver2D::match_gamma_simpler(gamma, &stackEdges.back(), gface, normal);
      // max_displ = EdgeCurver2D::match_gamma_simpler2(gamma, &stackEdges.back(), gface, normal);
      std::cout << "coeff = " << coeff << std::endl;
      for(int i = 1; i < N - 1; ++i) {
        double c = 0;
        double dx = 0;
        if(relativePositions[i] > start) {
          c = coeff / (1 - start) * (relativePositions[i] - start);
          dx = max_displ / (1 - start) * (relativePositions[i] - start);
          // if(start_index == -1) start_index = i - 1;
          // c = coeff / (N-1 - start_index) * (i - start_index);
          // dx = max_displ / (N-1 - start_index) * (i - start_index);
          std::cout << "c[" << i << "] = " << c << std::endl;
        }
        // EdgeCurver2D::linearize(c, &stackEdges[i], gface, normal);
        EdgeCurver2D::_reduceCurving(&stackEdges[i], c, gface);
        // EdgeCurver2D::_reduceCurving2(&stackEdges[i], dx, gface);
    if(params.endLinearizationFactor > 0.0) {
      InteriorEdgeCurver::linearizeEndOfBL(params, stackEdges, relativePositions, gface, normal);
    }

      }
    }
    // Reduce curving based on

      //     =>  L = (L_lin + L_disc) / 2
      //         Z = sum |x_i-z_i| / (N-1) (car Simpson)
      //         R = (1 - 2*Z/L) ** 4
      //         R >= gamma

    repositionInnerVertices(stackFaces, gface);

    // FIXME: Should we check the quality of all the elements?
    return true;
  }

  bool dev_change_normals(PairMElemVecMElem &column, const GFace *gface,
                             const GEdge *gedge, const SVector3 &normal)
  {

    if(column.second.size() < 2) return true;
    if(column.second.size() > 20) return true;

    // Compute stack high order edges and faces
    std::vector<MEdgeN> stackEdges;
    std::vector<MFaceN> stackFaces;
    computeStackHOEdgesFaces(column, stackEdges, stackFaces);

    //
    MVertex *v0 = stackEdges[0].getVertex(0);
    MVertex *v = stackEdges[1].getVertex(0);
    //double thick = norm3(v->point() - v0->point());
    double x = v->x() - v0->x();// = v->x() + (rand() % 1001 - 500) / 500. * thick / 2;
    double y = v->y() - v0->y();// = v->y() + (rand() % 1001 - 500) / 500. * thick / 2;
    double angle = atan2(y, x);
    std::vector<double> lengths(stackEdges.size()-1);
    for(auto i = 0; i < lengths.size(); ++i) {
      MVertex *v0 = stackEdges[i].getVertex(0);
      MVertex *v = stackEdges[i+1].getVertex(0);
      // double x = v->x();
      // double y = v->y();
      lengths[i] = norm3(v->point() - v0->point());
    }
    for(auto i = 1; i < stackEdges.size(); ++i) {
      double this_angle = angle + (rand() % 1001 - 500) / 500. * M_PI / 3.5;
      double this_length = lengths[i-1] * ((rand() % 1001) / 1000. * 1.5 + .5);
      MVertex *v0 = stackEdges[i-1].getVertex(0);
      MVertex *v = stackEdges[i].getVertex(0);
      v->x() = v0->x() + this_length * std::cos(this_angle);
      v->y() = v0->y() + this_length * std::sin(this_angle);
      std::vector<MVertex *> vert = stackFaces[i-1].getVertices();
      vert[19]->x() = 1./6 * v0->x() + 5./6 * v->x();
      vert[19]->y() = 1./6 * v0->y() + 5./6 * v->y();
      vert[20]->x() = 2./6 * v0->x() + 4./6 * v->x();
      vert[20]->y() = 2./6 * v0->y() + 4./6 * v->y();
      vert[21]->x() = 3./6 * v0->x() + 3./6 * v->x();
      vert[21]->y() = 3./6 * v0->y() + 3./6 * v->y();
      vert[22]->x() = 4./6 * v0->x() + 2./6 * v->x();
      vert[22]->y() = 4./6 * v0->y() + 2./6 * v->y();
      vert[23]->x() = 5./6 * v0->x() + 1./6 * v->x();
      vert[23]->y() = 5./6 * v0->y() + 1./6 * v->y();
    }
    return true;
  }

  SVector3 computeBisector(const SVector3 &u0, const SVector3 &u1, const SVector3 &v)
  {
    // Normalize the input vectors
    SVector3 n0 = u0.unit();
    SVector3 n1 = u1.unit();

    // Compute the unnormalized bisector
    SVector3 bisector = n0 + n1;

    // FIXME if bisector == 0

    // Ensure the bisector is in the same direction as 'v'
    if(dot(bisector, v) < 0.0) {
      bisector *= -1;
    }

    // bisector.normalize();
    // bisector *= v.norm();

    return bisector.unit();
  }


  bool dev_reorient_normals(VecPairMElemVecMElem &columns, const GFace *gface,
                             const GEdge *gedge, const SVector3 &normal)
  {
    for(auto &column : columns) {
      if(column.second.size() > 20) continue;
      // std::cout << column.second.size() << std::endl;
      for(auto &column_other : columns) {
        if(&column == &column_other) continue;
        MElement *el0 = column.second[0];
        MElement *el1 = column_other.second[0];
        MEdge e;
        if(!computeCommonEdge(el0, el1, e)) continue;

        MElement *b0 = column.first;
        MElement *b1 = column_other.first;
        const MEdgeN e0 = b0->getHighOrderEdge(b0->getEdge(0));
        const MEdgeN e1 = b1->getHighOrderEdge(b1->getEdge(0));
        MVertex *v_common = nullptr;
        for(int i = 0; i < 2; ++i) {
          if(e0.getVertex(i) == e1.getVertex(0) || e0.getVertex(i) == e1.getVertex(1)) {
            v_common = e0.getVertex(i);
            break;
          }
        }
        if(!v_common) {
          std::cerr << "Error: no common vertex between columns" << std::endl;
        }


        SVector3 u0, u1, v;
        for(int i = 0; i < 2; ++i) {
          if(e.getVertex(i) != v_common) {
            v = e.getVertex(i)->point() - v_common->point();
          }
        }

        int polyo = e0.getPolynomialOrder();
        if(e0.getVertex(0) == v_common) {
          u0 = e0.getVertex(2)->point() - v_common->point();
        }
        else {
          u0 = e0.getVertex(polyo)->point() - v_common->point();
        }
        if(e1.getVertex(0) == v_common) {
          u1 = e1.getVertex(2)->point() - v_common->point();
        }
        else {
          u1 = e1.getVertex(polyo)->point() - v_common->point();
        }

        SVector3 bisector = computeBisector(u0, u1, v);

        SPoint3 p0 = v_common->point(), p1;
        MVertex *v0 = v_common;

        std::vector<MElement*> stack;
        MEdge bottomEdge;
        if(column.second.size() > column_other.second.size()) {
          stack = column.second;
          bottomEdge = b0->getEdge(0);
        }
        else {
          stack = column_other.second;
          bottomEdge = b1->getEdge(0);
        }

        for(int i = 0; i < (int)stack.size()-1; ++i) {
          MElement *el = stack[i];
          MEdge e;
          for(int j = 0; j < 4; ++j) {
            e = el->getEdge(j);
            if(e == bottomEdge) continue;
            if(e.getVertex(0) == v0 || e.getVertex(1) == v0) break;
          }
          MVertex *other_v = nullptr;
          for(int j = 0; j < 2; ++j) {
            if(e.getVertex(j) != v0) { // `e(j)` gives the vertices of the edge
              other_v = e.getVertex(j);
              break;
            }
          }
          if(!other_v) {
            std::cerr << "Error: no other vertex found" << std::endl;
          }

          p1 = other_v->point();
          SVector3 v01 = p1 - p0;
          double length = v01.norm();

          // Compute the new position for `other_v`
          SPoint3 new_position = v0->point() + bisector * length; // v0 + bisector vector

          // Update the position of `other_v` to the new position
          other_v->setXYZ(new_position.x(), new_position.y(), new_position.z());

          // Advance v0 to the newly repositioned vertex
          v0 = other_v;
          p0 = p1;

          // Interior nodes
          MEdgeN e_ho = el->getHighOrderEdge(e);
          for(int j = 2; j < polyo+1; ++j) {
            double f = static_cast<double>(j-1) / polyo;
            double x = (1-f) * e_ho.getVertex(0)->x() + f * e_ho.getVertex(1)->x();
            double y = (1-f) * e_ho.getVertex(0)->y() + f * e_ho.getVertex(1)->y();
            double z = (1-f) * e_ho.getVertex(0)->z() + f * e_ho.getVertex(1)->z();
            e_ho.getVertex(j)->setXYZ(x, y, z);
          }

          computeCommonEdge(stack[i+1], el, bottomEdge);
        }
      }
    }
  }

  bool dev_touch_boundary(PairMElemVecMElem &column, const GFace *gface,
                             const GEdge *gedge, const SVector3 &normal)
  {
    if(column.second.size() < 2) return true;

    // Compute stack high order edges and faces
    std::vector<MEdgeN> stackEdges;
    std::vector<MFaceN> stackFaces;
    computeStackHOEdgesFaces(column, stackEdges, stackFaces);

    MEdgeN &edge = stackEdges[0];
    int polyo = edge.getPolynomialOrder();

    // Compute L_discrete
    double L_disc = 0;
    double vx, vy, vz;

    vx = edge.getVertex(2)->x() - edge.getVertex(0)->x();
    vy = edge.getVertex(2)->y() - edge.getVertex(0)->y();
    vz = edge.getVertex(2)->z() - edge.getVertex(0)->z();
    L_disc = sqrt(vx * vx + vy * vy + vz * vz);

    vx = edge.getVertex(1)->x() - edge.getVertex(polyo)->x();
    vy = edge.getVertex(1)->y() - edge.getVertex(polyo)->y();
    vz = edge.getVertex(1)->z() - edge.getVertex(polyo)->z();
    L_disc += sqrt(vx * vx + vy * vy + vz * vz);

    for(int i = 2; i < polyo; ++i) {
      vx = edge.getVertex(i+1)->x() - edge.getVertex(i)->x();
      vy = edge.getVertex(i+1)->y() - edge.getVertex(i)->y();
      vz = edge.getVertex(i+1)->z() - edge.getVertex(i)->z();
      L_disc += std::sqrt(vx*vx + vy*vy + vz*vz);
    }

    double pert = L_disc / polyo / 10;

    for(int i = 2; i < polyo + 1; ++i) {
      MVertex *v = edge.getVertex(i);
      v->x() += pert * (rand() % 1001 - 500) / 500.;
      v->y() += pert * (rand() % 1001 - 500) / 500.;
      v->z() += pert * (rand() % 1001 - 500) / 500.;
    }
    return true;
  }
} // namespace BoundaryLayerCurver

void curve2DBoundaryLayer(BoundaryLayerCurver::Parameters params,
                          VecPairMElemVecMElem &bndEl2column, SVector3 normal,
                          const GEdge *gedge)
{
  // TODO:
  //  1. Check if easy to include to GUI. Include to GUI or make usable by script
  //  2. Create class for parameters:
  //     - skip ensuring good quality element touching the BLM
  //     - how much reduce curving last layer (by smoothing)
  //     - how much last layer should be close to linearity
  //       => reduce curving for meeting all three conditions
  //     - % of thickness of high quality elements (if possible)
  //     - how much to force continuity between elements
  //  3. Implement quality check
  //     - at forward stage
  //     - at backward stage
  //  4. Implement better reducing of curving inside BLM
  //  5. Push to Git

  // TODO Later:
  //   Implement triangles
  //   Implement suface BL
  //   Clean the code

  double length = normal.normalize();
  if(length == 0) {
    Msg::Error("normal must be non-zero for boundary layer curving");
    return;
  }

  // Hack for making pictures without HO vertices of triangles
  {
    if(normal.z() < .5) {
      normal *= -1; // FIXME Hack for making work msh quad HO
    }

    if(bndEl2column.empty()) return;

    std::unordered_set<MVertex*> vertices_to_keep;
    for(auto gface = GModel::current()->firstFace(); gface != GModel::current()->lastFace(); ++gface) {
      std::vector<MQuadrangle*> quadrangles = (*gface)->quadrangles;
      for(auto quad : quadrangles) {
        int num_vert = quad->getNumVertices();
        for(int i = 0; i < num_vert; ++i) {
          MVertex *v = quad->getVertex(i);
          vertices_to_keep.insert(v);
        }
      }
    }

    for(auto gface = GModel::current()->firstFace(); gface != GModel::current()->lastFace(); ++gface) {
      std::vector<MTriangle*> triangles = (*gface)->triangles;
      std::vector<MTriangle*> triangles_toKeep;
      for(auto triangle : triangles) {
        int num_vert = triangle->getNumVertices();
        int polyo = triangle->getPolynomialOrder();
        for(int i = 0; i < 3*polyo; ++i) {
          MVertex *v = triangle->getVertex(i);
          if (vertices_to_keep.find(v) != vertices_to_keep.end()) {
            triangles_toKeep.push_back(triangle);
            break;
          }
        }
        for(int i = 3*polyo; i < num_vert; ++i) {
          MVertex *v = triangle->getVertex(i);
          v->setXYZ(-100, -100, 0);
        }
      }
      // (*gface)->triangles.clear(); // FIXME Hack for visu
      (*gface)->triangles = triangles_toKeep; // FIXME Hack for visu

      std::vector<MVertex*> vertices = (*gface)->mesh_vertices;

      std::vector<MVertex*> vertices_to_remove;
      for (MVertex *v : vertices) {
        if (vertices_to_keep.find(v) == vertices_to_keep.end()) {
          vertices_to_remove.push_back(v);
        }
      }

      std::cout << "Removing " << vertices_to_remove.size() << " vertices" << std::endl;

      for(auto &v : vertices_to_remove) {
        v->setXYZ(-100, -100, 0);
      }
    }
  }

  //  for (int i = 0; i < bndEl2column.size(); ++i) {
  //    bndEl2column[i].first->setVisibility(1);
  //    for (std::size_t j = 0; j < bndEl2column[i].second.size(); ++j) {
  //      bndEl2column[i].second[j]->setVisibility(1);
  //    }
  //  }

  // for(int i = 0; i < bndEl2column.size(); ++i) {
  //   BoundaryLayerCurver::dev_touch_boundary(bndEl2column[i], nullptr, gedge, normal);
  // }

  // for(int i = 0; i < bndEl2column.size(); ++i) {
  //   BoundaryLayerCurver::dev_change_normals(bndEl2column[i], nullptr, gedge, normal);
  // }

  // BoundaryLayerCurver::dev_reorient_normals(bndEl2column, nullptr, gedge, normal);

  for(int i = 0; i < bndEl2column.size(); ++i) {
    // if (bndEl2column[i].first->getNum() != 205) continue; // t161
    // if (bndEl2column[i].first->getNum() != 316) continue; // t161
    // if (bndEl2column[i].first->getNum() != 1156) continue; // trimesh
    // std::cout << bndEl2column[i].first->getNum() << std::endl;
    // if (   bndEl2column[i].first->getNum() != 1156
        // && bndEl2column[i].first->getNum() != 1079
        // && bndEl2column[i].first->getNum() != 1102
        // && bndEl2column[i].first->getNum() != 1119) continue;
    // if (   bndEl2column[i].first->getNum() != 1156) continue;
    // if (   bndEl2column[i].first->getNum() != 1157) continue;
    // std::cout << std::endl;
    // std::cout << "column " << bndEl2column[i].first->getNum() << std::endl;
    // if (bndEl2column[i].first->getNum() != 1079) continue; // Good
    // if (bndEl2column[i].first->getNum() != 1078) continue; // Next to good
    // if (bndEl2column[i].first->getNum() != 1099) continue; // Long on corner
    // if (bndEl2column[i].first->getNum() != 1102) continue; // HO
    // if (bndEl2column[i].first->getNum() != 1136) continue; // Bad linear
    // if (bndEl2column[i].first->getNum() != 1149) continue; // shorter
    // if (bndEl2column[i].first->getNum() != 1150) continue; // concave
    // if (bndEl2column[i].first->getNum() != 1151) continue; // symetric of concave
    // if (bndEl2column[i].first->getNum() != 1156) continue; // Strange
    // if (bndEl2column[i].first->getNum() != 1157) continue; // next to Strange
    // if (bndEl2column[i].first->getNum() != 6994) continue; // HO -> trailingL2
    // BoundaryLayerCurver::curve2Dcolumn(bndEl2column[i], nullptr, gedge, normal);
    //if (bndEl2column[i].first->getNum() != 12882) continue;
    BoundaryLayerCurver::curve2Dcolumn_newIdea(params, bndEl2column[i], nullptr, gedge, normal);
  }
}

void curve2DBoundaryLayer(BoundaryLayerCurver::Parameters params,
                          VecPairMElemVecMElem &bndEl2column,
                          const GFace *gface, const GEdge *gedge)
{
  if(!gface || !gedge) {
    Msg::Error("both gface and gedge are needed for boundary layer curving "
               "(%d, %d)",
               gface, gedge);
    return;
  }

  //  for (int i = 0; i < bndEl2column.size(); ++i) {
  //    bndEl2column[i].first->setVisibility(1);
  //    for (std::size_t j = 0; j < bndEl2column[i].second.size(); ++j) {
  //      bndEl2column[i].second[j]->setVisibility(1);
  //    }
  //  }

  for(int i = 0; i < bndEl2column.size(); ++i)
//    BoundaryLayerCurver::curve2Dcolumn(bndEl2column[i], gface, gedge,
//                                       SVector3());
    BoundaryLayerCurver::curve2Dcolumn_newIdea(params, bndEl2column[i], nullptr, gedge,
                                       SVector3());
}
