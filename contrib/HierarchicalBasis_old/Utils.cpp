// Gmsh - Copyright (C) 1997-2025 C. Geuzaine, J.-F. Remacle
//
// See the LICENSE.txt file in the Gmsh root directory for license information.
// Please report all issues on https://gitlab.onelab.info/gmsh/gmsh/issues.

#include <vector>
#include <unordered_set>
#include <string>
#include "GmshMessage.h"
#include "ElementType.h"
#include "Utils.h"
#include "MVertex.h"
#include "MElement.h"

void validateWantedOrientations(const std::vector<int>& wantedOrientations,
                                int maxOrientation,
                                const std::string& fsName,
                                const int familyType) {
    if (wantedOrientations.empty()) {
        return;
    }
    if (wantedOrientations.size() > static_cast<size_t>(maxOrientation)) {
        Msg::Error("Asking for more orientation that there exist (max allowed: %d)", maxOrientation);
        return;
    }
    std::unordered_set<int> uniqueOrientations;
    for (int ori : wantedOrientations) {
        if (ori < 0 || ori >= maxOrientation) {
            Msg::Error("Orientation %d does not exist for function space named '%s' on %s", ori, fsName.c_str(), ElementType::nameOfParentType(familyType, true).c_str());
            return;
        }

        if (!uniqueOrientations.insert(ori).second) {
            Msg::Error("Duplicate wanted orientation %d found", ori);
            return;
        }
    }
}

// Update Element Vertices With Next Permutation

void updateElementVerticesWithNextPermutation(std::vector<MVertex*>& vertices, MElement* element)
{
    MVertexPtrLessThan comp; /* struct MVertexPtrLessThan {
                              bool operator()(const MVertex *v1 , const MVertex *v2) const { return v1->getNum() < v2->getNum(); }  }; */
    
    std::next_permutation(vertices.begin(), vertices.end(), comp); // Generates the next permutation based on the increasing order of getNum() values.
                                                                   //Ex: 2 5 8 -> 2 8 5 -> 5 2 8 -> 5 8 2 -> 8 2 5 -> 8 5 2
    unsigned int numVertices = vertices.size();
    for (unsigned int i = 0; i < numVertices; ++i)
    {
        element->setVertex(i, vertices[i]); // Updates element->_Vertex[i] with vertices[i] generated by next_permutation.
    }
}
