// Gmsh - Copyright (C) 1997-2024 C. Geuzaine, J.-F. Remacle
//
// See the LICENSE.txt file in the Gmsh root directory for license information.
// Please report all issues on https://gitlab.onelab.info/gmsh/gmsh/issues.
//
// Contributed by Ismail Badia (2019) and Nawfel BENATIA (2025).

// Reference : Solin, P., Segeth, K., & Dolezel, I. (2003).
//             Higher-Order Finite Element Methods (1st ed.).
//             Chapman and Hall/CRC. https://doi.org/10.1201/9780203488041

#ifndef HIERARCHICAL_BASIS_H
#define HIERARCHICAL_BASIS_H

#include <vector>
#include <algorithm>
#include <cassert>
#include <array>
#include <utility>  // For std::pair


#include "OrthogonalPoly.h"

class HierarchicalBasis {
protected:
    //Number of Geometric Entities :
    int _numVertex;
    int _numEdge;
    int _numQuadFace;     // number of quadrilateral faces
    int _numTriFace;      // number of triangular faces
    
    //Number of shape (basis) functions :
    int _numVertexFunction;
    int _numEdgeFunction;
    int _numQuadFaceFunction;
    int _numTriFaceFunction;
    int _numBubbleFunction;
    
    // to be used in addAllOrientedFaceFunctions
    virtual void orientOneFace(double const &u, double const &v, double const &w,
                               int const &flag1, int const &flag2, int const &flag3,
                               int const &faceNumber, std::vector<double> &faceFunctions) = 0;
    
    virtual void orientOneFace(double const &u, double const &v, double const &w,
                               int const &flag1, int const &flag2, int const &flag3,
                               int const &faceNumber, std::vector<std::vector<double> > &faceFunctions, std::string typeFunction) = 0;
    // typeFunction = GradH1Legendre, HcurlLegendre, curlHcurlLegendre
    
    HierarchicalBasis() = default;
    
public:
    virtual ~HierarchicalBasis() = 0;
    
    virtual unsigned int getNumberOfOrientations() const = 0;
    
    virtual void generateBasis(double const &u, double const &v, double const &w,
                               std::vector<double> &vertexBasis,
                               std::vector<double> &edgeBasis,
                               std::vector<double> &faceBasis,
                               std::vector<double> &bubbleBasis,
                               std::string typeFunction) = 0; // typeFunction = H1Legendre, DivHdivLegendre
    
    virtual void generateBasis(double const &u, double const &v, double const &w,
                               std::vector<std::vector<double> > &vertexBasis,
                               std::vector<std::vector<double> > &edgeBasis,
                               std::vector<std::vector<double> > &faceBasis,
                               std::vector<std::vector<double> > &bubbleBasis,
                               std::string typeFunction) = 0; // typeFunction = GradH1Legendre, HcurlLegendre, curlHcurlLegendre, HdivLegendre
        
    virtual void orientEdgeFunctionsForNegativeFlag(std::vector<double> &edgeFunctions) = 0;
    virtual void orientEdgeFunctionsForNegativeFlag(std::vector<std::vector<double> > &edgeFunctions) = 0;

    /*
     * The "orientEdge" method use the edge functions stored in :
     *           "eTablePositiveFlag", which is generated by the "generateBasis" method;
     *           "eTableNegativeFlag", which is generated by the "orientEdgeFunctionsForNegativeFlag" method.
     *      The output is : "edgeFunctions"
     */
    virtual void orientEdge(int const &flagOrientation, int const &edgeNumber,
                            std::vector<double> &edgeFunctions,
                            const std::vector<double> &eTablePositiveFlag,
                            const std::vector<double> &eTableNegativeFlag) = 0;
    virtual void orientEdge(int const &flagOrientation, int const &edgeNumber,
                            std::vector<std::vector<double> > &edgeBasis,
                            const std::vector<std::vector<double> > &eTablePositiveFlag,
                            const std::vector<std::vector<double> > &eTableNegativeFlag) = 0;
    
    virtual void addAllOrientedFaceFunctions(double const &u, double const &v, double const &w,
                                             const std::vector<double> &faceFunctions,
                                             std::vector<double> &quadFaceFunctionsAllOrientation,
                                             std::vector<double> &triFaceFunctionsAllOrientation) = 0;
    virtual void addAllOrientedFaceFunctions(double const &u, double const &v, double const &w,
                                             const std::vector<std::vector<double> > &faceFunctions,
                                             std::vector<std::vector<double> > &quadFaceFunctionsAllOrientation,
                                             std::vector<std::vector<double> > &triFaceFunctionsAllOrientation,
                                             std::string typeFunction) = 0; // typeFunction =GradH1Legendre , HcurlLegendre, curlHcurlLegendre
    
    /*
     * Use the face functions stored in quadFaceFunctionsAllOrientations and
     * triFaceFunctionsAllOrientations, which are generated by the
     * addAllOrientedFaceFunctions method.
     */
    virtual void orientFace(int const &flag1, int const &flag2, int const &flag3, int const &faceNumber,
                            const std::vector<double> &quadFaceFunctionsAllOrientation,
                            const std::vector<double> &triFaceFunctionsAllOrientation,
                            std::vector<double> &fTableCopy) = 0;
    virtual void orientFace(int const &flag1, int const &flag2, int const &flag3, int const &faceNumber,
                            const std::vector<std::vector<double> > &quadFaceFunctionsAllOrientation,
                            const std::vector<std::vector<double> > &triFaceFunctionsAllOrientation,
                            std::vector<std::vector<double> > &fTableCopy) = 0;
        
    // Get information about the `keys' defined in GMSH API for one element
    virtual void getKeysInfo(std::vector<int> &functionTypeInfo, std::vector<int> &orderInfo) = 0;
    
    inline int getNumEdge() const { return _numEdge; }
    inline int getNumTriFace() const { return _numTriFace; }
    inline int getNumQuadFace() const { return _numQuadFace; }
    
    inline int getNumVertexFunction() const { return _numVertexFunction; }
    inline int getNumEdgeFunction() const { return _numEdgeFunction; }
    inline int getNumTriFaceFunction() const { return _numTriFaceFunction; }
    inline int getNumQuadFaceFunction() const { return _numQuadFaceFunction; }
    inline int getNumBubbleFunction() const { return _numBubbleFunction; }
        
    inline int getOrientationQuadFaceIndex(int flag1, int flag2, int flag3) {
        // Ensure all flags are either +1 or -1
        assert((flag1 == 1 || flag1 == -1) &&
               (flag2 == 1 || flag2 == -1) &&
               (flag3 == 1 || flag3 == -1));
        
        // Each flag is either -1 or 1, mapped to 1 or 0 respectively
        int i = (flag1 == -1) ? 1 : 0;
        int j = (flag2 == -1) ? 1 : 0;
        int k = (flag3 == -1) ? 1 : 0;
        
        // Produces a unique index in the range [0, 7]
        // Equivalent to: i + j * 2 + k * 4
        return  i | (j << 1) | (k << 2);
    }
    
    // used in orientFace
    inline int getOrientationTriFaceIndex(int flag1, int flag2) {
        // Ensure flag1 is 0, 1, or 2, and flag2 is either +1 or -1
        assert((flag1 == 0 || flag1 == 1 || flag1 == 2) &&
               (flag2 == 1 || flag2 == -1));
        
        // Map flag2: +1 → 0, -1 → 1
        int f = (flag2 == -1) ? 1 : 0;
        
        // Produces a unique index in the range [0, 5]
        return flag1 + f * 3;
    }
    
    // to be used in addAllOrientedFaceFunctions : 
    inline static std::array<int, 3> getQuadFaceFlagsFromIndex(int index) {
        assert(index >= 0 && index < 8);
        int i = index & 1;
        int j = (index >> 1) & 1;
        int k = (index >> 2) & 1;
        return { (i == 1 ? -1 : 1), (j == 1 ? -1 : 1), (k == 1 ? -1 : 1) };
    }
    
    inline static std::array<int, 2> getTriFaceFlagsFromIndex(int index) {
        assert(index >= 0 && index < 6);
        int flag1 = index % 3;                // values: 0, 1, 2
        int flag2 = (index < 3) ? 1 : -1;     // first 3 → +1, last 3 → -1
        return { flag1, flag2 };
    }
};

inline HierarchicalBasis::~HierarchicalBasis() = default;


/*
 Mapping of flags to QuadFaceIndex:

 flag1   flag2   flag3   <--->   index
  +1      +1      +1     <--->     0
  -1      +1      +1     <--->     1
  +1      -1      +1     <--->     2
  -1      -1      +1     <--->     3
  +1      +1      -1     <--->     4
  -1      +1      -1     <--->     5
  +1      -1      -1     <--->     6
  -1      -1      -1     <--->     7

 Mapping of flags to TriFaceIndex:

 flag1   flag2   <--->   index
   0      +1     <--->     0
   1      +1     <--->     1
   2      +1     <--->     2
   0      -1     <--->     3
   1      -1     <--->     4
   2      -1     <--->     5

 */
   
#endif
