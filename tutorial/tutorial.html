<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Enscript Output</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<H1>Contents</H1>
<OL>
  <LI><A HREF="#file1">README</A>
  <LI><A HREF="#file2">t1.geo</A>
  <LI><A HREF="#file3">t2.geo</A>
  <LI><A HREF="#file4">t3.geo</A>
  <LI><A HREF="#file5">t4.geo</A>
  <LI><A HREF="#file6">t5.geo</A>
  <LI><A HREF="#file7">t6.geo</A>
  <LI><A HREF="#file8">t7.geo</A>
  <LI><A HREF="#file9">t8.geo</A>
  <LI><A HREF="#file10">t9.geo</A>
</OL>
<HR>
<A NAME="file1">
<H1>README 1/10</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
$Id: tutorial.html,v 1.17 2001-08-04 01:17:28 geuzaine Exp $

Here are the examples in the Gmsh tutorial. These examples are
commented (both C and C++-style comments can be used in Gmsh input
files) and should introduce new features gradually, starting with
t1.geo.

[NOTE: This tutorial does not explain the mesh and post-processing
file formats. See the FORMATS file for this.]

There are two ways to actually run these examples with Gmsh. (The
operations to run Gmsh may vary according to your operating system. In
the folowing examples, we will assume that you're working with a
UNIX-like shell.) The first working mode of Gmsh is the interactive
graphical mode. To launch Gmsh in interactive mode, just type

&gt; gmsh

at the prompt on the command line. This will open two windows: the
graphic window (with a status bar at the bottom) and the menu window
(with a menu bar and some context dependent buttons). To open the
first tutorial file, select the 'File-&gt;Open' menu, and choose 't1.geo'
in the input field. To perform the mesh generation, go to the mesh
module (by selecting 'Mesh' in the module menu) and choose the
required dimension in the context-dependent buttons ('1D' will mesh
all the curves; '2D' will mesh all the surfaces ---as well as all the
curves if '1D' was not called before; '3D' will mesh all the volumes
---and all the surfaces if '2D' was not called before). To save the
resulting mesh in the current mesh format, choose 'Save' in the
context-dependent buttons, or select the appropriate format with the
'File-&gt;Save as' menu. The default mesh file name is based on the name
of the first input file on the command line (or 'unnamed' if there
wasn't any input file given), with an appended extension depending on
the mesh format.

[NOTE: Nearly all the interactive commands have shortcuts. Select
'Help-&gt;Shortcuts' in the menu bar to learn about these shortcuts.]

Instead of opening the tutorial with the 'File-&gt;Open' menu, it is
often more convenient to put the file name on the command line, for
example with:

&gt; gmsh t1.geo

[NOTE: The '.geo' extension can also be omitted.]

[NOTE: Even if it is often handy to define the variables and the points
directly in the input files (you may use any text editor for this
purpose, e.g. Wordpad on Windows, or Emacs on Unix), it is almost
always more simple to define the curves, the surfaces and the volumes
interactively. To do so, just follow the context dependent buttons in
the Geometry module. For example, to create a line, select 'Geometry'
in the module menu, and then select 'Elementary, Add, Create,
Line'. You will then be asked (in the status bar of the graphic
window) to select a list of points, and to click 'e' to finish the
selection (or 'q' to abort it). Once the interactive command is
completed, a string is automatically added at the end of the currently
opened project file.]

The second operating mode for Gmsh is the non-interactive mode. In
this mode, there is no graphical user interface, and all operations
are performed without any interaction. To mesh the first tutorial in
non-interactive mode, just type:

&gt; gmsh t1.geo -2

To mesh the same example, but with the backgound mesh available in the
file 'bgmesh.pos', just type:

&gt; gmsh t1.geo -2 -bgm bgmesh.pos

[NOTE: You should read the notes in the file 'bgmesh.pos' if you
intend to use background meshes.]

Several files can be loaded simultaneously in Gmsh. The first one
defines the project, while the others are appended (&quot;merged&quot;) to this
project. You can merge such files with the 'File-&gt;Merge' menu, or by
directly specifying the names of the files on the command line. This
is most useful for post-processing purposes. For example, to merge the
post-processing views contained in the files 'view1.pos' and
'view2.pos' together with the first tutorial 't1.geo', you can type
the following line on the command line:

&gt; gmsh t1.geo view1.pos view2.pos

In the Post-Processing module (select 'Post_Processing' in the module
menu), two view buttons will appear, respectively labeled &quot;a scalar
map&quot; and &quot;a vector map&quot;. A left mouse click toggles the visibility of
the selected view. A right mouse click provides access to the view's
options. If you want the modifications made to one view to affect also
all the other views, select the 'Apply next changes to all views' or
'Force same options for all views' option in the
'Options-&gt;Post-processing' menu.

[NOTE: All the options specified interactively can also be directly
specified in the ascii input files. All available options, with their
current values, can be saved into a file by selecting 'File-&gt;Save
as-&gt;GEO complete options', or simply viewed by pressing the '?' button
in the status bar. To save the current options as your default
preferences for all future Gmsh sessions, use the 'Options-&gt;Save
options now' menu.]


OK, that's all, folks. Enjoy the tutorial.

</PRE>
<HR>
<A NAME="file2">
<H1>t1.geo 2/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 1
 * 
 *  Variables, Elementary entities (Points, Lines, Surfaces), Physical
 *  entities (Points, Lines, Surfaces), Background mesh
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// All geometry description in Gmsh is made by means of a special
</FONT></I><I><FONT COLOR="#B22222">// language (looking somewhat similar to C). The simplest construction
</FONT></I><I><FONT COLOR="#B22222">// of this language is the 'affectation'. 
</FONT></I>
<I><FONT COLOR="#B22222">// The following command (all commands end with a semi colon) defines
</FONT></I><I><FONT COLOR="#B22222">// a variable called 'lc' and affects the value 0.007 to 'lc':
</FONT></I>
lc = 0.007 ;

<I><FONT COLOR="#B22222">// This newly created variable can be used to define the first Gmsh
</FONT></I><I><FONT COLOR="#B22222">// elementary entity, a 'Point'. A Point is defined by a list of four
</FONT></I><I><FONT COLOR="#B22222">// numbers: its three coordinates (x, y and z), and a characteristic
</FONT></I><I><FONT COLOR="#B22222">// length which sets the target mesh size at the point:
</FONT></I>
Point(1) = {0,  0,  0, 9.e-1 * lc} ;

<I><FONT COLOR="#B22222">// The mesh size is defined as the length of the segments for lines,
</FONT></I><I><FONT COLOR="#B22222">// the radii of the circumscribed circles for triangles and the radii
</FONT></I><I><FONT COLOR="#B22222">// of the circumscribed spheres for tetrahedra, respectively. The
</FONT></I><I><FONT COLOR="#B22222">// actual distribution of the mesh sizes is obtained by interpolation
</FONT></I><I><FONT COLOR="#B22222">// of the characteristic lengths prescribed at the points. There are
</FONT></I><I><FONT COLOR="#B22222">// also other possibilities to specify characteristic lengths:
</FONT></I><I><FONT COLOR="#B22222">// attractors (see t7.geo) and background meshes (see bgmesh.pos).
</FONT></I>
<I><FONT COLOR="#B22222">// As can be seen in the previous definition, more complex expressions
</FONT></I><I><FONT COLOR="#B22222">// can be constructed from variables. Here, the product of the
</FONT></I><I><FONT COLOR="#B22222">// variable 'lc' by the constant 9.e-1 is given as the fourth argument
</FONT></I><I><FONT COLOR="#B22222">// of the list defining the point.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The following general syntax rule is applied for the definition of
</FONT></I><I><FONT COLOR="#B22222">// all geometrical entities:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//    &quot;If a number defines a new entity, it is enclosed between
</FONT></I><I><FONT COLOR="#B22222">//    parentheses. If a number refers to a previously defined entity,
</FONT></I><I><FONT COLOR="#B22222">//    it is enclosed between braces.&quot;
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Three additional points are then defined:
</FONT></I>
Point(2) = {.1, 0,  0, lc} ;
Point(3) = {.1, .3, 0, lc} ;
Point(4) = {0,  .3, 0, lc} ;

<I><FONT COLOR="#B22222">// The second elementary geometrical entity in Gmsh is the
</FONT></I><I><FONT COLOR="#B22222">// curve. Amongst curves, straight lines are the simplest. A straight
</FONT></I><I><FONT COLOR="#B22222">// line is defined by a list of point numbers. For example, line 1
</FONT></I><I><FONT COLOR="#B22222">// starts at point 1 and ends at point 2:
</FONT></I>
Line(1) = {1,2} ;
Line(2) = {3,2} ;
Line(3) = {3,4} ;
Line(4) = {4,1} ;

<I><FONT COLOR="#B22222">// The third elementary entity is the surface. In order to define a
</FONT></I><I><FONT COLOR="#B22222">// simple rectangular surface from the four lines defined above, a
</FONT></I><I><FONT COLOR="#B22222">// line loop has first to be defined. A line loop is a list of
</FONT></I><I><FONT COLOR="#B22222">// connected lines, a sign being associated with each line (depending
</FONT></I><I><FONT COLOR="#B22222">// on the orientation of the line).
</FONT></I>
Line Loop(5) = {4,1,-2,3} ;

<I><FONT COLOR="#B22222">// The surface is then defined as a list of line loops (only one
</FONT></I><I><FONT COLOR="#B22222">// here):
</FONT></I>
Plane Surface(6) = {5} ;

<I><FONT COLOR="#B22222">// At this level, Gmsh knows everything to display the rectangular
</FONT></I><I><FONT COLOR="#B22222">// surface 6 and to mesh it. But a supplementary step is needed in
</FONT></I><I><FONT COLOR="#B22222">// order to assign region numbers to the various elements in the mesh
</FONT></I><I><FONT COLOR="#B22222">// (the points, the lines and the triangles discretizing points 1 to
</FONT></I><I><FONT COLOR="#B22222">// 4, lines 1 to 4 and surface 6). This is achieved by the definition
</FONT></I><I><FONT COLOR="#B22222">// of Physical entities. Physical entities will group elements
</FONT></I><I><FONT COLOR="#B22222">// belonging to several elementary entities by giving them a common
</FONT></I><I><FONT COLOR="#B22222">// number (a region number), and specifying their orientation.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// For example, the two points 1 and 2 can be grouped into the
</FONT></I><I><FONT COLOR="#B22222">// physical entity 1:
</FONT></I>
Physical Point(1) = {1,2} ;

<I><FONT COLOR="#B22222">// Consequently, two punctual elements will be saved in the output
</FONT></I><I><FONT COLOR="#B22222">// files, both with the region number 1. The mechanism is identical
</FONT></I><I><FONT COLOR="#B22222">// for line or surface elements:
</FONT></I>
Physical Line(10) = {1,2,4} ;
Physical Surface(100) = {6} ;

<I><FONT COLOR="#B22222">// All the line elements which will be created during the mesh of
</FONT></I><I><FONT COLOR="#B22222">// lines 1, 2 and 4 will be saved in the output file with the region
</FONT></I><I><FONT COLOR="#B22222">// number 10; and all the triangular elements resulting from the
</FONT></I><I><FONT COLOR="#B22222">// discretization of surface 6 will be given the region number 100.
</FONT></I>
<I><FONT COLOR="#B22222">// It is important to notice that only those elements which belong to
</FONT></I><I><FONT COLOR="#B22222">// physical groups will be saved in the output file if the file format
</FONT></I><I><FONT COLOR="#B22222">// is the msh format (the native mesh file format for Gmsh). For a
</FONT></I><I><FONT COLOR="#B22222">// description of the mesh and post-processing formats, see the
</FONT></I><I><FONT COLOR="#B22222">// FORMATS file.
</FONT></I>
</PRE>
<HR>
<A NAME="file3">
<H1>t2.geo 3/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 2
 * 
 *  Includes, Geometrical transformations, Elementary entities
 *  (Volumes), Physical entities (Volumes)
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// The first tutorial file will serve as a basis to construct this
</FONT></I><I><FONT COLOR="#B22222">// one. It can be included with:
</FONT></I>
Include &quot;t1.geo&quot; ;

<I><FONT COLOR="#B22222">// There are several possibilities to build a more complex geometry
</FONT></I><I><FONT COLOR="#B22222">// from the one previously defined in 't1.geo'.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// New points, lines and surfaces can first be directly defined in the
</FONT></I><I><FONT COLOR="#B22222">// same way as in 't1.geo':
</FONT></I>
Point(5) = {0, .4, 0, lc} ;
Line(5) = {4, 5} ;

<I><FONT COLOR="#B22222">// But Gmsh also provides geometrical transformation mechanisms to
</FONT></I><I><FONT COLOR="#B22222">// move (translate, rotate, ...), add (translate, rotate, ...) or
</FONT></I><I><FONT COLOR="#B22222">// extrude (translate, rotate) elementary geometrical entities. For
</FONT></I><I><FONT COLOR="#B22222">// example, the point 3 can be moved by 0.05 units on the left with:
</FONT></I>
Translate {-0.05,0,0} { Point{3} ; }

<I><FONT COLOR="#B22222">// The resulting point can also be duplicated and translated by 0.1
</FONT></I><I><FONT COLOR="#B22222">// along the y axis:
</FONT></I>
Translate {0,0.1,0} { Duplicata{ Point{3} ; } }

<I><FONT COLOR="#B22222">// Of course, translation, rotation and extrusion commands not only
</FONT></I><I><FONT COLOR="#B22222">// apply to points, but also to lines and surfaces. The following
</FONT></I><I><FONT COLOR="#B22222">// command extrudes surface 6 defined in 't1.geo', as well as a new
</FONT></I><I><FONT COLOR="#B22222">// surface 11, along the z axis by 'h':
</FONT></I>
h = 0.12 ;
Extrude Surface { 6, {0, 0, h} } ;

Line(7) = {3, 6} ; Line(8) = {6,5} ; Line Loop(10) = {5,-8,-7,3};

Plane Surface(11) = {10};

Extrude Surface { 11, {0, 0, h} } ;

<I><FONT COLOR="#B22222">// All these geometrical transformations automatically generate new
</FONT></I><I><FONT COLOR="#B22222">// elementary entities. The following commands permit to specify
</FONT></I><I><FONT COLOR="#B22222">// manually a characteristic length for some of the automatically
</FONT></I><I><FONT COLOR="#B22222">// created points:
</FONT></I>
Characteristic Length{6,22,2,3,16,12} = lc * 3 ;

<I><FONT COLOR="#B22222">// If the transformation tools are handy to create complex geometries,
</FONT></I><I><FONT COLOR="#B22222">// it is sometimes useful to generate the flat geometry, consisting
</FONT></I><I><FONT COLOR="#B22222">// only of the explicit list elementary entities. This can be achieved
</FONT></I><I><FONT COLOR="#B22222">// by selecting the 'File-&gt;Save as-&gt;GEO flattened geometry' menu or 
</FONT></I><I><FONT COLOR="#B22222">// by typing
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// &gt; gmsh t2.geo -0
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// on the command line.
</FONT></I>
<I><FONT COLOR="#B22222">// Volumes are the fourth type of elementary entities in Gmsh. In the
</FONT></I><I><FONT COLOR="#B22222">// same way one defines line loops to build surfaces, one has to
</FONT></I><I><FONT COLOR="#B22222">// define surface loops to build volumes. The following volumes are
</FONT></I><I><FONT COLOR="#B22222">// very simple, without holes (and thus consist of only one surface
</FONT></I><I><FONT COLOR="#B22222">// loop):
</FONT></I>
Surface Loop(145) = {121,11,131,135,139,144};
Volume(146) = {145};

Surface Loop(146) = {121,6,109,113,117,122};
Volume(147) = {146};

<I><FONT COLOR="#B22222">// To save all volumic (tetrahedral) elements of volume 146 and 147
</FONT></I><I><FONT COLOR="#B22222">// with the associate region number 1, a Physical Volume must be
</FONT></I><I><FONT COLOR="#B22222">// defined:
</FONT></I>
Physical Volume (1) = {146,147} ;

<I><FONT COLOR="#B22222">// Congratulations! You've created your first fully unstructured
</FONT></I><I><FONT COLOR="#B22222">// tetrahedral 3D mesh!
</FONT></I></PRE>
<HR>
<A NAME="file4">
<H1>t3.geo 4/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 3
 * 
 *  Extruded meshes, Options
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// Again, the first tutorial example is included:
</FONT></I>
Include &quot;t1.geo&quot; ;

<I><FONT COLOR="#B22222">// As in 't2.geo', an extrusion along the z axis will be performed:
</FONT></I>
h = 0.1 ;

<I><FONT COLOR="#B22222">// But contrary to 't2.geo', not only the geometry will be extruded,
</FONT></I><I><FONT COLOR="#B22222">// but also the 2D mesh. This is done with the same Extrude command,
</FONT></I><I><FONT COLOR="#B22222">// but by specifying the number of layers (here, there will be four
</FONT></I><I><FONT COLOR="#B22222">// layers, of respectively 8, 4, 2 and 1 elements in depth), with
</FONT></I><I><FONT COLOR="#B22222">// volume numbers 9000 to 9003 and respective heights equal to h/4:
</FONT></I>
Extrude Surface { 6, {0,0,h} } { 
  Layers { {8,4,2,1}, {9000:9003}, {0.25,0.5,0.75,1} } ; 
} ;

<I><FONT COLOR="#B22222">// The extrusion can also be combined with a rotation, and the
</FONT></I><I><FONT COLOR="#B22222">// extruded 3D mesh can be recombined into prisms (wedges). All
</FONT></I><I><FONT COLOR="#B22222">// rotations are specified by an axis direction ({0,1,0}), an axis
</FONT></I><I><FONT COLOR="#B22222">// point ({0,0,0}) and a rotation angle (Pi/2):
</FONT></I>
Extrude Surface { 122, {0,1,0} , {-0.1,0,0.1} , -Pi/2 } { 
  Recombine ; Layers { 7, 9004, 1 } ; 
};

Physical Volume(101) = {9000:9004};

<I><FONT COLOR="#B22222">// All interactive options can also be set directly in the input file.
</FONT></I><I><FONT COLOR="#B22222">// For example, the following lines define a global characteristic
</FONT></I><I><FONT COLOR="#B22222">// length factor, redefine some background colors, disable the display
</FONT></I><I><FONT COLOR="#B22222">// of the axes, and select an initial viewpoint in XYZ mode (disabling
</FONT></I><I><FONT COLOR="#B22222">// the interactive trackball-like rotation mode):
</FONT></I>
Mesh.CharacteristicLengthFactor = 4;
General.Color.Background = {120,120,120};
General.Color.Foreground = {255,255,255};
General.Color.Text = White;
Geometry.Color.Points = Orange;
General.Axes = 0;
General.Trackball = 0;
General.RotationX = 10;
General.RotationY = 70;
General.TranslationX = -0.1;

<I><FONT COLOR="#B22222">// Note: all colors can be defined literally or numerically, i.e.
</FONT></I><I><FONT COLOR="#B22222">// 'General.Color.Background = Red' is equivalent to
</FONT></I><I><FONT COLOR="#B22222">// 'General.Color.Background = {255,0,0}'. As with user-defined
</FONT></I><I><FONT COLOR="#B22222">// variables, the options can be used either as right hand or left
</FONT></I><I><FONT COLOR="#B22222">// hand sides, so that
</FONT></I>
Geometry.Color.Surfaces = Geometry.Color.Points;

<I><FONT COLOR="#B22222">// will assign the color of the surfaces in the geometry to the same
</FONT></I><I><FONT COLOR="#B22222">// color as the points.
</FONT></I>
<I><FONT COLOR="#B22222">// A click on the '?'  button in the status bar of the graphic window
</FONT></I><I><FONT COLOR="#B22222">// will dump all current options to the terminal. To save all
</FONT></I><I><FONT COLOR="#B22222">// available options to a file, use the 'File-&gt;Save as-&gt;GEO complete
</FONT></I><I><FONT COLOR="#B22222">// options' menu. To save the current options as the default options
</FONT></I><I><FONT COLOR="#B22222">// for all future Gmsh sessions, use the 'Options-&gt;Save options now'
</FONT></I><I><FONT COLOR="#B22222">// menu.
</FONT></I></PRE>
<HR>
<A NAME="file5">
<H1>t4.geo 5/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 4
 * 
 *  Built-in functions, Holes
 *
 *********************************************************************/</FONT></I>

cm = 1e-02 ;

e1 = 4.5*cm ; e2 = 6*cm / 2 ; e3 =  5*cm / 2 ;

h1 = 5*cm ; h2 = 10*cm ; h3 = 5*cm ; h4 = 2*cm ; h5 = 4.5*cm ;

R1 = 1*cm ; R2 = 1.5*cm ; r = 1*cm ;

ccos = ( -h5*R1 + e2 * Hypot(h5,Hypot(e2,R1)) ) / (h5^2 + e2^2) ;
ssin = Sqrt(1-ccos^2) ;

Lc1 = 0.01 ;
Lc2 = 0.003 ;

<I><FONT COLOR="#B22222">// A whole set of operators can be used, which can be combined in all
</FONT></I><I><FONT COLOR="#B22222">// the expressions. These operators are defined in a similar way to
</FONT></I><I><FONT COLOR="#B22222">// their C or C++ equivalents (with the exception of '^'):
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   '-' (in both unary and binary versions, i.e. as in '-1' and '1-2')
</FONT></I><I><FONT COLOR="#B22222">//   '!' (the negation)
</FONT></I><I><FONT COLOR="#B22222">//   '+'
</FONT></I><I><FONT COLOR="#B22222">//   '*'
</FONT></I><I><FONT COLOR="#B22222">//   '/'
</FONT></I><I><FONT COLOR="#B22222">//   '%' (the rest of the integer division)
</FONT></I><I><FONT COLOR="#B22222">//   '&lt;'
</FONT></I><I><FONT COLOR="#B22222">//   '&gt;'
</FONT></I><I><FONT COLOR="#B22222">//   '&lt;='
</FONT></I><I><FONT COLOR="#B22222">//   '&gt;='
</FONT></I><I><FONT COLOR="#B22222">//   '=='
</FONT></I><I><FONT COLOR="#B22222">//   '!='
</FONT></I><I><FONT COLOR="#B22222">//   '&amp;&amp;' (and)
</FONT></I><I><FONT COLOR="#B22222">//   '||' (or)
</FONT></I><I><FONT COLOR="#B22222">//   '||' (or)
</FONT></I><I><FONT COLOR="#B22222">//   '^' (power)
</FONT></I><I><FONT COLOR="#B22222">//   '?' ':' (the ternary operator)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Grouping is done, as usual, with parentheses.
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// In addition to these operators, all C mathematical functions can
</FONT></I><I><FONT COLOR="#B22222">// also be used (note the first capital letter):
</FONT></I><I><FONT COLOR="#B22222">// 
</FONT></I><I><FONT COLOR="#B22222">//   Exp(x)
</FONT></I><I><FONT COLOR="#B22222">//   Log(x)
</FONT></I><I><FONT COLOR="#B22222">//   Log10(x)
</FONT></I><I><FONT COLOR="#B22222">//   Sqrt(x)
</FONT></I><I><FONT COLOR="#B22222">//   Sin(x)
</FONT></I><I><FONT COLOR="#B22222">//   Asin(x)
</FONT></I><I><FONT COLOR="#B22222">//   Cos(x)
</FONT></I><I><FONT COLOR="#B22222">//   Acos(x)
</FONT></I><I><FONT COLOR="#B22222">//   Tan(x)
</FONT></I><I><FONT COLOR="#B22222">//   Atan(x)
</FONT></I><I><FONT COLOR="#B22222">//   Atan2(x,y)
</FONT></I><I><FONT COLOR="#B22222">//   Sinh(x)
</FONT></I><I><FONT COLOR="#B22222">//   Cosh(x)
</FONT></I><I><FONT COLOR="#B22222">//   Tanh(x)
</FONT></I><I><FONT COLOR="#B22222">//   Fabs(x)
</FONT></I><I><FONT COLOR="#B22222">//   Floor(x)
</FONT></I><I><FONT COLOR="#B22222">//   Ceil(x)
</FONT></I><I><FONT COLOR="#B22222">//   Fmod(x,y)
</FONT></I><I><FONT COLOR="#B22222">//   Hypot(x,y)
</FONT></I>
<I><FONT COLOR="#B22222">// An additional function 'Rand(x)' generates a random number in [0,x]
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">//   Rand(x)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// The only predefined constant in Gmsh is Pi.
</FONT></I>
Point(1) = { -e1-e2, 0.0  , 0.0 , Lc1};
Point(2) = { -e1-e2, h1   , 0.0 , Lc1};
Point(3) = { -e3-r , h1   , 0.0 , Lc2};
Point(4) = { -e3-r , h1+r , 0.0 , Lc2};
Point(5) = { -e3   , h1+r , 0.0 , Lc2};
Point(6) = { -e3   , h1+h2, 0.0 , Lc1};
Point(7) = {  e3   , h1+h2, 0.0 , Lc1};
Point(8) = {  e3   , h1+r , 0.0 , Lc2};
Point(9) = {  e3+r , h1+r , 0.0 , Lc2};
Point(10)= {  e3+r , h1   , 0.0 , Lc2};
Point(11)= {  e1+e2, h1   , 0.0 , Lc1};
Point(12)= {  e1+e2, 0.0  , 0.0 , Lc1};
Point(13)= {  e2   , 0.0  , 0.0 , Lc1};

Point(14)= {  R1 / ssin , h5+R1*ccos, 0.0 , Lc2};
Point(15)= {  0.0       , h5        , 0.0 , Lc2};
Point(16)= { -R1 / ssin , h5+R1*ccos, 0.0 , Lc2};
Point(17)= { -e2        , 0.0       , 0.0 , Lc1};

Point(18)= { -R2  , h1+h3   , 0.0 , Lc2};
Point(19)= { -R2  , h1+h3+h4, 0.0 , Lc2};
Point(20)= {  0.0 , h1+h3+h4, 0.0 , Lc2};
Point(21)= {  R2  , h1+h3+h4, 0.0 , Lc2};
Point(22)= {  R2  , h1+h3   , 0.0 , Lc2};
Point(23)= {  0.0 , h1+h3   , 0.0 , Lc2};

Point(24)= {  0 , h1+h3+h4+R2, 0.0 , Lc2};
Point(25)= {  0 , h1+h3-R2,    0.0 , Lc2};

Line(1)  = {1 ,17};
Line(2)  = {17,16};

<I><FONT COLOR="#B22222">// All curves are not straight lines... Circles are defined by a list
</FONT></I><I><FONT COLOR="#B22222">// of three point numbers, which represent the starting point, the
</FONT></I><I><FONT COLOR="#B22222">// center and the end point, respectively. All circles have to be
</FONT></I><I><FONT COLOR="#B22222">// defined in the trigonometric (counter-clockwise) sense.  Note that
</FONT></I><I><FONT COLOR="#B22222">// the 3 points should not be aligned (otherwise the plane in which
</FONT></I><I><FONT COLOR="#B22222">// the circle lies has to be defined, by 'Circle(num) =
</FONT></I><I><FONT COLOR="#B22222">// {start,center,end} Plane {nx,ny,nz}').
</FONT></I>
Circle(3) = {14,15,16};
Line(4)  = {14,13};
Line(5)  = {13,12};
Line(6)  = {12,11};
Line(7)  = {11,10};
Circle(8) = { 8, 9,10};
Line(9)  = { 8, 7};
Line(10) = { 7, 6};
Line(11) = { 6, 5};
Circle(12) = { 3, 4, 5};
Line(13) = { 3, 2};
Line(14) = { 2, 1};
Line(15) = {18,19};
Circle(16) = {21,20,24};
Circle(17) = {24,20,19};
Circle(18) = {18,23,25};
Circle(19) = {25,23,22};
Line(20) = {21,22};

Line Loop(21) = {17,-15,18,19,-20,16};
Plane Surface(22) = {21};

<I><FONT COLOR="#B22222">// The surface is made of two line loops, i.e. it has one hole:
</FONT></I>
Line Loop(23) = {11,-12,13,14,1,2,-3,4,5,6,7,-8,9,10};
Plane Surface(24) = {23,21};

Physical Surface(1) = {22};
Physical Surface(2) = {24};
</PRE>
<HR>
<A NAME="file6">
<H1>t5.geo 6/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 5
 * 
 *  Characteristic lengths, Arrays of variables, Functions, Loops
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// This defines some characteristic lengths:
</FONT></I>
lcar1 = .1;
lcar2 = .0005;
lcar3 = .075;

<I><FONT COLOR="#B22222">// In order to change these lengths globally (without changing the
</FONT></I><I><FONT COLOR="#B22222">// file), a global scaling factor for all characteristic lengths can
</FONT></I><I><FONT COLOR="#B22222">// be specified on the command line with the option '-clscale'. For
</FONT></I><I><FONT COLOR="#B22222">// example, with:
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// &gt; gmsh t5 -clscale 1
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// this example produces a mesh of approximately 2000 nodes and
</FONT></I><I><FONT COLOR="#B22222">// 10,000 tetrahedra (in 3 seconds on an alpha workstation running at
</FONT></I><I><FONT COLOR="#B22222">// 666MHz). With 
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// &gt; gmsh t5 -clscale 0.2
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// (i.e. with all characteristic lengths divided by 5), the mesh
</FONT></I><I><FONT COLOR="#B22222">// counts approximately 170,000 nodes and one million tetrahedra
</FONT></I><I><FONT COLOR="#B22222">// (and the computation takes 16 minutes on the same machine :-( So
</FONT></I><I><FONT COLOR="#B22222">// there is still a lot of work to do to achieve decent performance
</FONT></I><I><FONT COLOR="#B22222">// with Gmsh...)
</FONT></I>
Point(1) = {0.5,0.5,0.5,lcar2}; Point(2) = {0.5,0.5,0,lcar1};
Point(3) = {0,0.5,0.5,lcar1};   Point(4) = {0,0,0.5,lcar1}; 
Point(5) = {0.5,0,0.5,lcar1};   Point(6) = {0.5,0,0,lcar1};
Point(7) = {0,0.5,0,lcar1};     Point(8) = {0,1,0,lcar1};
Point(9) = {1,1,0,lcar1};       Point(10) = {0,0,1,lcar1};
Point(11) = {0,1,1,lcar1};      Point(12) = {1,1,1,lcar1};
Point(13) = {1,0,1,lcar1};      Point(14) = {1,0,0,lcar1};

Line(1) = {8,9};    Line(2) = {9,12};  Line(3) = {12,11};
Line(4) = {11,8};   Line(5) = {9,14};  Line(6) = {14,13};
Line(7) = {13,12};  Line(8) = {11,10}; Line(9) = {10,13};
Line(10) = {10,4};  Line(11) = {4,5};  Line(12) = {5,6};
Line(13) = {6,2};   Line(14) = {2,1};  Line(15) = {1,3};
Line(16) = {3,7};   Line(17) = {7,2};  Line(18) = {3,4};
Line(19) = {5,1};   Line(20) = {7,8};  Line(21) = {6,14};

Line Loop(22) = {11,19,15,18};       Plane Surface(23) = {22};
Line Loop(24) = {16,17,14,15};       Plane Surface(25) = {24};
Line Loop(26) = {-17,20,1,5,-21,13}; Plane Surface(27) = {26};
Line Loop(28) = {4,1,2,3};           Plane Surface(29) = {28};
Line Loop(30) = {7,-2,5,6};          Plane Surface(31) = {30};
Line Loop(32) = {6,-9,10,11,12,21};  Plane Surface(33) = {32};
Line Loop(34) = {7,3,8,9};           Plane Surface(35) = {34};
Line Loop(36) = {10,-18,16,20,-4,8}; Plane Surface(37) = {36};
Line Loop(38) = {-14,-13,-12,19};    Plane Surface(39) = {38};

<I><FONT COLOR="#B22222">// Instead of using included files, one can also define functions. In
</FONT></I><I><FONT COLOR="#B22222">// the following function, the reserved variable 'newp' is used, which
</FONT></I><I><FONT COLOR="#B22222">// automatically selects a new point number. This number is chosen as
</FONT></I><I><FONT COLOR="#B22222">// the highest current point number, plus one. Analogously to 'newp',
</FONT></I><I><FONT COLOR="#B22222">// there exists a variable 'newreg' which selects the highest number
</FONT></I><I><FONT COLOR="#B22222">// of all entities other than points, plus one.
</FONT></I>
<I><FONT COLOR="#B22222">// Note: there are no local variables. This will be changed in a
</FONT></I><I><FONT COLOR="#B22222">// future version of Gmsh.
</FONT></I>
Function CheeseHole 

  p1 = newp; Point(p1) = {x,  y,  z,  lcar3} ;
  p2 = newp; Point(p2) = {x+r,y,  z,  lcar3} ;
  p3 = newp; Point(p3) = {x,  y+r,z,  lcar3} ;
  p4 = newp; Point(p4) = {x,  y,  z+r,lcar3} ;
  p5 = newp; Point(p5) = {x-r,y,  z,  lcar3} ;
  p6 = newp; Point(p6) = {x,  y-r,z,  lcar3} ;
  p7 = newp; Point(p7) = {x,  y,  z-r,lcar3} ;

  c1 = newreg; Circle(c1) = {p2,p1,p7};
  c2 = newreg; Circle(c2) = {p7,p1,p5};
  c3 = newreg; Circle(c3) = {p5,p1,p4};
  c4 = newreg; Circle(c4) = {p4,p1,p2};
  c5 = newreg; Circle(c5) = {p2,p1,p3};
  c6 = newreg; Circle(c6) = {p3,p1,p5};
  c7 = newreg; Circle(c7) = {p5,p1,p6};
  c8 = newreg; Circle(c8) = {p6,p1,p2};
  c9 = newreg; Circle(c9) = {p7,p1,p3};
  c10 = newreg; Circle(c10) = {p3,p1,p4};
  c11 = newreg; Circle(c11) = {p4,p1,p6};
  c12 = newreg; Circle(c12) = {p6,p1,p7};

<I><FONT COLOR="#B22222">// All surfaces are not plane... Here is the way to define ruled
</FONT></I><I><FONT COLOR="#B22222">// surfaces (which have 3 or 4 borders):
</FONT></I>
  l1 = newreg; Line Loop(l1) = {c5,c10,c4};   Ruled Surface(newreg) = {l1};
  l2 = newreg; Line Loop(l2) = {c9,-c5,c1};   Ruled Surface(newreg) = {l2};
  l3 = newreg; Line Loop(l3) = {-c12,c8,c1};  Ruled Surface(newreg) = {l3};
  l4 = newreg; Line Loop(l4) = {c8,-c4,c11};  Ruled Surface(newreg) = {l4};
  l5 = newreg; Line Loop(l5) = {-c10,c6,c3};  Ruled Surface(newreg) = {l5};
  l6 = newreg; Line Loop(l6) = {-c11,-c3,c7}; Ruled Surface(newreg) = {l6};
  l7 = newreg; Line Loop(l7) = {c2,c7,c12};   Ruled Surface(newreg) = {l7};
  l8 = newreg; Line Loop(l8) = {-c6,-c9,c2};  Ruled Surface(newreg) = {l8};

<I><FONT COLOR="#B22222">// Arrays of variables can be manipulated in the same way as classical
</FONT></I><I><FONT COLOR="#B22222">// variables. Warning: accessing an uninitialized element in an array
</FONT></I><I><FONT COLOR="#B22222">// will produce an unpredictable result. Note that whole arrays can
</FONT></I><I><FONT COLOR="#B22222">// also be instantly initialized (e.g. l[]={1,2,7} is valid).
</FONT></I>
  theloops[t] = newreg ; 

  Surface Loop(theloops[t]) = {l8+1, l5+1, l1+1, l2+1, -(l3+1), -(l7+1), l6+1, l4+1};

  thehole = newreg ; 
  Volume(thehole) = theloops[t] ;

Return


x = 0 ; y = 0.75 ; z = 0 ; r = 0.09 ;

<I><FONT COLOR="#B22222">// A For loop is used to generate five holes in the cube:
</FONT></I>
For t In {1:5}

  x += 0.166 ; 
  z += 0.166 ; 

<I><FONT COLOR="#B22222">// This command calls the function CheeseHole. Note that, instead of
</FONT></I><I><FONT COLOR="#B22222">// defining a function, we could have defined a file containing the
</FONT></I><I><FONT COLOR="#B22222">// same code, and used the Include command to include this file.
</FONT></I>
  Call CheeseHole ;

<I><FONT COLOR="#B22222">// A physical volume is defined for each cheese hole
</FONT></I>
  Physical Volume (t) = thehole ;
 
<I><FONT COLOR="#B22222">// The Printf function permits to print the value of variables on the
</FONT></I><I><FONT COLOR="#B22222">// terminal, in a way similar to the 'printf' C function:
</FONT></I>
  Printf(&quot;The cheese hole %g (center = {%g,%g,%g}, radius = %g) has number %g!&quot;,
	 t, x, y, z, r, thehole) ;

<I><FONT COLOR="#B22222">// Note: All Gmsh variables are treated internally as double precision
</FONT></I><I><FONT COLOR="#B22222">// numbers. The format string should thus only contain valid double
</FONT></I><I><FONT COLOR="#B22222">// precision number format specifiers (see the C or C++ language
</FONT></I><I><FONT COLOR="#B22222">// reference for more details).
</FONT></I>
EndFor

<I><FONT COLOR="#B22222">// This is the surface loop for the exterior surface of the cube:
</FONT></I>
theloops[0] = newreg ;

Surface Loop(theloops[0]) = {35,31,29,37,33,23,39,25,27} ;

<I><FONT COLOR="#B22222">// The volume of the cube, without the 5 cheese holes, is defined by 6
</FONT></I><I><FONT COLOR="#B22222">// surface loops (the exterior surface and the five interior loops).
</FONT></I><I><FONT COLOR="#B22222">// To reference an array of variables, its identifier is followed by
</FONT></I><I><FONT COLOR="#B22222">// '[]':
</FONT></I>
Volume(186) = {theloops[]} ;

<I><FONT COLOR="#B22222">// This physical volume assigns the region number 10 to the tetrahedra
</FONT></I><I><FONT COLOR="#B22222">// paving the cube (but not the holes, whose elements were tagged from
</FONT></I><I><FONT COLOR="#B22222">// 1 to 5 in the 'For' loop)
</FONT></I>
Physical Volume (10) = 186 ;

</PRE>
<HR>
<A NAME="file7">
<H1>t6.geo 7/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 6
 * 
 *  Transfinite meshes
 *
 *********************************************************************/</FONT></I>

r_int  = 0.05 ;
r_ext  = 0.051 ;
r_far  = 0.125 ;
r_inf  = 0.4 ;
phi1   = 30. * (Pi/180.) ;
angl   = 45. * (Pi/180.) ;

nbpt_phi   = 5 ; nbpt_int   = 20 ;
nbpt_arc1  = 10 ; nbpt_arc2  = 10 ;
nbpt_shell = 10 ; nbpt_far   = 25 ; nbpt_inf = 15 ;

lc0 = 0.1 ; lc1 = 0.1 ; lc2 = 0.3 ;

Point(1) = {0,     0, 0, lc0} ;
Point(2) = {r_int, 0, 0, lc0} ;
Point(3) = {r_ext, 0, 0, lc1} ;
Point(4) = {r_far, 0, 0, lc2} ;
Point(5) = {r_inf, 0, 0, lc2} ;
Point(6) = {0, 0,  r_int, lc0} ;
Point(7) = {0, 0,  r_ext, lc1} ;
Point(8) = {0, 0,  r_far, lc2} ;
Point(9) = {0, 0,  r_inf, lc2} ;

Point(10) = {r_int*Cos(phi1), r_int*Sin(phi1), 0, lc0} ;
Point(11) = {r_ext*Cos(phi1), r_ext*Sin(phi1), 0, lc1} ;
Point(12) = {r_far*Cos(phi1), r_far*Sin(phi1), 0, lc2} ;
Point(13) = {r_inf*Cos(phi1), r_inf*Sin(phi1), 0, lc2} ;

Point(14) = {r_int/2,           0,   0,               lc2} ;
Point(15) = {r_int/2*Cos(phi1), r_int/2*Sin(phi1), 0, lc2} ;
Point(16) = {r_int/2,           0,                 r_int/2, lc2} ;
Point(17) = {r_int/2*Cos(phi1), r_int/2*Sin(phi1), r_int/2, lc2} ;
Point(18) = {0, 0,  r_int/2, lc2} ;
Point(19) = {r_int*Cos(angl),           0,                         r_int*Sin(angl), lc2} ;
Point(20) = {r_int*Cos(angl)*Cos(phi1), r_int*Cos(angl)*Sin(phi1), r_int*Sin(angl), lc2} ;
Point(21) = {r_ext*Cos(angl),           0,                         r_ext*Sin(angl), lc2} ;
Point(22) = {r_ext*Cos(angl)*Cos(phi1), r_ext*Cos(angl)*Sin(phi1), r_ext*Sin(angl), lc2} ;
Point(23) = {r_far*Cos(angl),           0,                         r_far*Sin(angl), lc2} ;
Point(24) = {r_far*Cos(angl)*Cos(phi1), r_far*Cos(angl)*Sin(phi1), r_far*Sin(angl), lc2} ;
Point(25) = {r_inf,           0,                r_inf, lc2} ;
Point(26) = {r_inf*Cos(phi1), r_inf*Sin(phi1),  r_inf, lc2} ;

Circle(1) = {2,1,19};   Circle(2) = {19,1,6};   Circle(3) = {3,1,21};
Circle(4) = {21,1,7};   Circle(5) = {4,1,23};   Circle(6) = {23,1,8};   
Line(7) = {5,25};   Line(8) = {25,9};
Circle(9) = {10,1,20};  Circle(10) = {20,1,6};  Circle(11) = {11,1,22};
Circle(12) = {22,1,7};  Circle(13) = {12,1,24}; Circle(14) = {24,1,8};
Line(15) = {13,26}; Line(16) = {26,9};
Circle(17) = {19,1,20}; Circle(18) = {21,1,22}; Circle(19) = {23,1,24};
Circle(20) = {25,1,26}; Circle(21) = {2,1,10};  Circle(22) = {3,1,11};  
Circle(23) = {4,1,12};  Circle(24) = {5,1,13};

Line(25) = {1,14};  Line(26) = {14,2};  Line(27) = {2,3};   Line(28) = {3,4};
Line(29) = {4,5};   Line(30) = {1,15};  Line(31) = {15,10}; Line(32) = {10,11};
Line(33) = {11,12}; Line(34) = {12,13}; Line(35) = {14,15}; Line(36) = {14,16};
Line(37) = {15,17}; Line(38) = {16,17}; Line(39) = {18,16}; Line(40) = {18,17};
Line(41) = {1,18};  Line(42) = {18,6};  Line(43) = {6,7};   Line(44) = {16,19};
Line(45) = {19,21}; Line(46) = {21,23}; Line(47) = {23,25}; Line(48) = {17,20};
Line(49) = {20,22}; Line(50) = {22,24}; Line(51) = {24,26}; Line(52) = {7,8};
Line(53) = {8,9};

Line Loop(54) = {39,-36,-25,41};  Ruled Surface(55) = {54};
Line Loop(56) = {44,-1,-26,36};   Ruled Surface(57) = {56};
Line Loop(58) = {3,-45,-1,27};    Ruled Surface(59) = {58};
Line Loop(60) = {5,-46,-3,28};    Ruled Surface(61) = {60};
Line Loop(62) = {7,-47,-5,29};    Ruled Surface(63) = {62};
Line Loop(64) = {-2,-44,-39,42};  Ruled Surface(65) = {64};
Line Loop(66) = {-4,-45,2,43};    Ruled Surface(67) = {66};
Line Loop(68) = {-6,-46,4,52};    Ruled Surface(69) = {68};
Line Loop(70) = {-8,-47,6,53};    Ruled Surface(71) = {70};
Line Loop(72) = {-40,-41,30,37};  Ruled Surface(73) = {72};
Line Loop(74) = {48,-9,-31,37};   Ruled Surface(75) = {74};
Line Loop(76) = {49,-11,-32,9};   Ruled Surface(77) = {76};
Line Loop(78) = {-50,-11,33,13};  Ruled Surface(79) = {78};
Line Loop(80) = {-51,-13,34,15};  Ruled Surface(81) = {80};
Line Loop(82) = {10,-42,40,48};   Ruled Surface(83) = {82};
Line Loop(84) = {12,-43,-10,49};  Ruled Surface(85) = {84};
Line Loop(86) = {14,-52,-12,50};  Ruled Surface(87) = {86};
Line Loop(88) = {16,-53,-14,51};  Ruled Surface(89) = {88};
Line Loop(90) = {-30,25,35};      Ruled Surface(91) = {90};
Line Loop(92) = {-40,39,38};      Ruled Surface(93) = {92};
Line Loop(94) = {37,-38,-36,35};  Ruled Surface(95) = {94};
Line Loop(96) = {-48,-38,44,17};  Ruled Surface(97) = {96};
Line Loop(98) = {18,-49,-17,45};  Ruled Surface(99) = {98};
Line Loop(100) = {19,-50,-18,46}; Ruled Surface(101) = {100};
Line Loop(102) = {20,-51,-19,47}; Ruled Surface(103) = {102};
Line Loop(104) = {-2,17,10};      Ruled Surface(105) = {104};
Line Loop(106) = {-9,-21,1,17};   Ruled Surface(107) = {106};
Line Loop(108) = {-4,18,12};      Ruled Surface(109) = {108};
Line Loop(110) = {-11,-22,3,18};  Ruled Surface(111) = {110};
Line Loop(112) = {-13,-23,5,19};  Ruled Surface(113) = {112};
Line Loop(114) = {-6,19,14};      Ruled Surface(115) = {114};
Line Loop(116) = {-15,-24,7,20};  Ruled Surface(117) = {116};
Line Loop(118) = {-8,20,16};      Ruled Surface(119) = {118};
Line Loop(120) = {-31,-35,26,21}; Ruled Surface(121) = {120};
Line Loop(122) = {32,-22,-27,21}; Ruled Surface(123) = {122};
Line Loop(124) = {33,-23,-28,22}; Ruled Surface(125) = {124};
Line Loop(126) = {34,-24,-29,23}; Ruled Surface(127) = {126};

Surface Loop(128) = {93,-73,-55,95,-91};         Volume(129) = {128}; <I><FONT COLOR="#B22222">// int
</FONT></I>Surface Loop(130) = {107,-75,-97,95,57,121};     Volume(131) = {130}; <I><FONT COLOR="#B22222">// int b
</FONT></I>Surface Loop(132) = {105,-65,-97,-83,-93};       Volume(133) = {132}; <I><FONT COLOR="#B22222">// int h
</FONT></I>Surface Loop(134) = {99,-111,77,123,59,107};     Volume(135) = {134}; <I><FONT COLOR="#B22222">// shell b
</FONT></I>Surface Loop(136) = {99,-109,67,105,85};         Volume(137) = {136}; <I><FONT COLOR="#B22222">// shell h
</FONT></I>Surface Loop(138) = {113,79,-101,-111,-125,-61}; Volume(139) = {138}; <I><FONT COLOR="#B22222">// ext b
</FONT></I>Surface Loop(140) = {115,-69,-101,-87,-109};     Volume(141) = {140}; <I><FONT COLOR="#B22222">// ext h
</FONT></I>Surface Loop(142) = {103,-117,-81,113,127,63};   Volume(143) = {142}; <I><FONT COLOR="#B22222">// inf b
</FONT></I>Surface Loop(144) = {89,-119,71,103,115};        Volume(145) = {144}; <I><FONT COLOR="#B22222">// inf h
</FONT></I>
<I><FONT COLOR="#B22222">// Transfinite line commands explicitly specify the number of points
</FONT></I><I><FONT COLOR="#B22222">// and their distribution. A minus sign in the argument list of the
</FONT></I><I><FONT COLOR="#B22222">// transfinite command will produce the reversed mesh.
</FONT></I>
Transfinite Line{35,21,22,23,24,38,17,18,19,20}   = nbpt_phi ;
Transfinite Line{31,26,48,44,42}                  = nbpt_int Using Progression 0.95;
Transfinite Line{41,37,36,9,11,1,3,13,5,15,7}     = nbpt_arc1 ;
Transfinite Line{30,25,40,39,10,2,12,4,14,6,16,8} = nbpt_arc2 ;
Transfinite Line{32,27,49,45,43}                  = nbpt_shell ;
Transfinite Line{33,28,46,50,52}                  = nbpt_far Using Progression 1.05 ;
Transfinite Line{34,29,51,47,53}                  = nbpt_inf Using Progression 0.01;

<I><FONT COLOR="#B22222">// *All* 2D and 3D transfinite entities are defined in respect to
</FONT></I><I><FONT COLOR="#B22222">// points. The ordering of the points defines the ordering of the mesh
</FONT></I><I><FONT COLOR="#B22222">// elements.
</FONT></I>
Transfinite Surface{55} = {1,14,16,18};
Transfinite Surface{57} = {14,2,19,16};
Transfinite Surface{59} = {2,3,21,19};
Transfinite Surface{61} = {3,4,23,21};
Transfinite Surface{63} = {4,5,25,23};
Transfinite Surface{73} = {1,15,17,18};
Transfinite Surface{75} = {15,10,20,17};
Transfinite Surface{77} = {10,11,22,20};
Transfinite Surface{79} = {11,12,24,22};
Transfinite Surface{81} = {12,13,26,24};
Transfinite Surface{65} = {18,16,19,6};
Transfinite Surface{67} = {6,19,21,7};
Transfinite Surface{69} = {7,21,23,8};
Transfinite Surface{71} = {8,23,25,9};
Transfinite Surface{83} = {17,18,6,20};
Transfinite Surface{85} = {20,6,7,22};
Transfinite Surface{87} = {22,7,8,24};
Transfinite Surface{89} = {24,8,9,26};
Transfinite Surface{91} = {1,14,15};
Transfinite Surface{95} = {15,14,16,17};
Transfinite Surface{93} = {18,16,17};
Transfinite Surface{121} = {15,14,2,10};
Transfinite Surface{97} = {17,16,19,20};
Transfinite Surface{123} = {10,2,3,11};
Transfinite Surface{99} = {20,19,21,22};
Transfinite Surface{107} = {10,2,19,20};
Transfinite Surface{105} = {6,20,19};
Transfinite Surface{109} = {7,22,21};
Transfinite Surface{111} = {11,3,21,22};
Transfinite Surface{101} = {22,21,23,24};
Transfinite Surface{125} = {11,3,4,12};
Transfinite Surface{115} = {8,24,23};
Transfinite Surface{113} = {24,12,4,23};
Transfinite Surface{127} = {12,13,5,4};
Transfinite Surface{103} = {24,23,25,26};
Transfinite Surface{119} = {9,26,25};
Transfinite Surface{117} = {13,5,25,26};

<I><FONT COLOR="#B22222">// As with Extruded meshes, the Recombine command tells Gmsh to
</FONT></I><I><FONT COLOR="#B22222">// recombine the simplices into quadrangles, prisms or hexahedra when
</FONT></I><I><FONT COLOR="#B22222">// possible. A colon in a list acts as in the 'For' loop: all surfaces
</FONT></I><I><FONT COLOR="#B22222">// having numbers between 55 and 127 are considered.
</FONT></I>
Recombine Surface {55:127};

<I><FONT COLOR="#B22222">// *All* 2D and 3D transfinite entities are defined in respect to
</FONT></I><I><FONT COLOR="#B22222">// points. The ordering of the points defines the ordering of the mesh
</FONT></I><I><FONT COLOR="#B22222">// elements.
</FONT></I>
Transfinite Volume{129} = {1,14,15,18,16,17};
Transfinite Volume{131} = {17,16,14,15,20,19,2,10};
Transfinite Volume{133} = {18,17,16,6,20,19};
Transfinite Volume{135} = {10,2,19,20,11,3,21,22};
Transfinite Volume{137} = {6,20,19,7,22,21};
Transfinite Volume{139} = {11,3,4,12,22,21,23,24};
Transfinite Volume{141} = {7,22,21,8,24,23};
Transfinite Volume{143} = {12,4,5,13,24,23,25,26};
Transfinite Volume{145} = {8,24,23,9,26,25};

VolInt           = 1000 ;
SurfIntPhi0      = 1001 ;
SurfIntPhi1      = 1002 ;
SurfIntZ0        = 1003 ;

VolShell         = 2000 ;
SurfShellInt     = 2001 ;
SurfShellExt     = 2002 ;
SurfShellPhi0    = 2003 ;
SurfShellPhi1    = 2004 ;
SurfShellZ0      = 2005 ;
LineShellIntPhi0 = 2006 ;
LineShellIntPhi1 = 2007 ;
LineShellIntZ0   = 2008 ;
PointShellInt    = 2009 ;

VolExt           = 3000 ;
VolInf           = 3001 ;
SurfInf          = 3002 ;
SurfExtInfPhi0   = 3003 ;
SurfExtInfPhi1   = 3004 ;
SurfExtInfZ0     = 3005 ;
SurfInfRight     = 3006 ;
SurfInfTop       = 3007 ;

Physical Volume  (VolInt)           = {129,131,133} ;
Physical Surface (SurfIntPhi0)      = {55,57,65} ;
Physical Surface (SurfIntPhi1)      = {73,75,83} ;
Physical Surface (SurfIntZ0)        = {91,121} ;

Physical Volume  (VolShell)         = {135,137} ;
Physical Surface (SurfShellInt)     = {105,107} ;
Physical Surface (SurfShellExt)     = {109,111} ;
Physical Surface (SurfShellPhi0)    = {59,67} ;
Physical Surface (SurfShellPhi1)    = {77,85} ;
Physical Surface (SurfShellZ0)      = {123} ;
Physical Line    (LineShellIntPhi0) = {1,2} ;
Physical Line    (LineShellIntPhi1) = {9,10} ;
Physical Line    (LineShellIntZ0)   = 21 ;
Physical Point   (PointShellInt)    = 6 ;

Physical Volume  (VolExt)           = {139,141} ;
Physical Volume  (VolInf)           = {143,145} ;
Physical Surface (SurfExtInfPhi0)   = {61,63,69,71} ;
Physical Surface (SurfExtInfPhi1)   = {79,87,81,89} ;
Physical Surface (SurfExtInfZ0)     = {125,127} ;
Physical Surface (SurfInfRight)     = {117} ;
Physical Surface (SurfInfTop)       = {119} ;
</PRE>
<HR>
<A NAME="file8">
<H1>t7.geo 8/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 7
 * 
 *  Anisotropic meshes, Attractors
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// The new anisotropic 2D mesh generator can be selected with:
</FONT></I>
Mesh.Algorithm = 2 ;

<I><FONT COLOR="#B22222">// One can force a 4 step Laplacian smoothing of the mesh with:
</FONT></I>
Mesh.Smoothing = 4 ;

lc = .1;

Point(1) = {0.0,0.0,0,lc};
Point(2) = {1,0.0,0,lc};
Point(3) = {1,1,0,lc};
Point(4) = {0,1,0,lc};

Line(1) = {3,2};
Line(2) = {2,1};
Line(3) = {1,4};
Line(4) = {4,3};

Line Loop(5) = {1,2,3,4};
Plane Surface(6) = {5};

Point(5) = {0.1,0.2,0,lc};
Point(11) = {0.5,0.5,-1,lc};
Point(22) = {0.6,0.6,1,lc};

Line(5) = {11,22};

<I><FONT COLOR="#B22222">// Anisotropic attractors can be defined on points and lines:
</FONT></I>
Attractor Line{5} = {.1, 0.01, 17};

Attractor Line{1,2} = {0.1, 0.005, 3};
</PRE>
<HR>
<A NAME="file9">
<H1>t8.geo 9/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 8
 * 
 *  Post-Processing, Scripting, Animations, Options
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// The first example is included, as well as two post-processing maps
</FONT></I><I><FONT COLOR="#B22222">// (for the format of the post-processing maps, see the FORMATS file):
</FONT></I>
Include &quot;t1.geo&quot; ;
Include &quot;view1.pos&quot; ;
Include &quot;view1.pos&quot; ;

<I><FONT COLOR="#B22222">// Some general options are set (all the options specified
</FONT></I><I><FONT COLOR="#B22222">// interactively can be directly specified in the ascii input
</FONT></I><I><FONT COLOR="#B22222">// files. The current options can be saved into a file by selecting
</FONT></I><I><FONT COLOR="#B22222">// 'File-&gt;Save as-&gt;GEO complete options')...
</FONT></I>
General.Trackball = 0 ;
General.RotationX = 0 ;
General.RotationY = 0 ;
General.RotationZ = 0 ;
General.Color.Background = White ;
General.Color.Text = Black ;
General.Orthographic = 0 ;
General.Axes = 0 ;

<I><FONT COLOR="#B22222">// ...as well as some options for each post-processing view...
</FONT></I>
View[0].Name = &quot;This is a very stupid demonstration...&quot; ;
View[0].IntervalsType = 2 ;
View[0].OffsetZ = 0.05 ;
View[0].RaiseZ = 0 ;
View[0].Light = 1 ;

View[1].Name = &quot;...of Gmsh's scripting capabilities&quot; ;
View[1].IntervalsType = 1 ;
View[1].ColorTable = { Green, Blue } ;
View[1].NbIso = 10 ;

<I><FONT COLOR="#B22222">// ...and loop from 1 to 255 with a step of 1 is performed (to use a
</FONT></I><I><FONT COLOR="#B22222">// step different from 1, just add a third argument in the list,
</FONT></I><I><FONT COLOR="#B22222">// e.g. 'For num In {0.5:1.5:0.1}' increments num from 0.5 to 1.5 with
</FONT></I><I><FONT COLOR="#B22222">// a step of 0.1):
</FONT></I>
t = 0 ;

For num In {1:255}

  View[0].TimeStep = t ;
  View[1].TimeStep = t ;

  t = (View[0].TimeStep &lt; View[0].NbTimeStep-1) ? t+1 : 0 ;
  
  View[0].RaiseZ += 0.01*t ;

  If (num == 3)
    <I><FONT COLOR="#B22222">// We want to use mpeg_encode to create a nice 320x240 animation
</FONT></I>    <I><FONT COLOR="#B22222">// for all frames when num==3:
</FONT></I>    General.GraphicsWidth = 320 ; 
    General.GraphicsHeight = 240 ;
  EndIf

  <I><FONT COLOR="#B22222">// It is possible to nest loops:
</FONT></I>
  For num2 In {1:50}

    General.RotationX += 10 ;
    General.RotationY = General.RotationX / 3 ;
    General.RotationZ += 0.1 ;
 
    Sleep 0.01; <I><FONT COLOR="#B22222">// sleep for 0.01 second
</FONT></I>    Draw; <I><FONT COLOR="#B22222">// draw the scene
</FONT></I>
    If ((num == 3) &amp;&amp; (num2 &lt; 10))
      <I><FONT COLOR="#B22222">// The Sprintf function permits to create complex strings using
</FONT></I>      <I><FONT COLOR="#B22222">// variables (since all Gmsh variables are treated internally as
</FONT></I>      <I><FONT COLOR="#B22222">// double precision numbers, the format should only contain valid
</FONT></I>      <I><FONT COLOR="#B22222">// double precision number format specifiers):
</FONT></I>      Print Sprintf(&quot;t8-0%g.jpg&quot;, num2);
    EndIf

    If ((num == 3) &amp;&amp; (num2 &gt;= 10))
      Print Sprintf(&quot;t8-%g.jpg&quot;, num2);
    EndIf

  EndFor

  If(num == 3)
    <I><FONT COLOR="#B22222">// We make a system call to generate the mpeg
</FONT></I>    System &quot;mpeg_encode t8.par&quot; ;    
  EndIf

EndFor


<I><FONT COLOR="#B22222">// Here is the list of available scripting commands:
</FONT></I><I><FONT COLOR="#B22222">//  
</FONT></I><I><FONT COLOR="#B22222">//  Merge string;     (to merge a file)
</FONT></I><I><FONT COLOR="#B22222">//  Draw;             (to draw the scene)
</FONT></I><I><FONT COLOR="#B22222">//  Mesh int;         (to perform the mesh generation; 'int' = 0, 1, 2 or 3)
</FONT></I><I><FONT COLOR="#B22222">//  Save string;      (to save the mesh)
</FONT></I><I><FONT COLOR="#B22222">//  Print string;     (to print the graphic window)
</FONT></I><I><FONT COLOR="#B22222">//  Sleep expr;       (to sleep during expr seconds)
</FONT></I><I><FONT COLOR="#B22222">//  Delete View[int]; (to free the view int)
</FONT></I><I><FONT COLOR="#B22222">//  Delete Meshes;    (to free all meshes)
</FONT></I><I><FONT COLOR="#B22222">//  System string;    (to execute a system call)
</FONT></I></PRE>
<HR>
<A NAME="file10">
<H1>t9.geo 10/10</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">/********************************************************************* 
 *
 *  Gmsh tutorial 9
 * 
 *  Post-Processing, Plugins
 *
 *********************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">// Plugins can be added to Gmsh in order to extend its
</FONT></I><I><FONT COLOR="#B22222">// capabilities. For example, post-processing plugins can modify a
</FONT></I><I><FONT COLOR="#B22222">// view, or create a new view based on previously loaded views. Three
</FONT></I><I><FONT COLOR="#B22222">// default plugins are available at the time of writing: CutMap,
</FONT></I><I><FONT COLOR="#B22222">// CutPlane and CutSphere. These plugins are just examples of how
</FONT></I><I><FONT COLOR="#B22222">// plugins (will) work.
</FONT></I>
<I><FONT COLOR="#B22222">// Let's load a three dimension scalar view
</FONT></I>
Include &quot;view3.pos&quot; ;

<I><FONT COLOR="#B22222">// Plugins can be controlled as other options in Gmsh. For example,
</FONT></I><I><FONT COLOR="#B22222">// the CutMap plugin extracts an isovalue surface from a 3D scalar
</FONT></I><I><FONT COLOR="#B22222">// view. The plugin can either be called from the graphical interface
</FONT></I><I><FONT COLOR="#B22222">// (right click on the view button, then Plugins-&gt;CutMap), or from
</FONT></I><I><FONT COLOR="#B22222">// the command file, as is shown below.
</FONT></I>
<I><FONT COLOR="#B22222">// This sets the optional parameter A of the CutMap plugin to the
</FONT></I><I><FONT COLOR="#B22222">// value 0.34 (see the About in the graphical interface for the
</FONT></I><I><FONT COLOR="#B22222">// documentation of each plugin), and runs the plugin:
</FONT></I>
Plugin(CutMap).A = 0.67 ; 
Plugin(CutMap).Run ; 

Plugin(CutPlane).A = 0 ; 
Plugin(CutPlane).B = 0.2 ; 
Plugin(CutPlane).C = 1 ; 
Plugin(CutPlane).D = 0 ; 
Plugin(CutPlane).Run ; 

View[0].Light = 1;
View[0].IntervalsType = 2;
View[0].NbIso = 6;
View[0].SmoothNormals = 1;

View[1].IntervalsType = 2;

View[2].IntervalsType = 2;
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU enscript 1.6.1</A>.</ADDRESS>
</BODY>
</HTML>
